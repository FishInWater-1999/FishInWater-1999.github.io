<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="什么是 Room ？ 谷歌为了帮助开发者解决 Android 架构设计问题，在 Google I/O 2017 发布一套帮助开发者解决 Android 架构设计的方案：Android Architecture Components，而我们的 Room 正是这套方案的两大模块之一。  定义：数据库解决方案 组成：Database、Entity、DAO  为什么本文叫谷歌范例？ 为了方便开发者进行学习">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 让你的 Room 搭上 RxJava 的顺风车 从重复的代码中解脱出来">
<meta property="og:url" content="http://yoursite.com/2019/10/03/101197865/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="什么是 Room ？ 谷歌为了帮助开发者解决 Android 架构设计问题，在 Google I/O 2017 发布一套帮助开发者解决 Android 架构设计的方案：Android Architecture Components，而我们的 Room 正是这套方案的两大模块之一。  定义：数据库解决方案 组成：Database、Entity、DAO  为什么本文叫谷歌范例？ 为了方便开发者进行学习">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-10-04T10:36:20.768Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android 让你的 Room 搭上 RxJava 的顺风车 从重复的代码中解脱出来">
<meta name="twitter:description" content="什么是 Room ？ 谷歌为了帮助开发者解决 Android 架构设计问题，在 Google I/O 2017 发布一套帮助开发者解决 Android 架构设计的方案：Android Architecture Components，而我们的 Room 正是这套方案的两大模块之一。  定义：数据库解决方案 组成：Database、Entity、DAO  为什么本文叫谷歌范例？ 为了方便开发者进行学习">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/10/03/101197865/">





  <title>Android 让你的 Room 搭上 RxJava 的顺风车 从重复的代码中解脱出来 | Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-首页"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-关于我"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-标签"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-归档"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/03/101197865/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android 让你的 Room 搭上 RxJava 的顺风车 从重复的代码中解脱出来</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-03T18:43:12+08:00">
                2019-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="什么是-Room-？"><a href="#什么是-Room-？" class="headerlink" title="什么是 Room ？"></a>什么是 Room ？</h1><hr>
<p>谷歌为了帮助开发者解决 Android 架构设计问题，在 Google I/O 2017 发布一套帮助开发者解决 Android 架构设计的方案：Android Architecture Components，而我们的 Room 正是这套方案的两大模块之一。</p>
<ul>
<li>定义：数据库解决方案</li>
<li>组成：Database、Entity、DAO</li>
</ul>
<h1 id="为什么本文叫谷歌范例？"><a href="#为什么本文叫谷歌范例？" class="headerlink" title="为什么本文叫谷歌范例？"></a>为什么本文叫谷歌范例？</h1><hr>
<p>为了方便开发者进行学习和理解，Google 在 GitHub 上上传了一系列的 Android Architecture Components 开源代码：<a href="https://github.com/googlesamples/android-architecture-components" target="_blank" rel="noopener">googlesamples/android-architecture-components</a> 本文就是通过解析这套范例的第一部分：<a href="https://github.com/googlesamples/android-architecture-components/tree/master/BasicRxJavaSample" target="_blank" rel="noopener">BasicRxJavaSample</a> 来对 Room 的使用进行分析。</p>
<p>关于本文中的代码以及后续文章中的代码，我已经上传至我的 GitHub 欢迎大家围观、star<br>详见-&gt; <a href="https://github.com/FishInWater-1999/ArchitectureComponentsStudy" target="_blank" rel="noopener">FishInWater-1999/ArchitectureComponentsStudy</a></p>
<h1 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h1><hr>
<h4 id="为什么我们要学-Room"><a href="#为什么我们要学-Room" class="headerlink" title="为什么我们要学 Room"></a>为什么我们要学 Room</h4><p>相比于我们直接使用传统方式，如果直接使用 <code>Java</code> 代码进行 <code>SQLite</code> 操作，每次都需要手写大量重复的代码，对于我们最求梦想的程序员来说，这种无聊的过程简直是一种折磨。于是，<code>Room</code> 也就应运而生了</p>
<ul>
<li>它通过注解处理器的形式，将繁琐无趣的代码封装起来，我们只需要添加一个简单的注解，就可以完成一系列复杂的功能！</li>
</ul>
<blockquote>
<p>首先我们需要了解下 <code>Room</code> 的基本组成</p>
</blockquote>
<p>前面我们已经说过 Room 的使用，主要由 Database、Entity、DAO 三大部分组成，那么这三大组成部分又分别是什么呢？</p>
<ul>
<li>Database：创建一个由 Room 管理的数据库，并在其中自定义所需要操作的数据库表</li>
</ul>
<h6 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h6><pre><code>1. 必须是abstract类而且的extends RoomDatabase。

2. 必须在类头的注释中包含与数据库关联的实体列表(Entity对应的类)。

3. 包含一个具有0个参数的抽象方法，并返回用@Dao注解的类。</code></pre><h6 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h6><p>通过单例模式实现，你可以通过静态 getInstance(…) 方法，获取数据库实例：</p>
<p><code>public static UsersDatabase getInstance(Context context)</code></p>
<ul>
<li><p>Entity：数据库中，某个表的实体类，如：<br><code>@Entity(tableName = &quot;users&quot;)</code><br><code>public class User {...}</code></p>
</li>
<li><p>DAO：具体访问数据库的方法的接口<br><code>@Dao</code><br><code>public interface UserDao {...}</code></p>
</li>
</ul>
<h1 id="BasicRxJavaSample-源码解析"><a href="#BasicRxJavaSample-源码解析" class="headerlink" title="BasicRxJavaSample 源码解析"></a>BasicRxJavaSample 源码解析</h1><hr>
<p>由于是源码解析，那我就以：从基础的类开始，一层层向上，抽丝剥茧，最后融为一体的方式，给大家进行解析。那么现在就让我们开始吧。</p>
<h4 id="表的搭建"><a href="#表的搭建" class="headerlink" title="表的搭建"></a>表的搭建</h4><p>Room 作为一个 Android 数据库操作的注解集合，最基本操作就是对我们数据库进行的。所以，先让我们试着建立一张名为 “users” 的数据表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 应用测试的表结构模型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Entity</span>(tableName = <span class="string">"users"</span>)<span class="comment">// 表名注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主键</span></span><br><span class="line"><span class="comment">     * 由于主键不能为空，所以需要 <span class="doctag">@NonNull</span> 注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"userid"</span>)<span class="comment">// Room 列注解</span></span><br><span class="line">    <span class="keyword">private</span> String mId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名</span></span><br><span class="line"><span class="comment">     * 普通列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"username"</span>)</span><br><span class="line">    <span class="keyword">private</span> String mUserName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     * 设置为 <span class="doctag">@Ignore</span> 将其忽视</span></span><br><span class="line"><span class="comment">     * 这样以来，这个注解方法就不会被传入 Room 中，做相应处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mUserName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Ignore</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String mUserName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mId    = UUID.randomUUID().toString();</span><br><span class="line">        <span class="keyword">this</span>.mUserName = mUserName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 我们发现与上个方法不同，该方法没有标记 <span class="doctag">@Ignore</span> 标签</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 所以编译时该方法会被传入 Room 中相应的注解处理器，做相应处理</span></span><br><span class="line"><span class="comment">     * 这里的处理应该是 add 新数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String id, String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mId = id;</span><br><span class="line">        <span class="keyword">this</span>.mUserName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mUserName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先在表头部分，我们就见到了之前说过的 <code>@Entity(...)</code> 标签，之前说过该标签表示数据库中某个表的实体类，我们查看它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Entity &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>从中我们可以知道该注解实在编译注解所在的类时触发的，这是我们注意到 Google 对该类的介绍是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Marks a class as an entity. This class will have a mapping SQLite table in the database.</span><br></pre></td></tr></table></figure>

<p>由此可知当注解所在的类，比如我们的这个 <code>User</code> 类编译时，相应的注解处理器就会调用其内部相应的代码，建立一个名为 <code>users</code> （在 <code>@Entity(tableName = &quot;users&quot;)</code> 中传入的数据表 ）</p>
<p><strong>我们再往下看：</strong></p>
<ul>
<li>@ColumnInfo(name = “userid”) ：该注解注解的数据成员，将会在表中生成相应的名为：<code>userid</code> 的列</li>
<li>@PrimaryKey ：顾名思义该注解与<code>@ColumnInfo(name = &quot;...&quot;)</code> 注解一起使用，表示表中的主键，这里要注意一点，在 <code>@Entity</code> 的源码中强调：Each entity must have at least 1 field annotated with {@link PrimaryKey}. 也就是说一个被 <code>@Entity(...)</code>  标注的数据表类中至少要有一个主键</li>
<li>@Ignore ：被该注解注释的数据成员、方法，将会被注解处理器忽略，不进行处理</li>
</ul>
<p>这里我们发现，代码中有存在两个构造方法，为什么 GoogleSample 中会存在这种看似多此一举的情况呢？我们再仔细观察就会发想，上方的构造方法标记了 <code>@Ignore</code> 标签，而下方的构造方法却没有。由于在 <code>@Entity</code> 标注的类中，构造方法和列属性的 <code>get()</code> 方法都会被注解处理器自动识别处理。我们就不难想到，Google 之所以这样设计，是因为我们于是需要创建临时的 <code>User</code> 对象，但我们又不希望 <code>@Entity</code> 在我们调用构造方法时，就将其存入数据库。所以我们就有了这个被 <code>@Ignore</code> 的构造方法，用于创建不被自动存入数据库的临时对象，等到我们想将这个对象存入数据库时，调用<code>User(String id, String userName)</code> 即可。</p>
<h4 id="UserDao"><a href="#UserDao" class="headerlink" title="UserDao"></a>UserDao</h4><p>上面我们通过 <code>@Entity</code> 建立了一张 <code>users</code> 表，下面就让我们用 <code>@Dao</code> 注解来变写 <code>UserDao</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为了简便，我们只在表中存入1个用户信息</span></span><br><span class="line"><span class="comment">     * 这个查询语句可以获得 所有 User 但我们只需要第一个即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM Users LIMIT 1"</span>)</span><br><span class="line">    <span class="function">Flowable&lt;User&gt; <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 想数据库中插入一条 User 对象</span></span><br><span class="line"><span class="comment">     * 若数据库中已存在，则将其替换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Insert</span>(onConflict = OnConflictStrategy.REPLACE)</span><br><span class="line">    <span class="function">Completable <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空所有数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"DELETE FROM Users"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAllUsers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照我们正常编写的习惯，我们会在该类中，编写相应的数据库操作代码。但与之不同的是采用 <code>Room</code> 之后，我们将其变为一个接口类，并且只需要编写和设定相应的标签即可，不用再去关心存储操作的具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为了简便，我们只在表中存入1个用户信息</span></span><br><span class="line"><span class="comment"> * 这个查询语句可以获得 所有 User 但我们只需要第一个即可</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Query</span>(<span class="string">"SELECT * FROM Users LIMIT 1"</span>)</span><br><span class="line"><span class="function">Flowable&lt;User&gt; <span class="title">getUser</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p> 这里我们看到，该查询方法使用的是 <code>@Query</code> 注解，那么这个注解的具体功能是什么呢？Google 官方对它的解释是：在一个被标注了 <code>@Dao</code> 标签的类中，用于查询的方法。顾名思义被该注解标注的方法，会被 <code>Room</code> 的注解处理器识别，当作一个数据查询方法，至于具体的查询逻辑并不需要我们关心，我们只需要将 <code>SQL 语句</code> 作为参数，传入 <code>@Query(...)</code> 中即可。之后我们发现，该方法返回的是一个背压 <code>Flowable&lt;...&gt;</code> 类型的对象，这是为了防止表中数据过多，读取速率远大于接收数据，从而导致内存溢出的问题，具体详见 <code>RxJava</code> 的教程，这里我就不赘述了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 想数据库中插入一条 User 对象</span></span><br><span class="line"><span class="comment"> * 若数据库中已存在，则将其替换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Insert</span>(onConflict = OnConflictStrategy.REPLACE)</span><br><span class="line"><span class="function">Completable <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们看到，上述方法被 <code>@Insert</code> 注解所标注，从名字就能看出，这将会是一个插入方法。顾名思义被 <code>@Insert</code> 标注的方法，会用于向数据库中插入数据，唯一让我们迷茫的是括号中的这个 <code>onConflict</code>  参数，<code>onConflict</code>  意为“冲突”，再联想下我们日常生活中的数据库操作，就不难想到：这是用来设定，当插入数据库中的数据，与原数据发生冲突时的处理方法。这里我们传入的是 <code>OnConflictStrategy.REPLACE</code> ，意为“如果数据发生冲突，则用其替换掉原数据”，除此之外还有很多相应操作的参数，比如<code>ROLLBACK</code> <code>ABORT</code> 等，篇幅原因就不详细说明了，大家可以自行查阅官方文档。还有一点值得说的是这个 <code>Completable</code> ，该返回值是 <code>RxJava</code> 的基本类型，它只处理 <code>onComplete</code> <code>onError</code> 事件，可以看成是Rx的Runnable。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空所有数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Query</span>(<span class="string">"DELETE FROM Users"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteAllUsers</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>最后这个方法就是清空 <code>users</code> 表中的所有内容，很简单，这里就不做说明了。唯一需要注意的是，这里使用了 <code>DELETE FROM 表名</code> 的形式，而不是 <code>truncate table 表名</code> ，区别就在于：效率上<code>truncate</code>比<code>delete</code>快，但<code>truncate</code> 相当于保留表的结构，重新创建了这个表，所以删除后不记录日志，不可以恢复数据。</p>
<h4 id="UsersDatabase"><a href="#UsersDatabase" class="headerlink" title="UsersDatabase"></a>UsersDatabase</h4><p>有关于 <code>Room</code> 的三大组成我们已经讲完了两个，现在就让我们看看最后一个 <code>@Database</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database</span>(entities = &#123;User.class&#125;, version = <span class="number">1</span>, exportSchema = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UsersDatabase</span> <span class="keyword">extends</span> <span class="title">RoomDatabase</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例模式</span></span><br><span class="line"><span class="comment">     * volatile 确保线程安全</span></span><br><span class="line"><span class="comment">     * 线程安全意味着改对象会被许多线程使用</span></span><br><span class="line"><span class="comment">     * 可以被看作是一种 “程度较轻的 synchronized”</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> UsersDatabase INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法由于获得 DataBase 对象</span></span><br><span class="line"><span class="comment">     * abstract</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> UserDao <span class="title">userDao</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UsersDatabase <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若为空则进行实例化</span></span><br><span class="line">        <span class="comment">// 否则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (UsersDatabase.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class="line">                            UsersDatabase.class, <span class="string">"Sample.db"</span>)</span><br><span class="line">                            .build();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>老样子， <code>Google</code> 定义中是这么写的：将一个类标记为 <code>Room</code> 数据库。顾名思义，我们需要在标记了该标签的类里，做具体的数据库操作，比如数据库的建立、版本更新等等。我们看到，我们向其中传入了多个参数，包括：<code>entities</code> 以数组结构，标记一系列数据库中的表，这个例子中我们只有一个 <code>User</code> 表，所以只传入一个； <code>version</code> 数据库版本；<code>exportSchema</code> 用于历史版本库的导出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式</span></span><br><span class="line"><span class="comment"> * volatile 确保线程安全</span></span><br><span class="line"><span class="comment"> * 线程安全意味着改对象会被许多线程使用</span></span><br><span class="line"><span class="comment"> * 可以被看作是一种 “程度较轻的 synchronized”</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> UsersDatabase INSTANCE;</span><br></pre></td></tr></table></figure>

<p> 可以看出这是一个单例模式，用于创建一个全局可获得的 UsersDatabase 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UsersDatabase <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若为空则进行实例化</span></span><br><span class="line">    <span class="comment">// 否则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (UsersDatabase.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>)&#123;</span><br><span class="line">                INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class="line">                        UsersDatabase.class, <span class="string">"Sample.db"</span>)</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是单例模式对象 INSTANCE 的获得方法，不明白的同学可以去看我这篇 <a href="https://blog.csdn.net/qq_43377749/article/details/96324909" target="_blank" rel="noopener">单例模式-全局可用的 context 对象，这一篇就够了</a></p>
<h4 id="UserDataSource"><a href="#UserDataSource" class="headerlink" title="UserDataSource"></a>UserDataSource</h4><p>我们可以看到：绝大多数的数据库操作方法，都定义在了 <code>UserDao</code> 中，虽然一般注解类的方法不会被继承，但是有些被特殊标记的方法可能会被继承，但是我们之后要建立的很多功能类中，都需要去调用 <code>UserDao</code> 里的方法。所以我们这里定义 <code>UserDataSource</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从数据库中读取信息</span></span><br><span class="line"><span class="comment">     * 由于读取速率可能 远大于 观察者处理速率，故使用背压 Flowable 模式</span></span><br><span class="line"><span class="comment">     * Flowable：https://www.jianshu.com/p/ff8167c1d191/</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Flowable&lt;User&gt; <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据写入数据库中</span></span><br><span class="line"><span class="comment">     * 如果数据已经存在则进行更新</span></span><br><span class="line"><span class="comment">     * Completable 可以看作是 RxJava 的 Runnale 接口</span></span><br><span class="line"><span class="comment">     * 但他只能调用 onComplete 和 onError 方法，不能进行 map、flatMap 等操作</span></span><br><span class="line"><span class="comment">     * Completable：https://www.jianshu.com/p/45309538ad94</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Completable <span class="title">insertOrUpdateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除所有表中所有 User 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">deleteAllUsers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接口很简单，就是一个工具，方法和  <code>UserDao</code>  一摸一样，这里我们就不赘述了。</p>
<h4 id="LocalUserDataSource"><a href="#LocalUserDataSource" class="headerlink" title="LocalUserDataSource"></a>LocalUserDataSource</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalUserDataSource</span> <span class="keyword">implements</span> <span class="title">UserDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDao mUserDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LocalUserDataSource</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mUserDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flowable&lt;User&gt; <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mUserDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Completable <span class="title">insertOrUpdateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mUserDao.insertUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAllUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mUserDao.deleteAllUsers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先看看官方的解析：“使用 <code>Room</code> 数据库作为一个数据源。”即通过该类的对象所持有的 <code>UserDao</code> 对象，进行数据库的增删改查操作。</p>
<ul>
<li>到此为止，有关于 Room 对数据库的操作部分就讲完了，接下来我们进行视图层搭建的解析。</li>
</ul>
<hr>
<h4 id="UserViewModel"><a href="#UserViewModel" class="headerlink" title="UserViewModel"></a>UserViewModel</h4><p>首先我们先实现 <code>ViewModel</code> 类，那什么是 <code>ViewModel</code> 类呢？从字面上理解的话，它肯定是跟视图 <code>View</code> 以及数据 <code>Model</code> 相关的。其实正像它字面意思一样，它是负责准备和管理和UI组件 <code>Fragment/Activity</code> 相关的数据类，也就是说 <code>ViewModel</code> 是用来管理UI相关的数据的，同时 <code>ViewModel</code> 还可以用来负责UI组件间的通信。那么现在就来看看他的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * UserDataSource 接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDataSource mDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User mUser;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserViewModel</span><span class="params">(UserDataSource dataSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mDataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从数据库中读取所有 user 名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 背压形式发出所有 User 的名字</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 由于数据库中 User 量可能很大，可能会因为背压导致内存溢出</span></span><br><span class="line"><span class="comment">     * 故采用 Flowable 模式，取代 Observable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flowable&lt;String&gt; <span class="title">getUserName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mDataSource.getUser()</span><br><span class="line">                .map(<span class="keyword">new</span> Function&lt;User, String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> user.getUserName();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新/添加 数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 判断是否为空，若为空则创建新 User 进行存储</span></span><br><span class="line"><span class="comment">     * 若不为空，说明该 User 存在，这获得其主键 'getId()' 和传入的新 Name 拼接，生成新 User 存储</span></span><br><span class="line"><span class="comment">     * 通过 insertOrUpdateUser 接口，返回 Comparable 对象，监听是否存储成功</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Completable <span class="title">updateUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        mUser = mUser == <span class="keyword">null</span></span><br><span class="line">                ? <span class="keyword">new</span> User(userName)</span><br><span class="line">                : <span class="keyword">new</span> User(mUser.getId(), userName);</span><br><span class="line">        <span class="keyword">return</span> mDataSource.insertOrUpdateUser(mUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码结构非常简单，<code>mDataSource</code> 就是我们前面建立的 <code>UserDataSource</code> 接口对象，由于我们的数据库操作控制类：<code>LocalUserDataSource</code> 是通过是实现该接口的，所以我们就可以在外部将 <code>LocalUserDataSource</code> 对象传入，从而对他的方法进行相应的回调，也就是先实现了所需的数据库操作。每个方法的功能，我已经在注释中给出，这里就不再赘述</p>
<h4 id="ViewModelFactory"><a href="#ViewModelFactory" class="headerlink" title="ViewModelFactory"></a>ViewModelFactory</h4><p>有上面我们可以看到，我们已经有了进行数据处理的 <code>ViewModel</code> 类，那么我们这里的 <code>ViewModelFactory</code> 类又有什么作用呢？让我们先看下范例中的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelFactory</span> <span class="keyword">implements</span> <span class="title">ViewModelProvider</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDataSource mDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewModelFactory</span><span class="params">(UserDataSource dataSource)</span> </span>&#123;</span><br><span class="line">        mDataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你需要通过 ViewModelProvider.Factory 的 create 方法来创建(自定义的) ViewModel</span></span><br><span class="line">    <span class="comment">// 参考文档：https://medium.com/koderlabs/viewmodel-with-viewmodelprovider-factory-the-creator-of-viewmodel-8fabfec1aa4f</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(@NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为什么这里用 isAssignableFrom 来判断传入的 modelClass 类的类型， 而不直接用 isInstance 判断？</span></span><br><span class="line">        <span class="comment">// 答：二者功能一样，但如果传入值（modelClass 为空）则 isInstance 会报错奔溃，而 isAssignableFrom 不会</span></span><br><span class="line">        <span class="keyword">if</span> (modelClass.isAssignableFrom(UserViewModel.class)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) <span class="keyword">new</span> UserViewModel(mDataSource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown ViewModel class"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ViewModelFactory</code> 继承自 <code>ViewModelProvider.Factory</code> ，它负责帮你创建 <code>ViewModel</code> 实例。但你也许会问，我们不是已经有了 <code>ViewModel</code> 的构造方法了吗？在用 <code>ViewModelFactory</code> 不是多此一举？如果还不熟悉 <code>ViewModelFactory</code> 有关内容的，可以看下这篇：<a href="https://blog.csdn.net/qq_43377749/article/details/100856599" target="_blank" rel="noopener">ViewModel 和 ViewModelProvider.Factory：ViewModel 的创建者</a></p>
<h4 id="Injection"><a href="#Injection" class="headerlink" title="Injection"></a>Injection</h4><p>关于 <code>Injection</code> ，这是个帮助类，它和 Room 的逻辑功能并没有关系。<code>Sample</code> 中将其独立出来用于各个对象、类型的注入，先让我们看下该类的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Injection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过该方法实例化出能操作数据库的 LocalUserDataSource 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserDataSource <span class="title">provideUserDateSource</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得 RoomDatabase</span></span><br><span class="line">        UsersDatabase database = UsersDatabase.getInstance(context);</span><br><span class="line">        <span class="comment">// 将可操作 UserDao 传入</span></span><br><span class="line">        <span class="comment">// 实例化出可操作 LocalUserDataSource 对象方便对数据库进行操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LocalUserDataSource(database.userDao());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得 ViewModelFactory 对象</span></span><br><span class="line"><span class="comment">     * 为 ViewModel 实例化作准备</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelFactory <span class="title">provideViewModelFactory</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        UserDataSource dataSource = provideUserDateSource(context);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ViewModelFactory(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类有两个方法组成，实现了各个类型数据相互间的转换，想再让我们先看下第一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过该方法实例化出能操作数据库的 LocalUserDataSource 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserDataSource <span class="title">provideUserDateSource</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得 RoomDatabase</span></span><br><span class="line">    UsersDatabase database = UsersDatabase.getInstance(context);</span><br><span class="line">    <span class="comment">// 将可操作 UserDao 传入</span></span><br><span class="line">    <span class="comment">// 实例化出可操作 LocalUserDataSource 对象方便对数据库进行操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LocalUserDataSource(database.userDao());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，我们首先接到了我们的 <code>context</code> 对象，通过 <code>UsersDatabase.getInstance(context)</code> 方法，让 <code>database</code> 持有 <code>context</code> ，实现数据库的链接和初始化。同时放回一个 <code>LocalUserDataSource</code> 对象，这样一来我们就可以对数据表中的内容惊醒相应的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得 ViewModelFactory 对象</span></span><br><span class="line"><span class="comment"> * 为 ViewModel 实例化作准备</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelFactory <span class="title">provideViewModelFactory</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    UserDataSource dataSource = provideUserDateSource(context);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ViewModelFactory(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的功能非常明确，就是为我们实例化出一个 <code>ViewModelFactory</code> 对象，为我们往后创建 <code>ViewModel</code> 作准备。可以看到，这里我们调用了前面的 <code>provideUserDateSource</code> 方法，通过该方法获得了对数据库操作的 <code>LocalUserDataSource</code> 对象，这里我们就看到了单例模式使用的先见性，使得数据库不会被反复的创建、连接。</p>
<ul>
<li>好了，至此所有准备工作都已经完成，让我们开始视图层 UserActivity 的调用</li>
<li>由于 <code>UserActivity</code> 的内容较多我就不贴完整的代码，我们逐步进行讲解</li>
</ul>
<hr>
<h4 id="准备数据成员"><a href="#准备数据成员" class="headerlink" title="准备数据成员"></a>准备数据成员</h4><p>首先我们准备了所需的给类数据成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = UserActivity.class.getSimpleName();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TextView mUserName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> EditText mUserNameInput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Button mUpdateButton;</span><br><span class="line"><span class="comment">// 一个 ViewModel 用于获得 Activity &amp; Fragment 实例</span></span><br><span class="line"><span class="keyword">private</span> ViewModelFactory mViewModelFactory;</span><br><span class="line"><span class="comment">// 用于访问数据库</span></span><br><span class="line"><span class="keyword">private</span> UserViewModel mViewModel;</span><br><span class="line"><span class="comment">// disposable 是订阅事件，可以用来取消订阅。防止在 activity 或者 fragment 销毁后仍然占用着内存，无法释放。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CompositeDisposable mDisposable = <span class="keyword">new</span> CompositeDisposable();</span><br></pre></td></tr></table></figure>

<ul>
<li>首先界面操作的各个控件</li>
<li>接这就是 <code>mViewModelFactory</code> 、 <code>mViewModel</code> 两个数据成员，用于负责数据源的操作</li>
<li>再就是一个 <code>CompositeDisposable</code> 对象，用于管理订阅事件，防止 Activity 结束后，订阅仍在进行的情况</li>
</ul>
<h4 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate"></a>onCreate</h4><p>控件、数据源层、数据库等的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_user);</span><br><span class="line"></span><br><span class="line">    mUserName = findViewById(R.id.user_name);</span><br><span class="line">    mUserNameInput = findViewById(R.id.user_name_input);</span><br><span class="line">    mUpdateButton = findViewById(R.id.update_user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化 ViewModelFactory 对象，准备实例化 ViewModel</span></span><br><span class="line">    mViewModelFactory = Injection.provideViewModelFactory(<span class="keyword">this</span>);</span><br><span class="line">    mViewModel = <span class="keyword">new</span> ViewModelProvider(<span class="keyword">this</span>, mViewModelFactory).get(UserViewModel.class);</span><br><span class="line">    mUpdateButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            updateUserName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先是各类控件的初始化</li>
<li>接着是 <code>ViewModel</code> 的初始化，在这过程中，也就实现了数据库的链接</li>
<li>用户信息按钮监听器绑定，点击执行 <code>updateUserName</code> 方法如下</li>
</ul>
<h4 id="updateUserName"><a href="#updateUserName" class="headerlink" title="updateUserName"></a>updateUserName</h4><p>修改数据库中用户信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String userName = mUserNameInput.getText().toString();</span><br><span class="line">    <span class="comment">// 在完成用户名更新之前禁用“更新”按钮</span></span><br><span class="line">    mUpdateButton.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 开启观察者模式</span></span><br><span class="line">    <span class="comment">// 更新用户信息，结束后重新开启按钮</span></span><br><span class="line">    mDisposable.add(mViewModel.updateUserName(userName)</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            mUpdateButton.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">new</span> Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"accept: Unable to update username"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获得新的用户名</li>
<li>将按钮设为不可点击</li>
<li>在 <code>io</code> 线程中访问数据库进行修改</li>
<li>切换到主线程进行相应处理，比如让按钮恢复到可点击状态</li>
</ul>
<h4 id="onStart"><a href="#onStart" class="headerlink" title="onStart"></a>onStart</h4><p>初始化用户信息，修改 <code>UI</code> 界面内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    <span class="comment">// 观察者模式</span></span><br><span class="line">    <span class="comment">// 通过 ViewModel 从数据库中读取 UserName 显示</span></span><br><span class="line">    <span class="comment">// 如果读取失败，显示错误信息</span></span><br><span class="line">    mDisposable.add(mViewModel.getUserName()</span><br><span class="line">            .subscribeOn(Schedulers.io())</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            mUserName.setText(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">new</span> Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Unable to update username"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>io</code> 线程中进行数据库访问</li>
<li>切换到主线程，修改 <code>UI</code> 信息</li>
</ul>
<h4 id="onStop"><a href="#onStop" class="headerlink" title="onStop"></a>onStop</h4><p>取消订阅</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    <span class="comment">// 取消订阅。防止在 activity 或者 fragment 销毁后仍然占用着内存，无法释放。</span></span><br><span class="line">    mDisposable.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过我们之前实例化的 <code>CompositeDisposable</code> 对象，解除订阅关系</li>
</ul>
<hr>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h4 id="Demo-地址"><a href="#Demo-地址" class="headerlink" title="Demo 地址"></a>Demo 地址</h4><p><a href="https://github.com/FishInWater-1999/ArchitectureComponentsStudy" target="_blank" rel="noopener">ArchitectureComponentsStudy</a></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>学会使用 <code>Android Architecture Components</code> 提供的组件简化我们的开发，能够使我们开发的应用模块更解耦更稳定，视图与数据持久层分离，以及更好的扩展性与灵活性。最后，码字不易，别忘了点个赞哦</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/10/03/101837623/" rel="prev" title="My New Post">
                My New Post <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是-Room-？"><span class="nav-number">1.</span> <span class="nav-text">什么是 Room ？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么本文叫谷歌范例？"><span class="nav-number">2.</span> <span class="nav-text">为什么本文叫谷歌范例？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#开始之前"><span class="nav-number">3.</span> <span class="nav-text">开始之前</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么我们要学-Room"><span class="nav-number">3.0.0.1.</span> <span class="nav-text">为什么我们要学 Room</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#要求："><span class="nav-number">3.0.0.1.0.1.</span> <span class="nav-text">要求：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#使用："><span class="nav-number">3.0.0.1.0.2.</span> <span class="nav-text">使用：</span></a></li></ol></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#BasicRxJavaSample-源码解析"><span class="nav-number">4.</span> <span class="nav-text">BasicRxJavaSample 源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#表的搭建"><span class="nav-number">4.0.0.1.</span> <span class="nav-text">表的搭建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UserDao"><span class="nav-number">4.0.0.2.</span> <span class="nav-text">UserDao</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UsersDatabase"><span class="nav-number">4.0.0.3.</span> <span class="nav-text">UsersDatabase</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UserDataSource"><span class="nav-number">4.0.0.4.</span> <span class="nav-text">UserDataSource</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LocalUserDataSource"><span class="nav-number">4.0.0.5.</span> <span class="nav-text">LocalUserDataSource</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UserViewModel"><span class="nav-number">4.0.0.6.</span> <span class="nav-text">UserViewModel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ViewModelFactory"><span class="nav-number">4.0.0.7.</span> <span class="nav-text">ViewModelFactory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Injection"><span class="nav-number">4.0.0.8.</span> <span class="nav-text">Injection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#准备数据成员"><span class="nav-number">4.0.0.9.</span> <span class="nav-text">准备数据成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#onCreate"><span class="nav-number">4.0.0.10.</span> <span class="nav-text">onCreate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#updateUserName"><span class="nav-number">4.0.0.11.</span> <span class="nav-text">updateUserName</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#onStart"><span class="nav-number">4.0.0.12.</span> <span class="nav-text">onStart</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#onStop"><span class="nav-number">4.0.0.13.</span> <span class="nav-text">onStop</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#源码"><span class="nav-number">5.</span> <span class="nav-text">源码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Demo-地址"><span class="nav-number">5.0.0.1.</span> <span class="nav-text">Demo 地址</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
