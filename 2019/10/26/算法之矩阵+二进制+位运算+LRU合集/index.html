<!DOCTYPE html>
<html lang="zh-CN">





<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="description" content="personal website of _yuanhao">
  <meta name="author" content="_yuanhao">
  <meta name="keywords" content="_yuanhao Hexo blogs github android google developer">
  <title>“面试必备：高频算法题终章「图文解析 + 范例代码」之 矩阵 二进制 + 位运算 + LRU 合集！” ~ _yuanhao</title>
  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css">
  <link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css">
  <link rel="stylesheet" href="https://at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">
  
    <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css">
  
  <link rel="stylesheet" href="/css/main.css">

  
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>_yuanhao</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">Archives</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">Categories</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">Tags</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">About</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>


</nav>

    <div class="view intro-2"
         style="background: url('/img/default.png')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              <p>星期六, 十月 26日 2019, 11:06 晚上</p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto">
          <div class="markdown-body">
            <p><img src="https://img-blog.csdnimg.cn/20191019105602815.png" srcset="/img/loading.gif" alt="面试"></p>
<h1 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h1><p>秋招接近尾声，我总结了 <code>牛客</code>、<code>WanAndroid</code> 上，有关笔试面经的帖子中出现的算法题，结合往年考题写了这一系列文章，所有文章均与 LeetCode 进行核对、测试。欢迎食用</p>
<hr>
<p><strong>本文将覆盖 「二进制」 + 「位运算」 和 Lru 方面的面试算法题，文中我将给出：</strong></p>
<ol>
<li>面试中的题目</li>
<li>解题的思路</li>
<li>特定问题的技巧和注意事项</li>
<li>考察的知识点及其概念</li>
<li>详细的代码和<code>解析</code></li>
</ol>
<h4 id="开始之前，我们先看下会有哪些重点案例："><a href="#开始之前，我们先看下会有哪些重点案例：" class="headerlink" title="开始之前，我们先看下会有哪些重点案例："></a>开始之前，我们先看下会有哪些重点案例：</h4><p><img src="https://img-blog.csdnimg.cn/20191021201644400.png" srcset="/img/loading.gif" alt="图片"></p>
<h1 id="为了方便大家跟进学习，我在-GitHub-建立了一个仓库"><a href="#为了方便大家跟进学习，我在-GitHub-建立了一个仓库" class="headerlink" title="为了方便大家跟进学习，我在 GitHub 建立了一个仓库"></a>为了方便大家跟进学习，我在 <code>GitHub</code> 建立了一个仓库</h1><p>仓库地址：<strong><a href="https://github.com/FishInWater-1999/android_interviews/tree/master/%E7%AE%97%E6%B3%95/%E8%B6%85%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">超级干货！精心归纳<code>视频、归类、总结</code>，各位路过的老铁支持一下！给个 Star ！</a></strong><br><br></p>
<p>现在就让我们开始吧！</p>
<br>

<hr>
<p><img src="https://img-blog.csdnimg.cn/20191024000511171.png" srcset="/img/loading.gif" alt="devider"></p>
<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><hr>
<p><img src="https://img-blog.csdnimg.cn/20191021201809145.png" srcset="/img/loading.gif" alt="矩阵"></p>
<br>
<br>

<p><img src="https://img-blog.csdnimg.cn/20191024000511171.png" srcset="/img/loading.gif" alt="devider"></p>
<h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><hr>
<p>给定一个包含 <code>m x n</code> 个要素的矩阵，（<code>m</code> 行, <code>n</code> 列），按照螺旋顺序，返回该矩阵中的所有要素。</p>
<p>示例 :</p>
<pre><code class="css">输入:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
输出: [1,2,3,4,8,12,11,10,9,5,6,7]</code></pre>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>我们定义矩阵的第 k 层是到最近边界距离为 k 的所有顶点。例如，下图矩阵最外层元素都是<code>第 1 层</code>，次外层元素都是<code>第 2 层</code>，然后是<code>第 3 层</code>的。</p>
<pre><code class="css">[[1, 1, 1, 1, 1, 1, 1],
 [1, 2, 2, 2, 2, 2, 1],
 [1, 2, 3, 3, 3, 2, 1],
 [1, 2, 2, 2, 2, 2, 1],
 [1, 1, 1, 1, 1, 1, 1]]</code></pre>
<p>对于每层，我们从左上方开始以顺时针的顺序遍历所有元素，假设当前层左上角坐标是 $\text{(r1, c1)}$，右下角坐标是 $\text{(r2, c2)}$。</p>
<p>首先，遍历上方的所有元素 <code>(r1, c)</code>，按照 <code>c = c1,...,c2</code>  的顺序。然后遍历右侧的所有元素 <code>(r, c2)</code>，按照 <code>r = r1+1,...,r2</code> 的顺序。如果这一层有四条边（也就是 <code>r1 &lt; r2</code> 并且 <code>c1 &lt; c2</code> ），我们以下图所示的方式遍历下方的元素和左侧的元素。</p>
<p><img src="https://img-blog.csdnimg.cn/20191021150901496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzc3NzQ5,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="螺旋矩阵"></p>
<pre><code class="java">public List &lt; Integer &gt; spiralOrder(int[][] matrix) {
    List ans = newArrayList();
    if (matrix.length == 0)
        return ans;
    int r1 = 0, r2 = matrix.length - 1;
    int c1 = 0, c2 = matrix[0].length - 1;
    while (r1 &lt;= r2 &amp;&amp; c1 &lt;= c2) {
        for (int c = c1; c &lt;= c2; c++) ans.add(matrix[r1][c]);
        for (int r = r1 + 1; r &lt;= r2; r++) ans.add(matrix[r][c2]);
        if (r1 &lt; r2 &amp;&amp; c1 &lt; c2) {
            for (int c = c2 - 1; c &gt; c1; c--) ans.add(matrix[r2][c]);
            for (int r = r2; r &gt; r1; r--) ans.add(matrix[r][c1]);
        }
        r1++;
        r2--;
        c1++;
        c2--;
    }
    return ans;
}</code></pre>
<br>
<br>

<p><img src="https://img-blog.csdnimg.cn/20191024000511171.png" srcset="/img/loading.gif" alt="devider"></p>
<h2 id="判断数独是否合法"><a href="#判断数独是否合法" class="headerlink" title="判断数独是否合法"></a>判断数独是否合法</h2><hr>
<p>请判定一个<code>数独</code>是否有效。该数独可能只填充了部分数字，其中缺少的数字用 . 表示。</p>
<p>维护一个<code>HashSet</code>用来记同一<code>行</code>、同一<code>列</code>、同一<code>九宫格</code>是否存在相同数字</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQud2lraW1lZGlhLm9yZy93aWtpcGVkaWEvY29tbW9ucy90aHVtYi9mL2ZmL1N1ZG9rdS1ieS1MMkctMjAwNTA3MTQuc3ZnLzI1MHB4LVN1ZG9rdS1ieS1MMkctMjAwNTA3MTQuc3ZnLnBuZw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="判断数独是否合法"></p>
<p>示例 :</p>
<pre><code class="css">输入:
[
  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],
  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],
  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],
  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],
  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]
]

输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</code></pre>
<p>说明:</p>
<p>一个有效的数独（部分已被填充）<code>不一定</code>是可解的。<br>只需要根据以上规则，验证已经填入的数字是否<code>有效即可</code>。<br>给定数独序列只包含数字 <code>1-9</code> 和字符 <code>&#39;.&#39;</code> 。<br>给定数独永远是 <code>9x9</code> 形式的。`</p>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>一次迭代<br>首先，让我们来讨论下面两个问题：</p>
<p>如何枚举子数独？<br>可以使用 <code>box_index = (row / 3) * 3 + columns / 3</code>，其中 / 是整数除法。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tLzJiMTQxMzkyZTJhMTgxMWQwZThkZmRmNjI3OWIxMzUyZTU5ZmFkMGIzOTYxOTA4YzZmZjk0MTJiNmE3ZTdjY2YtaW1hZ2UucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="一次迭代"></p>
<p>如何确保行 / 列 / 子数独中没有重复项？<br>可以利用 <code>value -&gt; count</code> 哈希映射来跟踪所有已经遇到的值。</p>
<p>现在，我们完成了这个算法的所有准备工作：</p>
<p>遍历数独。<br>检查看到每个单元格值是否已经在当前的行 / 列 / 子数独中出现过：<br>如果出现重复，返回 <code>false</code>。<br>如果没有，则保留此值以进行进一步跟踪。<br>返回 <code>true</code>。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMzYvMzZfc2xpZGVfMi5wbmc?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="确保行 / 列 / 子数独中没有重复项"></p>
<pre><code class="java">public boolean isValidSudoku(char[][] board) {
    Set seen = new HashSet();
    for (int i=0; i&lt;9; ++i) {
        for (int j=0; j&lt;9; ++j) {
            char number = board[i][j];
            if (number != &#39;.&#39;)
                if (!seen.add(number + &quot; in row &quot; + i) ||
                    !seen.add(number + &quot; in column &quot; + j) ||
                    !seen.add(number + &quot; in block &quot; + i / 3 + &quot;-&quot; + j / 3))
                    return false;
        }
    }
    return true;
}</code></pre>
<br>
<br>

<p><img src="https://img-blog.csdnimg.cn/20191024000511171.png" srcset="/img/loading.gif" alt="devider"></p>
<h2 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h2><hr>
<p>给定一个<code>N×N</code>的二维矩阵表示图像，<code>90度</code>顺时针旋转图像。</p>
<p>示例 :</p>
<pre><code class="css">输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；
     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</code></pre>
<p>说明:</p>
<pre><code class="css">1 &lt;= A.length = A[0].length &lt;= 20
0 &lt;= A[i][j] &lt;= 1</code></pre>
<h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>我们先来看看每个元素在旋转的过程中是如何移动的：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tLzEyNjA1ZWZiNjBkMmVmYzY0ZTZlY2ZjZjY1NjJhOThhNDlhY2IzY2U2OTZiMGMxYWQzZGE0NmFiODk3N2ZhMTYtNDhfYW5nbGVzLnBuZw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="如何移动"></p>
<p>这提供给我们了一个思路，将给定的矩阵分成四个矩形并且将原问题划归为<code>旋转这些矩形</code>的问题。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tLzdhNjg0YjIwN2E5NTE4OGZmNjQ1MGU0NzI0ZDZlZThiZGY0MjVmYzQ4Mzc3NWE4ZTMwMDgyZWQyNTA2MGRhYzEtNDhfcmVjdGFuZ2xlcy5wbmc?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="旋转这些矩形"></p>
<p>现在的解法很直接 – 可以在第一个矩形中移动元素并且在 长度为 4 个元素的临时列表中<code>移动</code>它们。</p>
<p><img src="https://img-blog.csdnimg.cn/20191021173207924.gif" srcset="/img/loading.gif" alt="变化过程"></p>
<pre><code class="java">public void rotate(int[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return;
    }

    int length = matrix.length;

    for (int i = 0; i &lt; length / 2; i++) {
        for (int j = 0; j &lt; (length + 1) / 2; j++){
            int tmp = matrix[i][j];
            matrix[i][j] = matrix[length - j - 1][i];
            matrix[length -j - 1][i] = matrix[length - i - 1][length - j - 1];
            matrix[length - i - 1][length - j - 1] = matrix[j][length - i - 1];
            matrix[j][length - i - 1] = tmp;
        }
    }   
}</code></pre>
<br>
<br>

<p><img src="https://img-blog.csdnimg.cn/20191024000511171.png" srcset="/img/loading.gif" alt="devider"></p>
<h1 id="二进制-位运算"><a href="#二进制-位运算" class="headerlink" title="二进制 / 位运算"></a>二进制 / 位运算</h1><hr>
<p><img src="https://img-blog.csdnimg.cn/20191021201855750.png" srcset="/img/loading.gif" alt="二进制位运算"></p>
<pre><code class="css">优点：

特定情况下，计算方便，速度快，被支持面广
如果用算数方法，速度慢，逻辑复杂
位运算不限于一种语言，它是计算机的基本运算方法</code></pre>
<br>

<h2 id="知识点预热"><a href="#知识点预热" class="headerlink" title="知识点预热"></a>知识点预热</h2><hr>
<p><img src="https://img-blog.csdnimg.cn/20191021202057416.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20191024000511171.png" srcset="/img/loading.gif" alt="devider"></p>
<h2 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h2><hr>
<p>给出 <code>2 * n + 1</code>个数字，除其中一个数字之外其他每个数字均出现两次，找到这个数字。</p>
<p>异或运算具有很好的性质，相同数字异或运算后为0，并且具有交换律和结合律，故将所有数字异或运算后即可得到只出现一次的数字。</p>
<p>示例 :</p>
<pre><code class="css">输入: [4,1,2,1,2]
输出: 4</code></pre>
<br>

<h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>如果我们对 0 和二进制位做 XOR 运算，得到的仍然是这个二进制位</p>
<p>$a \oplus 0 = a$ $a⊕0=a$</p>
<p>如果我们对相同的二进制位做 XOR 运算，返回的结果是 0</p>
<p>$a \oplus a = 0$ $a⊕a=0$</p>
<p>XOR 满足交换律和结合律</p>
<p>$a \oplus b \oplus a = (a \oplus a) \oplus b = 0 \oplus b = ba⊕b⊕a=(a⊕a)⊕b=0⊕b=b$</p>
<p>所以我们只需要将<code>所有</code>的数进行 XOR 操作，得到那个唯一的数字。</p>
<br>

<pre><code class="java">public int singleNumber(int[] A) {
    if(A == null || A.length == 0) {
        return -1;
    }
    int rst = 0;
    for (int i = 0; i &lt; A.length; i++) {
        rst ^= A[i];
    }
    return rst;
}</code></pre>
<br>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度： <code>O(n)</code> 。我们只需要将 $\text{nums}$ 中的元素遍历一遍，所以时间复杂度就是 $\text{nums}$ 中的元素个数。<br>空间复杂度：<code>O(1)</code> 。</p>
<p><img src="https://img-blog.csdnimg.cn/20191024000511171.png" srcset="/img/loading.gif" alt="devider"></p>
<h2 id="格雷编码"><a href="#格雷编码" class="headerlink" title="格雷编码"></a>格雷编码</h2><p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个二进制的差异。给定一个<code>非负整数 n</code> ，表示该代码中所有二进制的总数，请找出其格雷编码顺序。一个格雷编码顺序必须以 <code>0</code> 开始，并覆盖所有的 <code>2n</code> 个整数。例子——输入：<code>2</code>；输出：[0, 1, 3, 2]；解释: <code>0 - 00</code>，<code>1 - 01</code>，<code>3 - 11</code>，<code>2 - 10</code></p>
<br>

<h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>格雷码生成公式：<code>G(i) = i ^ (i &gt;&gt; 2)</code></p>
<pre><code class="css">public ArrayList&lt;Integer&gt; grayCode(int n) {
    ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
    for (int i = 0; i &lt; (1 &lt;&lt; n); i++) {
        result.add(i ^ (i &gt;&gt; 1));
    }
    return result;
}</code></pre>
<br>
<br>

<p><img src="https://img-blog.csdnimg.cn/20191024000511171.png" srcset="/img/loading.gif" alt="devider"></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><hr>
<p><img src="https://img-blog.csdnimg.cn/20191021201916673.png" srcset="/img/loading.gif" alt="其他"></p>
<br>
<br>

<p><img src="https://img-blog.csdnimg.cn/20191024000511171.png" srcset="/img/loading.gif" alt="devider"></p>
<h2 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h2><hr>
<p>将一个整数中的数字进行<code>颠倒</code>，当颠倒后的整数<code>溢出时</code>，返回 0 (标记为 32 位整数)。</p>
<p> 示例 :</p>
<pre><code class="css">输入: -123
输出: -321</code></pre>
<br>

<h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>利用<code>除 10 取余</code>的方法，将最低位和最高<code>倒序输出</code>即可</p>
<pre><code class="java">public int reverseInteger(int n) {
    int reversed_n = 0;

    while (n != 0) {
        int temp = reversed_n * 10 + n % 10;
        n = n / 10;
        if (temp / 10 != reversed_n) {
            reversed_n = 0;
            break;
        }
        reversed_n = temp;
    }
    return reversed_n;
}</code></pre>
<br>
<br>

<p><img src="https://img-blog.csdnimg.cn/20191024000511171.png" srcset="/img/loading.gif" alt="devider"></p>
<h2 id="LRU缓存策略"><a href="#LRU缓存策略" class="headerlink" title="LRU缓存策略"></a>LRU缓存策略</h2><hr>
<p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>
<p>获取数据 <code>get(key)</code> - 如果密钥 <code>(key) 存在</code>于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 <code>put(key, value)</code> - 如果密钥<code>不存在</code>，则<code>写入</code>其数据值。当缓存容量达到上限时，它应该在写入新数据之前<code>删除</code>最近最少使用的数据值，从而为新的数据值留出空间。</p>
<p>示例:</p>
<pre><code class="css">LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得密钥 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得密钥 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4</code></pre>
<br>

<h4 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h4><p><strong>解法一：</strong></p>
<p>自定义数据结构：</p>
<ul>
<li>实现一个链表用于记录缓存，并处理调用使用频率</li>
<li>定义一个 <code>HashMap</code> 用于记录缓存内容</li>
</ul>
<pre><code class="java">public class LRUCache {
    private class Node{
        Node prev;
        Node next;
        int key;
        int value;

        public Node(int key, int value) {
            this.key = key;
            this.value = value;
            this.prev = null;
            this.next = null;
        }
    }

    private int capacity;
    private HashMap&lt;Integer, Node&gt; hs = new HashMap&lt;Integer, Node&gt;();
    private Node head = new Node(-1, -1);// 头
    private Node tail = new Node(-1, -1);// 尾

    public LRUCache(int capacity) {
        this.capacity = capacity;
        tail.prev = head;
        head.next = tail;
    }

    public int get(int key) {
        if( !hs.containsKey(key)) {            //key找不到
            return -1;
        }

        // remove current
        Node current = hs.get(key);
        current.prev.next = current.next;
        current.next.prev = current.prev;

        // move current to tail
        move_to_tail(current);            //每次get，使用次数+1，最近使用，放于尾部

        return hs.get(key).value;
    }

    public void set(int key, int value) {            //数据放入缓存
        // get 这个方法会把key挪到最末端，因此，不需要再调用 move_to_tail
        if (get(key) != -1) {
            hs.get(key).value = value;
            return;
        }

        if (hs.size() == capacity) {        //超出缓存上限
            hs.remove(head.next.key);        //删除头部数据
            head.next = head.next.next;
            head.next.prev = head;
        }

        Node insert = new Node(key, value);        //新建节点
        hs.put(key, insert);
        move_to_tail(insert);                    //放于尾部
    }

    private void move_to_tail(Node current) {    //移动数据至尾部
        current.prev = tail.prev;
        tail.prev = current;
        current.prev.next = current;
        current.next = tail;
    }
}</code></pre>
<br>

<p><strong>解法二：</strong></p>
<p>题目要求实现 <code>LRU</code> 缓存机制，需要在 <code>O(1)</code>时间内完成如下操作：</p>
<ul>
<li>获取键 / 检查键是否存在</li>
<li>设置键</li>
<li>删除最先插入的键</li>
<li>前两个操作可以用标准的哈希表在 <code>O(1)</code> 时间内完成。</li>
</ul>
<p>有一种叫做<code>有序字典</code>的数据结构，综合了<code>哈希表</code>和<code>链表</code>，在 Java 中为 <code>LinkedHashMap</code>。</p>
<p>下面用这个数据结构来实现。</p>
<br>

<pre><code class="java">class LRUCache extends LinkedHashMap&lt;Integer, Integer&gt;{
    private int capacity;

    public LRUCache(int capacity) {
        super(capacity, 0.75F, true);
        this.capacity = capacity;
    }

    public int get(int key) {
        return super.getOrDefault(key, -1);
    }

    public void put(int key, int value) {
        super.put(key, value);
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt; eldest) {
        return size() &gt; capacity; 
    }
}</code></pre>
<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>时间复杂度：对于 put 和 get 操作复杂度是 $O(1)$，因为有序字典中的所有操作：</li>
<li><code>get/in/set/move_to_end/popitem（get/containsKey/put/remove）</code>都可以在常数时间内完成。<br>空间复杂度：$O(capacity)$，因为空间只用于有序字典存储最多 capacity + 1 个元素。</li>
</ul>
<br>
<br>

            <hr>
          </div>
          <br>
          <div>
            
              <p>
                <i class="iconfont icon-inbox"></i>
                
                  <a class="hover-with-bg" href="/categories/Android">Android</a>
                  &nbsp;
                
              </p>
            
            <p>
              <i class="iconfont icon-tag"></i>
              
                <a class="hover-with-bg" href="/tags/%E7%AE%97%E6%B3%95">算法</a>
              
                <a class="hover-with-bg" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制</a>
              
                <a class="hover-with-bg" href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97">位运算</a>
              
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
      <br><br>
      
      
  <div id="gitalk-container"></div>
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.11.1/js/md5.min.js"></script>
  <script type="text/javascript">
    var gitalk = new Gitalk({
      clientID: 'b490011b0888d5755e07',
      clientSecret: '032d235d0a00fedfc15850e426ad915f2e9a7278',
      repo: 'FishInWater-1999.github.io',
      owner: 'FishInWater-1999',
      admin: 'FishInWater-1999',
      id: md5(location.pathname),
      language: 'zh-CN',
      perPage: '15',
      pagerDirection: 'last',
      createIssueManually: 'true',
      distractionFreeMode: 'false'
    });

    gitalk.render('gitalk-container')
  </script>

    
  </div>
</div>
    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>
    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>

  <script src="/js/lazyload.js" ></script>


  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>


  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint linenums');
      prettyPrint();
    })
  </script>


  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "“面试必备：高频算法题终章「图文解析 + 范例代码」之 矩阵 二进制 + 位运算 + LRU 合集！”&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>


  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>


</body>
</html>
