<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>缩放手势 ScaleGestureDetector  源码解析，这一篇就够了</title>
    <link href="undefined2019/10/11/%E7%BC%A9%E6%94%BE%E6%89%8B%E5%8A%BF%20ScaleGestureDetector%20%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%8C%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <url>2019/10/11/%E7%BC%A9%E6%94%BE%E6%89%8B%E5%8A%BF%20ScaleGestureDetector%20%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%8C%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<p>其实在我们日常的编程中，对于缩放手势的使用并不是很经常，这一手势主要是用在图片浏览方面，比如下方例子。但是（敲重点），作为 Android 入门的基础来说，学习 ScaleGestureDetector 的使用，算是不得不过的一道坎，好在 ScaleGestureDetector 使用起来非常简单，就是源码分析上得花些功夫。</p><blockquote><p>本文首先将简单的介绍下 ScaleGestureDetector 的使用，在重点给大家分析下源码（由于源码方面是我自己的理解，可能有偏差，希望各位大佬能在评论区指出，万分感谢～）</p></blockquote><img src="https://user-gold-cdn.xitu.io/2019/6/27/16b996688722ec94?w=1280&h=904&f=jpeg&s=235091" srcset="/img/loading.gif" width="500" height="300" align="center"><hr><h1 id="ScaleGestureDetector-使用"><a href="#ScaleGestureDetector-使用" class="headerlink" title="ScaleGestureDetector 使用"></a>ScaleGestureDetector 使用</h1><p>ScaleGestureDetector 包括一个监听器，以及它所有方法的空实现：</p><table><thead><tr><th>名称</th><th>用途</th></tr></thead><tbody><tr><td>ScaleGestureDetector</td><td>缩放手势的监听器</td></tr><tr><td>SimpleOnScaleGestureListener</td><td>该监听器的空实现，在其中重写方法</td></tr></tbody></table><h3 id="ScaleGestureDetector-方法"><a href="#ScaleGestureDetector-方法" class="headerlink" title="ScaleGestureDetector 方法"></a>ScaleGestureDetector 方法</h3><table><thead><tr><th>名称</th><th>用途</th></tr></thead><tbody><tr><td>onScaleBegin</td><td>当 &gt;= 2 个手指碰触屏幕时调用，若返回 false 则忽略改事件调用</td></tr><tr><td>onScale</td><td>滑动（缩放）过程中调用，若成功处理，则用户返回 true，监听器继续记录下一个缩放等动作，若为 false 表明数据未处理，则监听器继续积累</td></tr><tr><td>onScaleEnd</td><td>全部手指离开屏幕，结束监听</td></tr></tbody></table><p>通常情况下，手势监听会结合自定义 View 来讲，这里我给出一个最简单的使用，具体的使用实例，以后再结合自定义 View 讲讲。</p><pre><code class="java">    private void iniScaleGestureListener(){        mListener = new ScaleGestureDetector.SimpleOnScaleGestureListener(){            @Override            public boolean onScaleBegin(ScaleGestureDetector detector) {                return super.onScaleBegin(detector);            }            @Override            public boolean onScale(ScaleGestureDetector detector) {                MyLog.d(&quot;X:&quot; + detector.getFocusX());                MyLog.d(&quot;Y:&quot; + detector.getFocusY());                MyLog.d(&quot;scale:&quot; + detector.getScaleFactor());                return super.onScale(detector);            }            @Override            public void onScaleEnd(ScaleGestureDetector detector) {                super.onScaleEnd(detector);            }        };        detector = new ScaleGestureDetector(getContext(), mListener);    }    @Override    public boolean onTouchEvent(MotionEvent event) {        detector.onTouchEvent(event);        return true;    }</code></pre><hr><h1 id="ScaleGestureDetector-的使用"><a href="#ScaleGestureDetector-的使用" class="headerlink" title="ScaleGestureDetector 的使用"></a>ScaleGestureDetector 的使用</h1><p>ScaleGestureDetector 在具体项目的使用有点复杂，我打算过段时间结合自定义 View 写一篇用来总结，所以这篇我们就先了解下 ScaleGestureDetector 的基本使用。</p><hr><h1 id="ScaleGestureDetector-源码分析"><a href="#ScaleGestureDetector-源码分析" class="headerlink" title="ScaleGestureDetector 源码分析"></a>ScaleGestureDetector 源码分析</h1><p>好了，现在我们进入本章重点，ScaleGestureDetector 源码分析，敲黑板敲黑板。首先，我们打开 ScaleGestureDetector 的源码可以看到，几乎所有的代码都集中在了 onTouchEvent 这个方法上，所以在这里，我就主要给大家介绍这个方法的实现。</p><h2 id="第一部分：前期准备"><a href="#第一部分：前期准备" class="headerlink" title="第一部分：前期准备"></a>第一部分：前期准备</h2><pre><code class="java">        if (mInputEventConsistencyVerifier != null) {            mInputEventConsistencyVerifier.onTouchEvent(event, 0);        }        mCurrTime = event.getEventTime();        final int action = event.getActionMasked();        // Forward the event to check for double tap gesture        if (mQuickScaleEnabled) {            mGestureDetector.onTouchEvent(event);        }        final int count = event.getPointerCount();        final boolean isStylusButtonDown =                (event.getButtonState() &amp; MotionEvent.BUTTON_STYLUS_PRIMARY) != 0;</code></pre><h3 id="mInputEventConsistencyVerifier"><a href="#mInputEventConsistencyVerifier" class="headerlink" title="mInputEventConsistencyVerifier"></a>mInputEventConsistencyVerifier</h3><ul><li>输入事件一致性验证器 @有道</li><li>根据名字以及前面的定义</li><li>我们可以猜测这个对象应该是手势监听 Event 是否注册（连接到硬件）</li><li>所以，如果他为空，那么我们在这里调用 onTouchEvent 进行注册</li></ul><pre><code class="java">        if (mInputEventConsistencyVerifier != null) {            mInputEventConsistencyVerifier.onTouchEvent(event, 0);        }</code></pre><h3 id="mCurrTime"><a href="#mCurrTime" class="headerlink" title="mCurrTime"></a>mCurrTime</h3><ul><li>获得事件发生时的时间</li></ul><pre><code class="java">        mCurrTime = event.getEventTime();</code></pre><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><ul><li>获得事件类型</li></ul><pre><code class="java">        final int action = event.getActionMasked();</code></pre><h3 id="mQuickScaleEnabled"><a href="#mQuickScaleEnabled" class="headerlink" title="mQuickScaleEnabled"></a>mQuickScaleEnabled</h3><ul><li>Forward the event to check for double tap gesture</li><li>@有道 转发事件以检查双击手势</li><li>首先是 mQuickScaleEnabled 这个对象</li><li>翻译过来是： @有道 启用快速扩展</li><li>作用大概就是调用双击监听事件，比如双击最大化</li></ul><pre><code class="java">        if (mQuickScaleEnabled) {            mGestureDetector.onTouchEvent(event);        }</code></pre><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><ul><li>获得屏幕上手指的数目</li></ul><pre><code class="java">        final int count = event.getPointerCount();</code></pre><h3 id="isStylusButtonDown"><a href="#isStylusButtonDown" class="headerlink" title="isStylusButtonDown"></a>isStylusButtonDown</h3><p> 这个主要是由于判断手写笔是否按下<br> 由于我们很少处理手写笔，所以这里不做过多说明</p><pre><code class="java">         final boolean isStylusButtonDown =                (event.getButtonState() &amp; MotionEvent.BUTTON_STYLUS_PRIMARY) != 0;</code></pre><hr><h2 id="第二部分：处理与手势变化"><a href="#第二部分：处理与手势变化" class="headerlink" title="第二部分：处理与手势变化"></a>第二部分：处理与手势变化</h2><p> 用户的缩放手势不总是一定的，就是说对于用户而言，随时可能有手指碰触或离开屏幕，这就使得缩放中心的（焦点）随时可能发生变化，这部分主要是用来处理这一变化，并做出响应。</p><pre><code class="java">         final boolean anchoredScaleCancelled =                mAnchoredScaleMode == ANCHORED_SCALE_MODE_STYLUS &amp;&amp; !isStylusButtonDown;        final boolean streamComplete = action == MotionEvent.ACTION_UP ||                action == MotionEvent.ACTION_CANCEL || anchoredScaleCancelled;        // 如果发生了上面这种小动作，或者说有一手指离开了屏幕，进行调用        if (action == MotionEvent.ACTION_DOWN || streamComplete) {            // Reset any scale in progress with the listener.            // If it&#39;s an ACTION_DOWN we&#39;re beginning a new event stream.            // This means the app probably didn&#39;t give us all the events. Shame on it.            if (mInProgress) {                mListener.onScaleEnd(this);                mInProgress = false;                mInitialSpan = 0;                mAnchoredScaleMode = ANCHORED_SCALE_MODE_NONE;            } else if (inAnchoredScaleMode() &amp;&amp; streamComplete) {                mInProgress = false;                mInitialSpan = 0;                mAnchoredScaleMode = ANCHORED_SCALE_MODE_NONE;            }            if (streamComplete) {                return true;            }        }</code></pre><h3 id="anchoredScaleCancelled"><a href="#anchoredScaleCancelled" class="headerlink" title="anchoredScaleCancelled"></a>anchoredScaleCancelled</h3><ul><li>@Google 锚定规模取消</li><li>我的理解是：用于判断滑动事件是否被取消</li></ul><pre><code class="java">        final boolean anchoredScaleCancelled =                mAnchoredScaleMode == ANCHORED_SCALE_MODE_STYLUS &amp;&amp; !isStylusButtonDown;</code></pre><h3 id="streamComplete"><a href="#streamComplete" class="headerlink" title="streamComplete"></a>streamComplete</h3><ul><li>@Google Translate: 流完成</li><li>我的理解是，这个布尔变量用于标记</li><li>当前动作是否完成</li><li>我这里说的动作有两种</li><li>这里指的是：在大动作如三指触屏放大过程中，又一个手指离开了屏幕这种</li><li>在大动作三指触屏中发生的一个小动作，离开一指</li></ul><pre><code class="java">        final boolean streamComplete = action == MotionEvent.ACTION_UP ||                action == MotionEvent.ACTION_CANCEL || anchoredScaleCancelled;</code></pre><h3 id="action-MotionEvent-ACTION-DOWN-streamComplete"><a href="#action-MotionEvent-ACTION-DOWN-streamComplete" class="headerlink" title="action == MotionEvent.ACTION_DOWN || streamComplete"></a>action == MotionEvent.ACTION_DOWN || streamComplete</h3><ul><li>如果发生了上面这种小动作，或者说有一手指离开了屏幕，就进行调用</li></ul><pre><code class="java">if (action == MotionEvent.ACTION_DOWN || streamComplete) {...}</code></pre><h3 id="if-mInProgress"><a href="#if-mInProgress" class="headerlink" title="if (mInProgress)"></a>if (mInProgress)</h3><ul><li>@google Translate：重置侦听器正在进行的任何缩放。</li><li>如果是ACTION_DOWN，我们开始一个新的事件流。</li><li>这意味着应用程序可能没有给我们所有的事件。很遗憾。</li><li>首先判断该进程（从第一个手指碰上屏幕，到最后一个手指离开屏幕为止）是否结束</li><li>如果仍在运行中，这调用回调方法：onScaleEnd 使其结束</li></ul><pre><code class="java">            if (mInProgress) {                mListener.onScaleEnd(this);                mInProgress = false;                mInitialSpan = 0;                mAnchoredScaleMode = ANCHORED_SCALE_MODE_NONE;            }</code></pre><h3 id="else-if-inAnchoredScaleMode-amp-amp-streamComplete"><a href="#else-if-inAnchoredScaleMode-amp-amp-streamComplete" class="headerlink" title="else if (inAnchoredScaleMode() &amp;&amp; streamComplete)"></a>else if (inAnchoredScaleMode() &amp;&amp; streamComplete)</h3><ul><li>如果当前进程已经结束</li><li>判断 mAnchoredScaleMode 是否为 ANCHORED_SCALE_MODE_STYLUS 状态</li><li>同时判断操作流 streamComplete 是否完成</li><li>都符合的情况下结束这一手势变化</li></ul><pre><code class="java">            else if (inAnchoredScaleMode() &amp;&amp; streamComplete) {                mInProgress = false;                mInitialSpan = 0;                mAnchoredScaleMode = ANCHORED_SCALE_MODE_NONE;            }</code></pre><h3 id="if-streamComplete"><a href="#if-streamComplete" class="headerlink" title="if (streamComplete)"></a>if (streamComplete)</h3><ul><li>结束本次 onTouchEvent 方法的调用，等待下一次调用发生</li></ul><pre><code class="java">            if (streamComplete) {                return true;            }</code></pre><p>总结： 可以看到，当触发 down 或者触发 up，cancel 时，如果之前处于缩放计算的状态，会将其状态重置， 并调用 onScaleEnd 方法。</p><hr><h2 id="进入锚定比例模式"><a href="#进入锚定比例模式" class="headerlink" title="进入锚定比例模式"></a>进入锚定比例模式</h2><ul><li>当判断用户动作，如果为双击这类点击事件，进入该模式</li><li>与正常缩放区分。这个模式功能一般是：双击最大化和最小化</li></ul><pre><code class="java">        if (!mInProgress &amp;&amp; mStylusScaleEnabled &amp;&amp; !inAnchoredScaleMode()                &amp;&amp; !streamComplete &amp;&amp; isStylusButtonDown) {            // Start of a button scale gesture            mAnchoredScaleStartX = event.getX();            mAnchoredScaleStartY = event.getY();            mAnchoredScaleMode = ANCHORED_SCALE_MODE_STYLUS;            mInitialSpan = 0;        }</code></pre><h3 id="mAnchoredScaleStartX-amp-mAnchoredScaleStartY"><a href="#mAnchoredScaleStartX-amp-mAnchoredScaleStartY" class="headerlink" title="mAnchoredScaleStartX &amp; mAnchoredScaleStartY"></a>mAnchoredScaleStartX &amp; mAnchoredScaleStartY</h3><ul><li>后文中将用于重新计算焦点</li></ul><pre><code class="java">            mAnchoredScaleStartX = event.getX();            mAnchoredScaleStartY = event.getY();</code></pre><h3 id="mAnchoredScaleMode"><a href="#mAnchoredScaleMode" class="headerlink" title="mAnchoredScaleMode"></a>mAnchoredScaleMode</h3><ul><li>赋值之后，再次调用 inAnchoredScaleMode() 方法，返回值变为 true</li></ul><pre><code class="java">            mAnchoredScaleMode = ANCHORED_SCALE_MODE_STYLUS;</code></pre><h2 id="计算缩放中心"><a href="#计算缩放中心" class="headerlink" title="计算缩放中心"></a>计算缩放中心</h2><pre><code class="java">        final boolean configChanged = action == MotionEvent.ACTION_DOWN ||                action == MotionEvent.ACTION_POINTER_UP ||                action == MotionEvent.ACTION_POINTER_DOWN || anchoredScaleCancelled;        final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;        final int skipIndex = pointerUp ? event.getActionIndex() : -1;        // Determine focal point        float sumX = 0, sumY = 0;        final int div = pointerUp ? count - 1 : count;        final float focusX;        final float focusY;        if (inAnchoredScaleMode()) {            // In anchored scale mode, the focal pt is always where the double tap            // or button down gesture started            focusX = mAnchoredScaleStartX;            focusY = mAnchoredScaleStartY;            if (event.getY() &lt; focusY) {                mEventBeforeOrAboveStartingGestureEvent = true;            } else {                mEventBeforeOrAboveStartingGestureEvent = false;            }        } else {            for (int i = 0; i &lt; count; i++) {                if (skipIndex == i) continue;                sumX += event.getX(i);                sumY += event.getY(i);            }            focusX = sumX / div;            focusY = sumY / div;        }</code></pre><h3 id="configChanged"><a href="#configChanged" class="headerlink" title="configChanged"></a>configChanged</h3><ul><li>布尔类型量，标志着一个操作的完成或者结束（手指离开，手指按下）</li></ul><pre><code class="java">        final boolean configChanged = action == MotionEvent.ACTION_DOWN ||                action == MotionEvent.ACTION_POINTER_UP ||                action == MotionEvent.ACTION_POINTER_DOWN || anchoredScaleCancelled;</code></pre><h3 id="pointerUp"><a href="#pointerUp" class="headerlink" title="pointerUp"></a>pointerUp</h3><ul><li>布尔类型量，用于判断当前动作，是否为手指离开（抬起动作）</li></ul><pre><code class="java">        final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;</code></pre><h3 id="skipIndex"><a href="#skipIndex" class="headerlink" title="skipIndex"></a>skipIndex</h3><ul><li>标记量，在是手指离开的情况下，标记离开手指</li><li>在后面计算新的焦点代码中，跳过该手指的标记点坐标，进行计算</li></ul><pre><code class="java">        final int skipIndex = pointerUp ? event.getActionIndex() : -1;</code></pre><h3 id="初始化计算所需临时变量"><a href="#初始化计算所需临时变量" class="headerlink" title="初始化计算所需临时变量"></a>初始化计算所需临时变量</h3><pre><code class="java">        // Determine focal point        float sumX = 0, sumY = 0;        // 如果是抬起手指，则当前手指数减1，否则不变        final int div = pointerUp ? count - 1 : count;        final float focusX;        final float focusY;</code></pre><h3 id="判断是否为锚定比例模式"><a href="#判断是否为锚定比例模式" class="headerlink" title="判断是否为锚定比例模式"></a>判断是否为锚定比例模式</h3><ul><li>是的话直接将点击时记下的点，作为焦点</li><li>不是的话，把所有点累加求和，除以总个数，计算平均值</li></ul><pre><code class="java">        if (inAnchoredScaleMode()) {            // In anchored scale mode, the focal pt is always where the double tap            // or button down gesture started            // 在锚定比例模式中，焦点pt始终是双击的位置，或按下手势开始            focusX = mAnchoredScaleStartX;            focusY = mAnchoredScaleStartY;            if (event.getY() &lt; focusY) {                mEventBeforeOrAboveStartingGestureEvent = true;            } else {                mEventBeforeOrAboveStartingGestureEvent = false;            }        } else {            for (int i = 0; i &lt; count; i++) {                if (skipIndex == i) continue;                sumX += event.getX(i);                sumY += event.getY(i);            }            focusX = sumX / div;            focusY = sumY / div;        }</code></pre><hr><h2 id="算缩放比例"><a href="#算缩放比例" class="headerlink" title="算缩放比例"></a>算缩放比例</h2><ul><li>计算缩放比例也很简单，就是计算各个手指到焦点的平均距离，在用户手指移动后用新的平均距离除以旧的平均距离，并以此计算得出缩放比例。</li></ul><pre><code class="java">        // Determine average deviation from focal point @Google translate         float devSumX = 0, devSumY = 0;        for (int i = 0; i &lt; count; i++) {            if (skipIndex == i) continue;            // Convert the resulting diameter into a radius.            devSumX += Math.abs(event.getX(i) - focusX);            devSumY += Math.abs(event.getY(i) - focusY);        }        final float devX = devSumX / div;        final float devY = devSumY / div;        // Span is the average distance between touch points through the focal point;        // i.e. the diameter of the circle with a radius of the average deviation from        // the focal point.        final float spanX = devX * 2;        final float spanY = devY * 2;        final float span;        if (inAnchoredScaleMode()) {            span = spanY;        } else {            span = (float) Math.hypot(spanX, spanY);        }</code></pre><h3 id="计算平均偏差"><a href="#计算平均偏差" class="headerlink" title="计算平均偏差"></a>计算平均偏差</h3><ul><li>确定焦点的平均偏差</li></ul><pre><code class="java">        float devSumX = 0, devSumY = 0;        for (int i = 0; i &lt; count; i++) {            if (skipIndex == i) continue;            // Convert the resulting diameter into a radius.            devSumX += Math.abs(event.getX(i) - focusX);            devSumY += Math.abs(event.getY(i) - focusY);        }        final float devX = devSumX / div;        final float devY = devSumY / div;</code></pre><h3 id="计算缩放比例"><a href="#计算缩放比例" class="headerlink" title="计算缩放比例"></a>计算缩放比例</h3><ul><li>跨度是通过焦点的触摸点之间的平均距离;</li><li>即圆的直径，其半径为平均偏差</li><li>这里的 Math.hypot(spanX, spanY) 方法，相当于 sqrt(x<em>x + y</em>y)</li></ul><pre><code class="java">        final float spanX = devX * 2;        final float spanY = devY * 2;        final float span;        if (inAnchoredScaleMode()) {            span = spanY;        } else {            span = (float) Math.hypot(spanX, spanY);        }</code></pre><hr><h2 id="结束缩放事件"><a href="#结束缩放事件" class="headerlink" title="结束缩放事件"></a>结束缩放事件</h2><ul><li>@Google Translate：根据需要调度开始/结束事件。</li><li>如果配置发生更改，请通过开始通知应用重置其当前状态</li><li>一个新的比例事件流。</li><li>这里就不做太多描述，主要就是：</li><li>判断是不是所有手指都离开了屏幕</li><li>如果是，那么索命这个缩放进程结束了</li><li>则保存当前缩放的数据</li><li>调用 onScaleEnd 方法，结束当前操作</li></ul><pre><code class="java">        final boolean wasInProgress = mInProgress;        mFocusX = focusX;        mFocusY = focusY;        if (!inAnchoredScaleMode() &amp;&amp; mInProgress &amp;&amp; (span &lt; mMinSpan || configChanged)) {            mListener.onScaleEnd(this);            mInProgress = false;            mInitialSpan = span;        }        if (configChanged) {            mPrevSpanX = mCurrSpanX = spanX;            mPrevSpanY = mCurrSpanY = spanY;            mInitialSpan = mPrevSpan = mCurrSpan = span;        }</code></pre><h2 id="触发-onScaleBegin-开始缩放"><a href="#触发-onScaleBegin-开始缩放" class="headerlink" title="触发 onScaleBegin 开始缩放"></a>触发 onScaleBegin 开始缩放</h2><ul><li>当手指移动的距离超过一定数值(数值大小由系统定义)后，会触发 onScaleBegin 方法</li><li>如果用户在 onScaleBegin 方法里面返回了 true，则接受事件后，就会重置缩放相关数值，并且开始积累缩放因子。</li></ul><pre><code class="java">        final int minSpan = inAnchoredScaleMode() ? mSpanSlop : mMinSpan;        if (!mInProgress &amp;&amp; span &gt;= minSpan &amp;&amp;                (wasInProgress || Math.abs(span - mInitialSpan) &gt; mSpanSlop)) {            mPrevSpanX = mCurrSpanX = spanX;            mPrevSpanY = mCurrSpanY = spanY;            mPrevSpan = mCurrSpan = span;            mPrevTime = mCurrTime;            mInProgress = mListener.onScaleBegin(this);        }</code></pre><h2 id="通知用户进行缩放处理"><a href="#通知用户进行缩放处理" class="headerlink" title="通知用户进行缩放处理"></a>通知用户进行缩放处理</h2><ul><li>@ Google Translate: 处理动作;焦点和跨度/比例因子正在发生变化。</li><li>这块代码的功能主要就是通知用户（编程者）</li><li>根据这些数据进行缩放</li></ul><pre><code class="java">        if (action == MotionEvent.ACTION_MOVE) {            mCurrSpanX = spanX;            mCurrSpanY = spanY;            mCurrSpan = span;            boolean updatePrev = true;            if (mInProgress) {                updatePrev = mListener.onScale(this);            }            if (updatePrev) {                mPrevSpanX = mCurrSpanX;                mPrevSpanY = mCurrSpanY;                mPrevSpan = mCurrSpan;                mPrevTime = mCurrTime;            }        }</code></pre><h3 id="updatePrev"><a href="#updatePrev" class="headerlink" title="updatePrev"></a>updatePrev</h3><ul><li>这个用于接收用户的返回值</li><li>只要我们放回 true ，系统就会保存当前数据</li><li>重新获取并计算新的数据和比例</li><li>系统默认返回 false 然后进行下一次事件的计算</li></ul><pre><code class="java">            if (mInProgress) {                updatePrev = mListener.onScale(this);            }            if (updatePrev) {                mPrevSpanX = mCurrSpanX;                mPrevSpanY = mCurrSpanY;                mPrevSpan = mCurrSpan;                mPrevTime = mCurrTime;            }</code></pre><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>我要讲的所有内容，到这里就完全结束了</p><p>由于源码是按照我自己的理解来讲的，所以难免会有一些出入</p><p>希望大家能在评论区中帮我指出，谢谢～ 🙏</p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>ScaleGestureDetector</tag>
      
      <tag>缩放手势</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式-全局可用的 context 对象，这一篇就够了</title>
    <link href="undefined2019/10/09/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E5%85%A8%E5%B1%80%E5%8F%AF%E7%94%A8%E7%9A%84%20context%20%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <url>2019/10/09/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E5%85%A8%E5%B1%80%E5%8F%AF%E7%94%A8%E7%9A%84%20context%20%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>单例模式在各个方面都有着极为广泛的使用，所谓单例，顾名思义就是整个程序中只有一个该类的实例，所以它成功保证了整个程序的生命周期内该类的对象只能创建一次，并且提供全局唯一访问该类的方法：getInstance()</p></blockquote><hr><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>关于单例模式主要分为两类：</p><ul><li>懒汉模式</li><li>饿汉模式</li></ul><p>由于饿汉模式是线程安全的，所以通常情况下，我们都尽量采用饿汉模式，具体原因常见这位大佬的博文：<a href="https://www.jianshu.com/p/8b59089a12f6" target="_blank" rel="noopener">点击前往</a></p><p>本文主要结合 Android 分析下当例模式在 Android 中获得全局可用的 Context 对象</p><hr><h3 id="搭建饿汉模式基本框架"><a href="#搭建饿汉模式基本框架" class="headerlink" title="搭建饿汉模式基本框架"></a>搭建饿汉模式基本框架</h3><p>单例模式基本方法包括</p><ul><li>一个该类对象</li><li>该类构造方法</li><li>获得单例的方法</li></ul><pre><code class="java">/**单例模式 * * 向整个应用提供 App (application) 单例 */public class AppContext {    private static AppContext instance;    public AppContext(Context application){    }    public static AppContext getInstance() {        if (instance == null){            throw new RuntimeException();        }        return instance;    }}</code></pre><hr><h3 id="对外暴露实例化单例的方法"><a href="#对外暴露实例化单例的方法" class="headerlink" title="对外暴露实例化单例的方法"></a>对外暴露实例化单例的方法</h3><p>外界调用时，将全局的 context 对象传入</p><pre><code class="java">    public static void init(Context context){        if (instance != null){            throw new RuntimeException();        }        instance = new AppContext(context);    }</code></pre><p>修改构造方法：</p><ul><li>将全局的 Context 对象保存到该单例中</li></ul><pre><code class="java">    private Context applicationContext;    public AppContext(Context application){        this.applicationContext = application;    }</code></pre><hr><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>在之前的基础上，暴露获得 Context 对象的方法</p><pre><code class="java">/**单例模式 * * 向整个应用提供 App (application) 单例 */public class AppContext {    private static AppContext instance;    private Context applicationContext;    public AppContext(Context application){        this.applicationContext = application;    }    public Context getApplicationContext() {        return applicationContext;    }    public static AppContext getInstance() {        if (instance == null){            throw new RuntimeException();        }        return instance;    }    public static void init(Context context){        if (instance != null){            throw new RuntimeException();        }        instance = new AppContext(context);    }    public static boolean isInitialized(){        return (instance != null);    }}</code></pre><hr><h1 id="单例的实例化"><a href="#单例的实例化" class="headerlink" title="单例的实例化"></a>单例的实例化</h1><p>那么我们如何生成该单例能，由于单例是全剧唯一的，根据这个特性我们一般在 Application 中实例化它</p><pre><code class="java">public class App extends Application {    @Override    public void onCreate() {        super.onCreate();        if (!AppContext.isInitialized()){            AppContext.init(getApplicationContext());        }    }}</code></pre><hr><h1 id="单例-context-的使用"><a href="#单例-context-的使用" class="headerlink" title="单例 context 的使用"></a>单例 context 的使用</h1><p>context 的使用可以说非常广泛，例如获得程序网络功能，获得制定控件属性等等，用途可以说是非常广泛</p><ul><li>获得网络状态</li></ul><pre><code class="java">NetworkUtil.isNetworkAvailable(AppContext.getInstance().getApplicationContext()public class NetworkUtil {    /**     * 检查网络是否可用     *     * @param context     * @return     */    public static boolean isNetworkAvailable(Context context) {        ConnectivityManager manager = (ConnectivityManager) context                .getApplicationContext().getSystemService(                        Context.CONNECTIVITY_SERVICE);        if (manager == null) {            return false;        }        NetworkInfo networkinfo = manager.getActiveNetworkInfo();        if (networkinfo == null || !networkinfo.isAvailable()) {            return false;        }        return true;    }}</code></pre><ul><li>在工具类中获得控件属性值</li></ul><pre><code class="java">    /**     * color.xml里面的id     */    public static int getColor(int colorResId){        Context context = OrderContext.getInstance().getApplicationContext();        return context.getResources().getColor(colorResId);    }</code></pre><hr><p>单例模式的使用非常广泛，但具体的内容基本就这些，本文主要是我学习过程中的一点总结。</p><p>大家可以在此基础上加以改造使用，如果有其他的应用场景，欢迎在评论区中分享，一起进步～！</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高效解决「SQLite」数据库并发访问安全问题，只这一篇就够了</title>
    <link href="undefined2019/10/07/%E9%AB%98%E6%95%88%E8%A7%A3%E5%86%B3%E3%80%8CSQLite%E3%80%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%8C%E5%8F%AA%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <url>2019/10/07/%E9%AB%98%E6%95%88%E8%A7%A3%E5%86%B3%E3%80%8CSQLite%E3%80%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%8C%E5%8F%AA%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2019/9/29/16d7d4bb55a49eb6?w=2000&h=1215&f=jpeg&s=125618" srcset="/img/loading.gif" alt="学Android"></p><h1 id="Concurrent-database-access"><a href="#Concurrent-database-access" class="headerlink" title="Concurrent database access"></a>Concurrent database access</h1><hr><p>对于 Android Dev 而言，有关 SQLite 的操作再经常不过了，相比你一定经历过控制台一片爆红的情况，这不禁让我们疑问：SQLite 到底是线程安全的吗？</p><p><strong>OK  废话不多说，我们 ⬇️</strong></p><h1 id="直接开始"><a href="#直接开始" class="headerlink" title="直接开始"></a>直接开始</h1><hr><h4 id="首先，假设你已经实现了一个-SQLiteHelper-类，如下所示："><a href="#首先，假设你已经实现了一个-SQLiteHelper-类，如下所示：" class="headerlink" title="首先，假设你已经实现了一个 SQLiteHelper 类，如下所示："></a>首先，假设你已经实现了一个 SQLiteHelper 类，如下所示：</h4><pre><code class="java">public class DatabaseHelper extends SQLiteOpenHelper { ... }</code></pre><p>现在你想要在两个子线程中，分别地向 SQLite 里写入一些数据：</p><pre><code class="java"> // Thread 1 Context context = getApplicationContext(); DatabaseHelper helper = new DatabaseHelper(context); SQLiteDatabase database = helper.getWritableDatabase(); database.insert(…); database.close(); // Thread 2 Context context = getApplicationContext(); DatabaseHelper helper = new DatabaseHelper(context); SQLiteDatabase database = helper.getWritableDatabase(); database.insert(…); database.close();</code></pre><blockquote><p>对吧？看上去很 OK 没啥毛病。</p></blockquote><p>那么这时，我们点一下 <code>run</code> ，gio～ 你将会在你的 logcat 里收到如下礼物「报错」：</p><pre><code class="java">android.database.sqlite.SQLiteDatabaseLockedException: database is locked (code 5)</code></pre><h4 id="到底是怎么回事呢？"><a href="#到底是怎么回事呢？" class="headerlink" title="到底是怎么回事呢？"></a>到底是怎么回事呢？</h4><p>我们分析一下报错终于发现：这是由于你每次创建 SQLiteHelper 时，都对数据库进行了一个链接操作。这时，如果你尝试着，同时从实际不同的链接中，对数据库进行写入操作，失败就是必然的了。</p><blockquote><p><strong>总结一下</strong><br>如果我们想再不同的线程中，对数据库进行包括读写操作在内的任何使用，我们就必须得确保，我们使用的是同一个的连接</p></blockquote><p>好，那现在问题就明了了。现在让我们创建一个单例模式类：<code>DatabaseManager</code> 用来创建和返回唯一的，单例 <code>DatabaseManager</code> 对象。</p><blockquote><p>ps 有些同学问我什么是单例模式，我专门跑去写了这篇博客来解释下，<a href="https://blog.csdn.net/qq_43377749/article/details/96324909" target="_blank" rel="noopener">单例模式-全局可用的 context 对象，这一篇就够了</a>码字不易帮我点个赞谢谢 🙏</p></blockquote><pre><code class="java">public class DatabaseManager {    private static DatabaseManager instance;    private static SQLiteOpenHelper mDatabaseHelper;    public static synchronized void initializeInstance(SQLiteOpenHelper helper) {        if (instance == null) {            instance = new DatabaseManager();            mDatabaseHelper = helper;        }    }    public static synchronized DatabaseManager getInstance() {        if (instance == null) {            throw new IllegalStateException(DatabaseManager.class.getSimpleName() +                    &quot; is not initialized, call initialize(..) method first.&quot;);        }        return instance;    }    public synchronized SQLiteDatabase getDatabase() {        return mDatabaseHelper.getWritableDatabase();    }}</code></pre><p>现在，我们在回来修改下之前的代码，结果如下所示：</p><pre><code class="java">// In your application classDatabaseManager.initializeInstance(new DatabaseHelper());// Thread 1DatabaseManager manager = DatabaseManager.getInstance();SQLiteDatabase database = manager.getDatabase()database.insert(…);database.close();// Thread 2DatabaseManager manager = DatabaseManager.getInstance();SQLiteDatabase database = manager.getDatabase()database.insert(…);database.close();</code></pre><p>逻辑比之前更清晰，代码冗余也少了。现在我们在跑下代码，这时我们会收到，另一个 <code>cache</code> ：</p><pre><code class="java">java.lang.IllegalStateException: attempt to re-open an already-closed object: SQLiteDatabase</code></pre><p>不要慌，我们仔细分析下报错，我们发现：单例模式的使用保证了我们，在线程一、二「Thread 1、Thread 2 中」只会获得到唯一的 SQLiteHelper 对象，但这时问题就来了，当我们运行完线程一「Thread 1」时，我们的 <code>database.close();</code> 已经替我们关闭了对数据库的连接，但与此同时我们的线程二「Thread 2」依然保持这对 SQLiteHelper 的引用。正是这个原因，我们收到了<code>IllegalStateException</code>的报错。</p><p>所以，这时我们就需要保证，当没有人使用 SQLiteHelper 时，再将其断开连接。</p><h4 id="保证-SQLIiteHelper-在无人使用时才断开连接"><a href="#保证-SQLIiteHelper-在无人使用时才断开连接" class="headerlink" title="保证 SQLIiteHelper 在无人使用时才断开连接"></a>保证 SQLIiteHelper 在无人使用时才断开连接</h4><p>关于这个问题的解决 stackoveflow 上很多人建议我们：永远不要断开 SQLiteHelper 的连接，但是这样以来你会在 logcat 上得到如下输出：</p><pre><code class="java">Leak foundCaused by: java.lang.IllegalStateException: SQLiteDatabase created and never closed</code></pre><p>所以，我非常不建议你用这个方法。为了解决这个问题，我们引入计数器的概念</p><h4 id="标准样例"><a href="#标准样例" class="headerlink" title="标准样例"></a>标准样例</h4><p>通过如下方法，你将通过一个计数器来完美解决 打开/关闭 数据库连接的问题：</p><pre><code class="java">public class DatabaseManager {    private AtomicInteger mOpenCounter = new AtomicInteger();    private static DatabaseManager instance;    private static SQLiteOpenHelper mDatabaseHelper;    private SQLiteDatabase mDatabase;    public static synchronized void initializeInstance(SQLiteOpenHelper helper) {        if (instance == null) {            instance = new DatabaseManager();            mDatabaseHelper = helper;        }    }    public static synchronized DatabaseManager getInstance() {        if (instance == null) {            throw new IllegalStateException(DatabaseManager.class.getSimpleName() +                    &quot; is not initialized, call initializeInstance(..) method first.&quot;);        }        return instance;    }    public synchronized SQLiteDatabase openDatabase() {        if(mOpenCounter.incrementAndGet() == 1) {            // Opening new database            mDatabase = mDatabaseHelper.getWritableDatabase();        }        return mDatabase;    }    public synchronized void closeDatabase() {        if(mOpenCounter.decrementAndGet() == 0) {            // Closing database            mDatabase.close();        }    }}</code></pre><p>我们在线程中可以这样使用它：</p><pre><code class="java">SQLiteDatabase database = DatabaseManager.getInstance().openDatabase();database.insert(...);// database.close(); Don&#39;t close it directly!DatabaseManager.getInstance().closeDatabase(); // correct way</code></pre><p>每当你需要使用数据库时，你只要调用 DatabaseManager 中的 openDatabase() 方法。在这个方法中，我们有一个，用来记录数据库被“打开”了几次的 mOpenCounter 对象。当它等于 1 时，这意味着你需要去创建新的数据库连接来使用数据库，否则的话，就说明数据库已经在使用中了。</p><p>同样的情况也发生在 closeDatabase() 方法中，当你每次调用该方法时，我们的 mOpenCounter 对象就会减一。当它减到 0 时，我们就去关闭这个数据库的连接。</p><p>完美，最后：</p><ol><li>现在你就能随心所欲的使用你的数据库，而且你可以相信 – 它是线程安全的了！</li><li>当然很多同学对数据库的使用，还有着很多的疑惑，我后期将会针对数据库的使用，作出一系列总结，有兴趣可以继续关注 <strong><a href="https://juejin.im/user/5d00b2ee6fb9a07ef5622eed/posts" target="_blank" rel="noopener">_yuanhao 的编程世界</a></strong></li></ol><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><hr><blockquote><h4 id="每个人都要学的图片压缩，有效解决-Android-程序-OOM"><a href="#每个人都要学的图片压缩，有效解决-Android-程序-OOM" class="headerlink" title="每个人都要学的图片压缩，有效解决 Android 程序 OOM"></a><a href="https://juejin.im/post/5d932934e51d45784f2503a7" target="_blank" rel="noopener">每个人都要学的图片压缩，有效解决 Android 程序 OOM</a></h4><h4 id="Android-让你的-Room-搭上-RxJava-的顺风车-从重复的代码中解脱出来"><a href="#Android-让你的-Room-搭上-RxJava-的顺风车-从重复的代码中解脱出来" class="headerlink" title="Android 让你的 Room 搭上 RxJava 的顺风车 从重复的代码中解脱出来"></a><a href="https://juejin.im/post/5d8ab439e51d45784021e446" target="_blank" rel="noopener">Android 让你的 Room 搭上 RxJava 的顺风车 从重复的代码中解脱出来</a></h4><h4 id="ViewModel-和-ViewModelProvider-Factory：ViewModel-的创建者"><a href="#ViewModel-和-ViewModelProvider-Factory：ViewModel-的创建者" class="headerlink" title="ViewModel 和 ViewModelProvider.Factory：ViewModel 的创建者"></a><a href="https://juejin.im/post/5d80920bf265da03b638e0bd" target="_blank" rel="noopener">ViewModel 和 ViewModelProvider.Factory：ViewModel 的创建者</a></h4><h4 id="单例模式-全局可用的-context-对象，这一篇就够了"><a href="#单例模式-全局可用的-context-对象，这一篇就够了" class="headerlink" title="单例模式-全局可用的 context 对象，这一篇就够了"></a><a href="https://juejin.im/post/5d2ef3c96fb9a07ef90ccf90" target="_blank" rel="noopener">单例模式-全局可用的 context 对象，这一篇就够了</a></h4><h4 id="缩放手势-ScaleGestureDetector-源码解析，这一篇就够了"><a href="#缩放手势-ScaleGestureDetector-源码解析，这一篇就够了" class="headerlink" title="缩放手势 ScaleGestureDetector 源码解析，这一篇就够了"></a><a href="https://juejin.im/post/5d14cc0ff265da1b6d403750" target="_blank" rel="noopener">缩放手势 ScaleGestureDetector 源码解析，这一篇就够了</a></h4><h4 id="Android-属性动画框架-ObjectAnimator、ValueAnimator-，这一篇就够了"><a href="#Android-属性动画框架-ObjectAnimator、ValueAnimator-，这一篇就够了" class="headerlink" title="Android 属性动画框架 ObjectAnimator、ValueAnimator ，这一篇就够了"></a><a href="https://juejin.im/post/5d09990bf265da1bd260ef52" target="_blank" rel="noopener">Android 属性动画框架 ObjectAnimator、ValueAnimator ，这一篇就够了</a></h4><h4 id="看完这篇再不会-View-的动画框架，我跪搓衣板"><a href="#看完这篇再不会-View-的动画框架，我跪搓衣板" class="headerlink" title="看完这篇再不会 View 的动画框架，我跪搓衣板"></a><a href="https://juejin.im/post/5d04610be51d45775a700309" target="_blank" rel="noopener">看完这篇再不会 View 的动画框架，我跪搓衣板</a></h4><h4 id="Android-自定义时钟控件-时针、分针、秒针的绘制这一篇就够了"><a href="#Android-自定义时钟控件-时针、分针、秒针的绘制这一篇就够了" class="headerlink" title="Android 自定义时钟控件 时针、分针、秒针的绘制这一篇就够了"></a><a href="https://juejin.im/post/5d00f09c6fb9a07ef06f8d03" target="_blank" rel="noopener">Android 自定义时钟控件 时针、分针、秒针的绘制这一篇就够了</a></h4><h4 id="android-自定义控件之-绘制钟表盘"><a href="#android-自定义控件之-绘制钟表盘" class="headerlink" title="android 自定义控件之-绘制钟表盘"></a><a href="https://juejin.im/post/5d0c8faa5188253274727dc0" target="_blank" rel="noopener">android 自定义控件之-绘制钟表盘</a></h4><h4 id="Android-进阶自定义-ViewGroup-自定义布局"><a href="#Android-进阶自定义-ViewGroup-自定义布局" class="headerlink" title="Android 进阶自定义 ViewGroup 自定义布局"></a><a href="https://juejin.im/post/5d0db01af265da1bcc194aba" target="_blank" rel="noopener">Android 进阶自定义 ViewGroup 自定义布局</a></h4></blockquote><h1 id="欢迎关注-yuanhao的掘金！"><a href="#欢迎关注-yuanhao的掘金！" class="headerlink" title="欢迎关注_yuanhao的掘金！"></a>欢迎关注<a href="https://juejin.im/user/5d00b2ee6fb9a07ef5622eed/posts" target="_blank" rel="noopener">_yuanhao</a>的掘金！</h1><hr><p>定期分享<code>Android开发</code>湿货，追求文章<code>幽默与深度</code>的完美统一。</p><p>关于源码 Demo 链接：<strong><a href="https://github.com/FishInWater-1999/SQLiteSample" target="_blank" rel="noopener">为了写 Demo 花了好几天时间，希望大家点歌 star~ 谢谢！</a></strong></p><h3 id="请点赞！因为你的鼓励是我写作的最大动力！"><a href="#请点赞！因为你的鼓励是我写作的最大动力！" class="headerlink" title="请点赞！因为你的鼓励是我写作的最大动力！"></a>请点赞！因为你的鼓励是我写作的最大动力！</h3><p><img src="https://user-gold-cdn.xitu.io/2019/9/29/16d7d4cac8f48e62?w=2000&h=1215&f=jpeg&s=190057" srcset="/img/loading.gif" alt="学Android"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQLite</tag>
      
      <tag>线程安全</tag>
      
      <tag>并发访问</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ViewModel 和 ViewModelProvider.Factory：ViewModel 的创建者</title>
    <link href="undefined2019/10/06/ViewModel%20%E5%92%8C%20ViewModelProvider.Factory%EF%BC%9AViewModel%20%E7%9A%84%E5%88%9B%E5%BB%BA%E8%80%85/"/>
    <url>2019/10/06/ViewModel%20%E5%92%8C%20ViewModelProvider.Factory%EF%BC%9AViewModel%20%E7%9A%84%E5%88%9B%E5%BB%BA%E8%80%85/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20190915160822831.jpg" srcset="/img/loading.gif" alt></p><blockquote><p>朋友们好，今天我向大家介绍下 ViewModel 中如何使用 ViewModelProvider.Factory.</p></blockquote><hr><h1 id="现在开始"><a href="#现在开始" class="headerlink" title="现在开始"></a>现在开始</h1><p>所以，我们首要问题是：什么是 ViewModelProvider.Factory ?让我们在不使用 ViewModelProvider.Factory 的情况下，试着创建一个 ViewModel 看看：</p><p><img src="https://img-blog.csdnimg.cn/20190915160918134.png" srcset="/img/loading.gif" alt="MyViewModel.kt"></p><p>在活动中实例化：</p><p><img src="https://img-blog.csdnimg.cn/20190915161022293.png" srcset="/img/loading.gif" alt="MyActivity.kt"></p><p>有没有人注意到：当我们使用 ViewModelProviders 在活动中实例化 MyViewModel 时，从未没用过 MyViewModel 的构造方法，而都是使用 ViewModelProviders 这个类中的方法。ViewModelProviders 在内部为我们管理并调用 ViewModel 的主构造函数，创建viewmodel的实例并将该实例并返回。</p><p>那么，现在让我们看看，如果我们直接把参数传递给 MyViewModel 类的构造方法时会发生了什么：</p><p><img src="https://img-blog.csdnimg.cn/20190915184848112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzc3NzQ5,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="MyViewModel.kt"></p><p>现在，我们在活动中创建 MyViewModel 实例：</p><p><img src="https://img-blog.csdnimg.cn/20190915184940962.png" srcset="/img/loading.gif" alt="MyActivity.kt"></p><p>太棒了！没有发生任何错误</p><p>但是，等等。</p><p>当你运行上面这段代码的时候，你收到了 RunTimeError。程序崩溃了！！！ RuntimeException 不能创建出 MyViewModel 实例。</p><p>现在我们为什么会发生这些。ViewModelProviders 的 of() 方法，在内部创建了默认的 ViewModelProvider.Factory ，从而实现了 ViewModel 的无参创建。所以，当我们在构造方法添加参数时， ViewModelProvider.Factory 的内部无法实例化 ViewModel 对象，因为 ViewModelProvider.Factory 调用主构造方法创建 ViewModel’s 实例而失败。下图是 ViewModelFactory ViewModelFactory 的默认实现。</p><p><img src="https://img-blog.csdnimg.cn/20190915190507130.png" srcset="/img/loading.gif" alt="ViewModel Factory inner implementation"><br>如果你想在构造方法中添加参数，你需要编写自己的 ViewModelProvider 来创建 ViewModel 实例。</p><h1 id="什么是-ViewModelProvider-Factory"><a href="#什么是-ViewModelProvider-Factory" class="headerlink" title="什么是 ViewModelProvider.Factory?"></a>什么是 ViewModelProvider.Factory?</h1><p>ViewModelProviders.Factory 接口是负责实例化 ViewModels 对象的启动装置。这意味着你需要自己写实例化 ViewModel 对象的方法。</p><p>让我们像下面这样创建自己的 ViewModelProvider.Factory ：</p><p><img src="https://img-blog.csdnimg.cn/20190915192036556.png" srcset="/img/loading.gif" alt="MyViewModelFactory.kt"></p><p>这里有几点需要记下：</p><ol><li>你需要通过构造方法或者其他你喜欢的途径（比如 Singleton, FactoryPattern 等等）。这是由于你在实例化 ViewModel 对象时，不能直接在活动或者碎片中调用 ViewModel 的构造方法，而且你又想去设置 ViewModel 构造方法的参数，因此你需要将参数传入 ViewModelProvider.Factory 它将会帮你创建你的 ViewModel。</li><li>ViewModelProvider.Factory 是一个包含 create 方法的接口。这个 create 方法负责创建你的 VeiwModel’s 实例。</li><li>modelClass.getConstructor(Int::class.java) 方法是一个整型的能够通过调用 newInstance 方法来想构造方法传值的方法。</li></ol><p>现在就让我们通过 ViewModelProvider.Factory 在活动中创建 ViewModel 实例。</p><p><img src="https://img-blog.csdnimg.cn/20190915194318145.png" srcset="/img/loading.gif" alt="MyActivity.kt"></p><p>我们将参数或者依赖关系转入我们的 ViewModelProvider.Factory 以便于它能够为我们创建 ViewModel，ViewModelProviders.of( context, instanceOfViewModelFactory) 方法获得我们 ViewModelProvider.Factory 实例，现在就像之前的例子中一样，我们已经学会了创建 ViewModel 实例的过程。</p><h2 id="所以，为什么我们需要-ViewModelProvider-Factory"><a href="#所以，为什么我们需要-ViewModelProvider-Factory" class="headerlink" title="所以，为什么我们需要 ViewModelProvider.Factory ?"></a>所以，为什么我们需要 ViewModelProvider.Factory ?</h2><p>我们心中有这样一些疑问，我们不能直接在活动或碎片中将值传入 ViewModel 构造方法中去，我需要写法来设置我们的参数值使其正常工作，这就是为什么我们需要 ViewModelProver.Factory，在一些情况下你可以不使用，但在某些特定情形下，你需要使用 ViewModelProver.Factory。</p><h2 id="什么时候使用-ViewModelProvider-Factory"><a href="#什么时候使用-ViewModelProvider-Factory" class="headerlink" title="什么时候使用 ViewModelProvider.Factory"></a>什么时候使用 ViewModelProvider.Factory</h2><p>当你的 ViewModel 有依赖项，并且你需要将这些依赖项通过构造方法传入，因此，您可以模拟该依赖项并测试 ViewModel。</p><h2 id="什么时候不应该使用-ViewModelProvider-Factory"><a href="#什么时候不应该使用-ViewModelProvider-Factory" class="headerlink" title="什么时候不应该使用 ViewModelProvider.Factory"></a>什么时候不应该使用 ViewModelProvider.Factory</h2><p>如果你的 ViewModel 没有依赖项，这时你就不需要去自己创建 ViewModelProvider.Factory。系统自带的方法，注意帮助你创建 ViewModel。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ViewModelProvider.Factory 负责帮你创建 ViewModel 实例。当你的 ViewModel 存在依赖项，且你希望测试你的 ViewModel 时，你需要创建自己的 ViewModelProvider.Factory 来通过 ViewModel 的构造方法传递依赖项，将你的数值传入 ViewModelProvider.Factory 实例中去</p><blockquote><p>你的关注是我最大的动力！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ViewModelProvider</tag>
      
      <tag>ViewModel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 Mac 上安装 Git ，生成 SSH 密钥用于 GitHub 授权</title>
    <link href="undefined2019/10/04/%E5%9C%A8-Mac-%E4%B8%8A%E5%AE%89%E8%A3%85-Git-%EF%BC%8C%E7%94%9F%E6%88%90-SSH-%E5%AF%86%E9%92%A5%E7%94%A8%E4%BA%8E-GitHub-%E6%8E%88%E6%9D%83/"/>
    <url>2019/10/04/%E5%9C%A8-Mac-%E4%B8%8A%E5%AE%89%E8%A3%85-Git-%EF%BC%8C%E7%94%9F%E6%88%90-SSH-%E5%AF%86%E9%92%A5%E7%94%A8%E4%BA%8E-GitHub-%E6%8E%88%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在本教程中，将介绍如何在 Mac 上安装 Git，如何生成SSH密钥，以及如何将您的公共 SSH 密钥上传到 GitHub 帐户进行授权。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190920090245710.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="如何在你的-Mac-上安装-Git-？"><a href="#如何在你的-Mac-上安装-Git-？" class="headerlink" title="如何在你的 Mac 上安装 Git ？"></a>如何在你的 Mac 上安装 Git ？</h1><p>打开‘终端’输入如下命令：</p><pre><code class="xml">$ brew install git</code></pre><blockquote><p> 具体方法查看其官方文档 ：<a href="https://brew.sh/" target="_blank" rel="noopener">https://brew.sh/</a></p></blockquote><p>这将在您的系统上安装 Git。<br>若要确认是否安装成功，请输入：</p><pre><code class="xml">$ git --version</code></pre><p>这样你就能看到目前的 Git 版本。</p><h1 id="如何为-GitHub-授权生成-SSH-密钥"><a href="#如何为-GitHub-授权生成-SSH-密钥" class="headerlink" title="如何为 GitHub 授权生成 SSH 密钥"></a>如何为 GitHub 授权生成 SSH 密钥</h1><h4 id="打开你的终端"><a href="#打开你的终端" class="headerlink" title="打开你的终端"></a>打开你的终端</h4><h4 id="输入-cd-来到你的根目录下"><a href="#输入-cd-来到你的根目录下" class="headerlink" title="输入  cd ~/  来到你的根目录下"></a>输入  <strong>cd ~/</strong>  来到你的根目录下</h4><h4 id="输入以下指令："><a href="#输入以下指令：" class="headerlink" title="输入以下指令："></a>输入以下指令：</h4><pre><code class="xml">ssh-keygen -t rsa</code></pre><ul><li>这时系统将提示您输入一个文件名来存储密钥 </li><li>只需按 ‘回车’ 接受默认文件 (/Users/you/.ssh/id_rsa) 即可</li><li>然后它会要求您创建一个密码。你可以进行设定，但我一般选择直接回车（这样密码就为空，不用专门去记）</li></ul><h4 id="当你再次按下‘回车’时，以下两个文件就会被建立了"><a href="#当你再次按下‘回车’时，以下两个文件就会被建立了" class="headerlink" title="当你再次按下‘回车’时，以下两个文件就会被建立了"></a>当你再次按下‘回车’时，以下两个文件就会被建立了</h4><pre><code class="xml">~/.ssh/id_rsa~/.ssh/id_rsa.pub</code></pre><h4 id="最后一步："><a href="#最后一步：" class="headerlink" title="最后一步："></a>最后一步：</h4><p>我们需要的 SSH 公钥存储在以.pub结尾的文件中，即：<br><code>~/.ssh/id_rsa.pub</code></p><h1 id="如何复制公共-SSH-密钥"><a href="#如何复制公共-SSH-密钥" class="headerlink" title="如何复制公共 SSH 密钥"></a>如何复制公共 SSH 密钥</h1><p>为了使用 GitHub 验证您自己和您的设备，您需要将上面生成的公共 SSH密钥 上传到你的 GitHub 帐户。</p><p><strong>复制公共SSH密钥</strong></p><p>你不需要去寻找这个 .pub 文件，你只需要打开终端并输入：</p><pre><code class="xml">$ pbcopy &lt; ~/.ssh/id_rsa.pub</code></pre><p>这将直接复制 <code>id_rsa</code> 文件内的内容。</p><h1 id="如何上传您的公共-SSH-密钥到-GitHub"><a href="#如何上传您的公共-SSH-密钥到-GitHub" class="headerlink" title="如何上传您的公共 SSH 密钥到 GitHub"></a>如何上传您的公共 SSH 密钥到 GitHub</h1><ol><li>复制了公共SSH密钥后，登录到GitHub帐户并转到 <a href="https://github.com/settings/profile" target="_blank" rel="noopener">https://github.com/settings/profile</a></li><li>在左侧菜单中，您将看到一个链接“SSH和GPG密钥”</li><li>单击该链接，它将带您进入一个页面，您可以在这里输入您之前复制的公共SSH密钥。</li><li>点击“新建SSH密钥”按钮</li><li>然后输入一个标题名称——可以是任何东西，例如 newMac</li><li>将公共SSH密钥粘贴到密钥文本框中</li><li>点击“添加SSH密钥”</li></ol><h1 id="大功告成！测试你的GitHub授权"><a href="#大功告成！测试你的GitHub授权" class="headerlink" title="大功告成！测试你的GitHub授权:"></a>大功告成！测试你的GitHub授权:</h1><p>打开你的终端输入</p><pre><code class="xml">$ git clone git@github.com:你的用户名/你的某个仓库名.git</code></pre><ol><li>它会问你是否想继续连接，输入 <code>yes</code></li><li>如果您在生成公钥时创建了一个密码，那么它将要求您输入它。</li><li>输入密码并按<code>Enter</code>键。</li><li>然后，它将开始将项目克隆到您当前的目录中。</li></ol><p><strong>现在，您已经准备好使用Git和GitHub了。有问题欢迎在评论区留言</strong></p><blockquote><p>欢迎关注我的博客获得更多知识</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mac</tag>
      
      <tag>SSH</tag>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每个人都要学的图片压缩终极奥义，有效解决 Android 程序 OOM</title>
    <link href="undefined2019/10/03/%E6%AF%8F%E4%B8%AA%E4%BA%BA%E9%83%BD%E8%A6%81%E5%AD%A6%E7%9A%84%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%BB%88%E6%9E%81%E5%A5%A5%E4%B9%89%EF%BC%8C%E6%9C%89%E6%95%88%E8%A7%A3%E5%86%B3%20Android%20%E7%A8%8B%E5%BA%8F%20OOM/"/>
    <url>2019/10/03/%E6%AF%8F%E4%B8%AA%E4%BA%BA%E9%83%BD%E8%A6%81%E5%AD%A6%E7%9A%84%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%BB%88%E6%9E%81%E5%A5%A5%E4%B9%89%EF%BC%8C%E6%9C%89%E6%95%88%E8%A7%A3%E5%86%B3%20Android%20%E7%A8%8B%E5%BA%8F%20OOM/</url>
    
    <content type="html"><![CDATA[<h1 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h1><hr><blockquote><p>在我们编写 <code>Android</code> 程序的时候，几乎永远逃避不了图片压缩的难题。除了应用图标之外，我们所要显示的图片基本上只有两个来源：</p><ul><li>来自网络下载</li><li>本地相册中加载</li></ul></blockquote><p>不管是网上下载下来的也好，还是从系统图片库中读取的图片，都有一个相同的特点：像素一帮较高。同时我们都知道，<code>Android</code> 系统分配给我们每个应用的内存是有限的，由于解析、加载一张图片，需要占用的内存大小，是远大于图片自身大小的。所以，这时程序就可能因为占用了过多的内存，从而出现<code>OOM</code> 现象。那么什么是 <code>OOM</code> 呢？</p><p><code>OOM</code> 即 <code>OutOfMemory</code> 异常，也就是我们所说的 内存溢出 ，其一般表现为应用闪退等现象。那么我们该如何下手去解决呢？</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><hr><p>首先我们发现，我们所加载的这些图片的分辨率，要比我们手机屏幕高得多，更有甚者，我们在一个拇指大的控件上，去加载一个 4k 大图是完全没有必要的，也就是说，如果我们能让每个控件上都去显示相应大小的图片，那么这个问题也就迎刃而解了</p><p>那么，要怎样才能达到图片与控件的对号入座？这时我们就引进了图片压缩的方案：</p><ul><li>首先，获得原图片大小</li><li>其次，获取控件大小</li><li>接着，获取我们图片和控件的比例</li><li>最后，根据这一比例，将图片压缩为适合显示的大小</li></ul><p>那么就让我们开始吧：</p><h1 id="获取原图大小"><a href="#获取原图大小" class="headerlink" title="获取原图大小"></a>获取原图大小</h1><hr><p>我们都知道，<code>Android 向我们提供了 BitmapFactory</code> 这个类，在这个类中有着诸如：<code>decodeResource()</code>  <code>decodeFile()</code>   <code>decodeStream()</code> 等。其中：</p><ul><li>decodeResource()  ：    用于解析资源文件，即 res 文件夹下的图片</li><li>decodeFile() ：               用于解析系统相册中的图片  </li><li>decodeStream() ：        用于解析输入输出流中图片通常，是采用 HttpClient 从下载的图片</li></ul><p>其他的方法这里就不多说了，因为在源码中我们可有i看到，几乎所有的方法，最后都会将图片解析为流的形式，最后调用 <code>decodeStream()</code> 方法，实例化出我们的 <code>Bitmap</code> 对象。</p><p>虽然这些方法对我们是再熟悉不过的了，但对于某些初学者而言，却经常忽略了一个重要的内部类 ：<code>BitmapFactory.Options</code> ，然而他确实我们图片压缩必不可少的，为什么需要这个参数呢？<code>Options</code> 的对象用于确定需要生成的 Bitmap 即目标图片的参数。<br>他的用法很简单，我们先 new 一个 <code>BitmapFactory.Options</code> 对象。再去调用含有 <code>Options</code> 参数的方法，如</p><ul><li><code>public static Bitmap decodeResource(Resources res, int id, Options opts)</code></li><li><code>public static Bitmap decodeResourceStream(@Nullable Resources res,@Nullable TypedValue value,@Nullable InputStream is, @Nullable Rect pad, @Nullable Options opts)</code></li></ul><p>调用完之后我们发现，除了方法放回给我们一个实例化出来的 <code>Bitmap</code> 图片之外，这个 <code>Options</code> 对象中长度、宽度、类型等等属性，也都被设置成了了我们图片的相应属性。所以，我们很容易想到：通过将 <code>Options</code> 对象传入，来获得图片的原始尺寸，为后期的压缩做准备，说干就干，我们将 <code>Options</code> 对象，和 <code>Resources</code>中一张 4k 图片的<code>id</code> 一块传入上诉方法中，来尝试获得它的尺寸，结果我们发现：程序 <code>OOM</code> 崩溃了！</p><p>为什么会发生这种情况？首先我们想想我们为什么要获得这个<code>Options</code> 对象？时为了获得图片的尺寸大小；那我们为什么要获得原图尺寸大小？是为了按照原图尺寸和控件尺寸的比例，将其压缩为适合显示的大小？那我们又为什么要去压缩它为合适的大小呢？是因为如果按照原大小去调用相应的 <code>decode...()</code>方法解析图片，会导致内存占有率过高触发<code>OOM</code> 异常，进而导致程序崩溃啊！没想到的是：结果我们为了获得 <code>Options</code> 而调用了相应的 <code>decode...()</code> 方法，的确 <code>Options</code> 是复制了，但由于该方法适用于生成图片，也就是 <code>Bitmap</code> 对象的。所以程序也在解析这张超大图的过程中<code>OOM</code> 崩溃了</p><p>那么难道就没方法了吗？</p><p>有的，我之前说过：<code>Option</code> 内部有着众多参数，其中有一个叫做：  <code>inJustDecodeBounds</code> 。这个参数默认值为<code>false</code> 。但如果我们先把这个参数设置为 true  时，该方法便不在会去生成相应的 <code>Bitmap</code> ，而仅仅是去测量图片的各种属性，如长度、宽度、类型等等，然后放回一个 <code>null</code> 。所以，我们很容易想到：可以先通过将 <code>inJustDecodeBounds</code> 的值设为 <code>true</code> ，再去调用相应的相应的 <code>decode...()</code>方法，最后再将<code>inJustDecodeBounds</code> 的值改回 <code>false</code> 。这种做法有两个好处：</p><ol><li>既能获得图片大小，由于后续操作</li><li>又成功避免了去解析图片，导致程序 <code>OOM</code> 而崩溃。</li></ol><p>但这恰恰是被很多人所忽略的一点。</p><h4 id="好了，现在给出具体的实现："><a href="#好了，现在给出具体的实现：" class="headerlink" title="好了，现在给出具体的实现："></a>好了，现在给出具体的实现：</h4><pre><code class="java">    public static void calculateOptionsById(@NonNull Resources res,@NonNull BitmapFactory.Options options, int imgId) {        BitmapFactory.decodeResource(res, imgId, options);    }</code></pre><blockquote><p>大家可能发现，这里只将 <code>inJustDecodeBounds</code> 设为<code>true</code>却没有改回<code>false</code> ，这是因为获得 <code>Options</code> 只是图片压缩的第一步，我们在后续方法中将会进行修改</p></blockquote><h1 id="如何进行压缩"><a href="#如何进行压缩" class="headerlink" title="如何进行压缩"></a>如何进行压缩</h1><hr><p>我们继续看 <code>Options</code> 的构成。我们发现，其中有个名为 <code>inSampleSize</code> 的数据成员，他就是关键所在，那么他有着什么意义呢？</p><p>这里我给大家举个例子，比如我这有张 4000*1000 像素的图片：</p><ul><li>当我们把 <code>inSampleSize</code>  的值设为 <code>4</code>时，最后生成出来的图片大小将会是：1000 x 250 像素 </li><li>当我们把<code>inSampleSize</code> 的值设为<code>5</code>时，最后生成出来的图片大小将会是：800 x 200 像素。这是个什么概念？</li></ul><p>这不仅仅是长宽都变为原来四分之一或者五分之一这么简单，而是其图片大小，直接变为原图的 <code>1/(n^2)</code>！也就是说：</p><ul><li>如果原图 <code>2MB</code>，那么当 <code>inSampleSize</code>  赋值为<code>4</code>加载时就只需要 <code>0.125MB</code></li><li>那 如果 <code>inSampleSize</code>  赋值为 <code>5</code> 呢？只需要 <code>0.08 MB</code>！连<code>100k</code> 都不到的小图啊！</li></ul><h4 id="那么下面我就给出这个方法的具体实现："><a href="#那么下面我就给出这个方法的具体实现：" class="headerlink" title="那么下面我就给出这个方法的具体实现："></a>那么下面我就给出这个方法的具体实现：</h4><pre><code class="java">    public static int calculateInSamplesizeByOptions(@NonNull BitmapFactory.Options options, int reqWidth, int reqHeight) {        int inSamplesize   = 1;        int originalWidth  = options.outWidth;        int originalHeight = options.outHeight;        if (originalHeight &gt; reqHeight || originalWidth &gt; reqWidth) {            int heightRatio = originalHeight / reqHeight;            int widthRatio  = originalWidth  / reqWidth;            inSamplesize = heightRatio &gt; widthRatio ? heightRatio : widthRatio;        }        return inSamplesize;    }</code></pre><p>我们发现，这里我先计算出了，原图尺寸与目标大小大比例，在三目运算符中，将<code>inSamplesize</code> 赋值为较大的一个。为什么不用小的那一个呢？这里我就卖个关子，大家可以在评论区中发表自己的想法</p><h1 id="生成目标图片"><a href="#生成目标图片" class="headerlink" title="生成目标图片"></a>生成目标图片</h1><hr><p>经过前面的两个步骤，想必大家已经能勾勒处这最后一步的做法了，思路非常简单：</p><ol><li>先生成一个 <code>Options</code>对象</li><li>将 <code>Options 的 inJustDecodeBounds</code>设置为<code>true</code></li><li>接着调用方法一<code>calculateOptionsById</code>获得原图尺寸到<code>Options</code>中</li><li>调用方法三<code>calculateInSamplesizeByOptions</code> 获得相应的<code>inSampleSize</code> 对象</li><li>将 <code>Options</code>的<code>inJustDecodeBounds</code>改回 <code>false</code></li><li>再次调用 <code>decode...()</code>方法（这里是 <code>decodeResource</code> ）获得压缩后的 <code>Bitmap</code>对象</li></ol><h4 id="具体实现如下"><a href="#具体实现如下" class="headerlink" title="具体实现如下"></a>具体实现如下</h4><pre><code class="java">    public static Bitmap decodeBitmapById (@NonNull Resources res, int resId, int reqWidth, int reqHeight) {        BitmapFactory.Options options = new BitmapFactory.Options();        options.inJustDecodeBounds = true;        calculateOptionsById(res, options, resId);        options.inSampleSize = calculateInSamplesizeByOptions(options, reqWidth, reqHeight);        options.inJustDecodeBounds = false;        Bitmap bitmap = BitmapFactory.decodeResource(res, resId, options);        return bitmap;    }</code></pre><p>非常棒，我们赶紧看看效果：</p><p><img src="https://img-blog.csdnimg.cn/2019100116455266.png" srcset="/img/loading.gif" alt></p><p>太棒了，几乎和原图效果一摸一样，但软件运行的流畅性确大大提高了！但是，这真的就完美了吗？</p><p>最求完美的我们可能会有个想法：如果调用我们方法的人，或者说特殊时候的我们。不想用这个已经写好的 <code>decodeBitmapById</code>方法，而是像自己通过前两个方法：<code>calculateOptionsById</code>  <code>calculateInSamplesizeByOptions</code> 来实现图片压缩功能，这是问题就出现了：</p><ul><li>调用 <code>calculateOptionsById</code>  前可能忘记，设置 <code>inJustDecodeBound</code> 为 <code>true</code> ，进而导致计算超大图时，直接发生 <code>OOM</code></li><li>调用完 <code>calculateInSamplesizeByOptions</code> 后可能忘记，设置<code>inJustDecodeBounds</code> 为 <code>false</code>，进而导致无法获得<code>Bitmap</code> 对象，一脸懵逼</li><li>啥都做了结果调用完 <code>calculateInSamplesizeByOptions</code> 没把没回的值赋给 <code>options.inSampleSize</code> ，白忙活一场</li></ul><p>所以，我们需要在优化一下：</p><p>首先，在<code>calculateOptionsById</code>中，默认将 <code>options.inJustDecodeBounds</code> 设置为<code>true</code>：</p><pre><code class="java">    public static void calculateOptionsById(@NonNull Resources res,@NonNull BitmapFactory.Options options, int imgId) {        options.inJustDecodeBounds = true;        BitmapFactory.decodeResource(res, imgId, options);    }</code></pre><p>其次，在 <code>calculateInSamplesizeByOptions</code>最后，默认将 <code>options.inJustDecodeBounds</code>设置为<code>false</code>：</p><pre><code class="java">    public static int calculateInSamplesizeByOptions(@NonNull BitmapFactory.Options options, int reqWidth, int reqHeight) {        int inSamplesize   = 1;        int originalWidth  = options.outWidth;        int originalHeight = options.outHeight;        if (originalHeight &gt; reqHeight || originalWidth &gt; reqWidth) {            int heightRatio = originalHeight / reqHeight;            int widthRatio  = originalWidth  / reqWidth;            inSamplesize = heightRatio &gt; widthRatio ? heightRatio : widthRatio;        }        options.inJustDecodeBounds = false;        return inSamplesize;    }</code></pre><p>为什么不在该方法后面，对 <code>options.inSampleSize</code>进行赋值呢？这主要是防止，有时我们可能只想得到计算相应比例来做其他操作，而不想改变原有属性，所以是否赋值，就交给用户去选择吧</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>好了，到这里为止，历时有关图片压缩的所有坑坑洼洼都已经总结好了，我们从头理以边思路：</p><ol><li>借助<code>options.inJustDecodeBounds</code> 参数赋值<code>true</code>时，不生成图片的特性，将原图尺寸保存在 <code>Options</code> 中</li><li>通过 <code>options</code> 中原图尺寸与目标（控件）尺寸的比例，对 <code>options.inSampleSize</code> 进行设置</li><li>生成目标图片</li><li>压缩的问题解决了，但是每次打开图片都压缩也太麻烦了！下面我将针对这个问题进行更有效地解决 ，有兴趣可以继续关注 <strong><a href="https://blog.csdn.net/qq_43377749" target="_blank" rel="noopener">_yuanhao 的编程世界</a></strong></li></ol><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><hr><p><a href="https://blog.csdn.net/qq_43377749/article/details/101197865" target="_blank" rel="noopener">Android 让你的 Room 搭上 RxJava 的顺风车 从重复的代码中解脱出来</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/100856599" target="_blank" rel="noopener">ViewModel 和 ViewModelProvider.Factory：ViewModel 的创建者</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/96324909" target="_blank" rel="noopener">单例模式-全局可用的 context 对象，这一篇就够了</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/94156207" target="_blank" rel="noopener">缩放手势 ScaleGestureDetector 源码解析，这一篇就够了</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/94155960" target="_blank" rel="noopener">看完这篇还不会 GestureDetector 手势检测，我跪搓衣板！</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/92629161" target="_blank" rel="noopener">Android 属性动画框架 ObjectAnimator、ValueAnimator ，这一篇就够了</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/92425865" target="_blank" rel="noopener">Android 逐帧动画（ Drawable 动画），这一篇就够了</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/91890323" target="_blank" rel="noopener">看完这篇再不会 View 的动画框架，我跪搓衣板</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/91474208" target="_blank" rel="noopener">Android 自定义时钟控件 时针、分针、秒针的绘制这一篇就够了</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/91379915" target="_blank" rel="noopener">android 自定义控件之-绘制钟表盘</a></p><h3 id="请点赞！因为你的鼓励是我写作的最大动力！"><a href="#请点赞！因为你的鼓励是我写作的最大动力！" class="headerlink" title="请点赞！因为你的鼓励是我写作的最大动力！"></a>请点赞！因为你的鼓励是我写作的最大动力！</h3><hr><p>源码 Demo 链接：<strong><a href="https://github.com/FishInWater-1999/Drop/blob/master/app/src/main/java/com/example/drop/utils/BitmapBuilder.java" target="_blank" rel="noopener">Drop 我第一次写的 Android 项目，希望大家点歌 star~ 谢谢！</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OOM</tag>
      
      <tag>图片压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 让你的 Room 搭上 RxJava 的顺风车 从重复的代码中解脱出来</title>
    <link href="undefined2019/10/03/Android%20%E8%AE%A9%E4%BD%A0%E7%9A%84%20Room%20%E6%90%AD%E4%B8%8A%20RxJava%20%E7%9A%84%E9%A1%BA%E9%A3%8E%E8%BD%A6%20%E4%BB%8E%E9%87%8D%E5%A4%8D%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%A7%A3%E8%84%B1%E5%87%BA%E6%9D%A5/"/>
    <url>2019/10/03/Android%20%E8%AE%A9%E4%BD%A0%E7%9A%84%20Room%20%E6%90%AD%E4%B8%8A%20RxJava%20%E7%9A%84%E9%A1%BA%E9%A3%8E%E8%BD%A6%20%E4%BB%8E%E9%87%8D%E5%A4%8D%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%A7%A3%E8%84%B1%E5%87%BA%E6%9D%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-Room-？"><a href="#什么是-Room-？" class="headerlink" title="什么是 Room ？"></a>什么是 Room ？</h1><hr><p>谷歌为了帮助开发者解决 Android 架构设计问题，在 Google I/O 2017 发布一套帮助开发者解决 Android 架构设计的方案：Android Architecture Components，而我们的 Room 正是这套方案的两大模块之一。</p><ul><li>定义：数据库解决方案</li><li>组成：Database、Entity、DAO</li></ul><h1 id="为什么本文叫谷歌范例？"><a href="#为什么本文叫谷歌范例？" class="headerlink" title="为什么本文叫谷歌范例？"></a>为什么本文叫谷歌范例？</h1><hr><p>为了方便开发者进行学习和理解，Google 在 GitHub 上上传了一系列的 Android Architecture Components 开源代码：<a href="https://github.com/googlesamples/android-architecture-components" target="_blank" rel="noopener">googlesamples/android-architecture-components</a> 本文就是通过解析这套范例的第一部分：<a href="https://github.com/googlesamples/android-architecture-components/tree/master/BasicRxJavaSample" target="_blank" rel="noopener">BasicRxJavaSample</a> 来对 Room 的使用进行分析。</p><p>关于本文中的代码以及后续文章中的代码，我已经上传至我的 GitHub 欢迎大家围观、star<br>详见-&gt; <a href="https://github.com/FishInWater-1999/ArchitectureComponentsStudy" target="_blank" rel="noopener">FishInWater-1999/ArchitectureComponentsStudy</a></p><h1 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h1><hr><h4 id="为什么我们要学-Room"><a href="#为什么我们要学-Room" class="headerlink" title="为什么我们要学 Room"></a>为什么我们要学 Room</h4><p>相比于我们直接使用传统方式，如果直接使用 <code>Java</code> 代码进行 <code>SQLite</code> 操作，每次都需要手写大量重复的代码，对于我们最求梦想的程序员来说，这种无聊的过程简直是一种折磨。于是，<code>Room</code> 也就应运而生了</p><ul><li>它通过注解处理器的形式，将繁琐无趣的代码封装起来，我们只需要添加一个简单的注解，就可以完成一系列复杂的功能！</li></ul><blockquote><p>首先我们需要了解下 <code>Room</code> 的基本组成</p></blockquote><p>前面我们已经说过 Room 的使用，主要由 Database、Entity、DAO 三大部分组成，那么这三大组成部分又分别是什么呢？</p><ul><li>Database：创建一个由 Room 管理的数据库，并在其中自定义所需要操作的数据库表</li></ul><h6 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h6><pre><code>   1. 必须是abstract类而且的extends RoomDatabase。   2. 必须在类头的注释中包含与数据库关联的实体列表(Entity对应的类)。   3. 包含一个具有0个参数的抽象方法，并返回用@Dao注解的类。</code></pre><h6 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h6><p>通过单例模式实现，你可以通过静态 getInstance(…) 方法，获取数据库实例：</p><p><code>public static UsersDatabase getInstance(Context context)</code></p><ul><li><p>Entity：数据库中，某个表的实体类，如：<br><code>@Entity(tableName = &quot;users&quot;)</code><br><code>public class User {...}</code></p></li><li><p>DAO：具体访问数据库的方法的接口<br><code>@Dao</code><br><code>public interface UserDao {...}</code></p></li></ul><h1 id="BasicRxJavaSample-源码解析"><a href="#BasicRxJavaSample-源码解析" class="headerlink" title="BasicRxJavaSample 源码解析"></a>BasicRxJavaSample 源码解析</h1><hr><p>由于是源码解析，那我就以：从基础的类开始，一层层向上，抽丝剥茧，最后融为一体的方式，给大家进行解析。那么现在就让我们开始吧。</p><h4 id="表的搭建"><a href="#表的搭建" class="headerlink" title="表的搭建"></a>表的搭建</h4><p>Room 作为一个 Android 数据库操作的注解集合，最基本操作就是对我们数据库进行的。所以，先让我们试着建立一张名为 “users” 的数据表</p><pre><code class="java">/** * 应用测试的表结构模型 */@Entity(tableName = &quot;users&quot;)// 表名注解public class User {    /**     * 主键     * 由于主键不能为空，所以需要 @NonNull 注解     */    @NonNull    @PrimaryKey    @ColumnInfo(name = &quot;userid&quot;)// Room 列注解    private String mId;    /**     * 用户名     * 普通列     */    @ColumnInfo(name = &quot;username&quot;)    private String mUserName;    /**     * 构造方法     * 设置为 @Ignore 将其忽视     * 这样以来，这个注解方法就不会被传入 Room 中，做相应处理     * @param mUserName     */    @Ignore    public User(String mUserName){        this.mId    = UUID.randomUUID().toString();        this.mUserName = mUserName;    }    /**     * 我们发现与上个方法不同，该方法没有标记 @Ignore 标签     *      * 所以编译时该方法会被传入 Room 中相应的注解处理器，做相应处理     * 这里的处理应该是 add 新数据     * @param id     * @param userName     */    public User(String id, String userName) {        this.mId = id;        this.mUserName = userName;    }    public String getId() {        return mId;    }    public String getUserName() {        return mUserName;    }}</code></pre><p>首先在表头部分，我们就见到了之前说过的 <code>@Entity(...)</code> 标签，之前说过该标签表示数据库中某个表的实体类，我们查看它的源码：</p><pre><code class="java">@Target(ElementType.TYPE)@Retention(RetentionPolicy.CLASS)public @interface Entity {...}</code></pre><p>从中我们可以知道该注解实在编译注解所在的类时触发的，这是我们注意到 Google 对该类的介绍是：</p><pre><code class="xml">Marks a class as an entity. This class will have a mapping SQLite table in the database.</code></pre><p>由此可知当注解所在的类，比如我们的这个 <code>User</code> 类编译时，相应的注解处理器就会调用其内部相应的代码，建立一个名为 <code>users</code> （在 <code>@Entity(tableName = &quot;users&quot;)</code> 中传入的数据表 ）</p><p><strong>我们再往下看：</strong></p><ul><li>@ColumnInfo(name = “userid”) ：该注解注解的数据成员，将会在表中生成相应的名为：<code>userid</code> 的列</li><li>@PrimaryKey ：顾名思义该注解与<code>@ColumnInfo(name = &quot;...&quot;)</code> 注解一起使用，表示表中的主键，这里要注意一点，在 <code>@Entity</code> 的源码中强调：Each entity must have at least 1 field annotated with {@link PrimaryKey}. 也就是说一个被 <code>@Entity(...)</code>  标注的数据表类中至少要有一个主键</li><li>@Ignore ：被该注解注释的数据成员、方法，将会被注解处理器忽略，不进行处理</li></ul><p>这里我们发现，代码中有存在两个构造方法，为什么 GoogleSample 中会存在这种看似多此一举的情况呢？我们再仔细观察就会发想，上方的构造方法标记了 <code>@Ignore</code> 标签，而下方的构造方法却没有。由于在 <code>@Entity</code> 标注的类中，构造方法和列属性的 <code>get()</code> 方法都会被注解处理器自动识别处理。我们就不难想到，Google 之所以这样设计，是因为我们于是需要创建临时的 <code>User</code> 对象，但我们又不希望 <code>@Entity</code> 在我们调用构造方法时，就将其存入数据库。所以我们就有了这个被 <code>@Ignore</code> 的构造方法，用于创建不被自动存入数据库的临时对象，等到我们想将这个对象存入数据库时，调用<code>User(String id, String userName)</code> 即可。</p><h4 id="UserDao"><a href="#UserDao" class="headerlink" title="UserDao"></a>UserDao</h4><p>上面我们通过 <code>@Entity</code> 建立了一张 <code>users</code> 表，下面就让我们用 <code>@Dao</code> 注解来变写 <code>UserDao</code> 接口。</p><pre><code class="java">@Daopublic interface UserDao {    /**     * 为了简便，我们只在表中存入1个用户信息     * 这个查询语句可以获得 所有 User 但我们只需要第一个即可     * @return     */    @Query(&quot;SELECT * FROM Users LIMIT 1&quot;)    Flowable&lt;User&gt; getUser();    /**     * 想数据库中插入一条 User 对象     * 若数据库中已存在，则将其替换     * @param user     * @return     */    @Insert(onConflict = OnConflictStrategy.REPLACE)    Completable insertUser(User user);    /**     * 清空所有数据     */    @Query(&quot;DELETE FROM Users&quot;)    void deleteAllUsers();}</code></pre><p>按照我们正常编写的习惯，我们会在该类中，编写相应的数据库操作代码。但与之不同的是采用 <code>Room</code> 之后，我们将其变为一个接口类，并且只需要编写和设定相应的标签即可，不用再去关心存储操作的具体实现。</p><pre><code class="java">    /**     * 为了简便，我们只在表中存入1个用户信息     * 这个查询语句可以获得 所有 User 但我们只需要第一个即可     * @return     */    @Query(&quot;SELECT * FROM Users LIMIT 1&quot;)    Flowable&lt;User&gt; getUser();</code></pre><p> 这里我们看到，该查询方法使用的是 <code>@Query</code> 注解，那么这个注解的具体功能是什么呢？Google 官方对它的解释是：在一个被标注了 <code>@Dao</code> 标签的类中，用于查询的方法。顾名思义被该注解标注的方法，会被 <code>Room</code> 的注解处理器识别，当作一个数据查询方法，至于具体的查询逻辑并不需要我们关心，我们只需要将 <code>SQL 语句</code> 作为参数，传入 <code>@Query(...)</code> 中即可。之后我们发现，该方法返回的是一个背压 <code>Flowable&lt;...&gt;</code> 类型的对象，这是为了防止表中数据过多，读取速率远大于接收数据，从而导致内存溢出的问题，具体详见 <code>RxJava</code> 的教程，这里我就不赘述了。</p><pre><code class="java">    /**     * 想数据库中插入一条 User 对象     * 若数据库中已存在，则将其替换     * @param user     * @return     */    @Insert(onConflict = OnConflictStrategy.REPLACE)    Completable insertUser(User user);</code></pre><p>我们看到，上述方法被 <code>@Insert</code> 注解所标注，从名字就能看出，这将会是一个插入方法。顾名思义被 <code>@Insert</code> 标注的方法，会用于向数据库中插入数据，唯一让我们迷茫的是括号中的这个 <code>onConflict</code>  参数，<code>onConflict</code>  意为“冲突”，再联想下我们日常生活中的数据库操作，就不难想到：这是用来设定，当插入数据库中的数据，与原数据发生冲突时的处理方法。这里我们传入的是 <code>OnConflictStrategy.REPLACE</code> ，意为“如果数据发生冲突，则用其替换掉原数据”，除此之外还有很多相应操作的参数，比如<code>ROLLBACK</code> <code>ABORT</code> 等，篇幅原因就不详细说明了，大家可以自行查阅官方文档。还有一点值得说的是这个 <code>Completable</code> ，该返回值是 <code>RxJava</code> 的基本类型，它只处理 <code>onComplete</code> <code>onError</code> 事件，可以看成是Rx的Runnable。</p><pre><code class="java">    /**     * 清空所有数据     */    @Query(&quot;DELETE FROM Users&quot;)    void deleteAllUsers();</code></pre><p>最后这个方法就是清空 <code>users</code> 表中的所有内容，很简单，这里就不做说明了。唯一需要注意的是，这里使用了 <code>DELETE FROM 表名</code> 的形式，而不是 <code>truncate table 表名</code> ，区别就在于：效率上<code>truncate</code>比<code>delete</code>快，但<code>truncate</code> 相当于保留表的结构，重新创建了这个表，所以删除后不记录日志，不可以恢复数据。</p><h4 id="UsersDatabase"><a href="#UsersDatabase" class="headerlink" title="UsersDatabase"></a>UsersDatabase</h4><p>有关于 <code>Room</code> 的三大组成我们已经讲完了两个，现在就让我们看看最后一个 <code>@Database</code> 注解：</p><pre><code class="java">@Database(entities = {User.class}, version = 1, exportSchema = false)public abstract class UsersDatabase extends RoomDatabase {    /**     * 单例模式     * volatile 确保线程安全     * 线程安全意味着改对象会被许多线程使用     * 可以被看作是一种 “程度较轻的 synchronized”     */    private static volatile UsersDatabase INSTANCE;    /**     * 该方法由于获得 DataBase 对象     * abstract     * @return     */    public abstract UserDao userDao();    public static UsersDatabase getInstance(Context context) {        // 若为空则进行实例化        // 否则直接返回        if (INSTANCE == null) {            synchronized (UsersDatabase.class) {                if (INSTANCE == null){                    INSTANCE = Room.databaseBuilder(context.getApplicationContext(),                            UsersDatabase.class, &quot;Sample.db&quot;)                            .build();                }            }        }        return INSTANCE;    }}</code></pre><p>老样子， <code>Google</code> 定义中是这么写的：将一个类标记为 <code>Room</code> 数据库。顾名思义，我们需要在标记了该标签的类里，做具体的数据库操作，比如数据库的建立、版本更新等等。我们看到，我们向其中传入了多个参数，包括：<code>entities</code> 以数组结构，标记一系列数据库中的表，这个例子中我们只有一个 <code>User</code> 表，所以只传入一个； <code>version</code> 数据库版本；<code>exportSchema</code> 用于历史版本库的导出</p><pre><code class="java">    /**     * 单例模式     * volatile 确保线程安全     * 线程安全意味着改对象会被许多线程使用     * 可以被看作是一种 “程度较轻的 synchronized”     */    private static volatile UsersDatabase INSTANCE;</code></pre><p> 可以看出这是一个单例模式，用于创建一个全局可获得的 UsersDatabase 对象。</p><pre><code class="java">    public static UsersDatabase getInstance(Context context) {        // 若为空则进行实例化        // 否则直接返回        if (INSTANCE == null) {            synchronized (UsersDatabase.class) {                if (INSTANCE == null){                    INSTANCE = Room.databaseBuilder(context.getApplicationContext(),                            UsersDatabase.class, &quot;Sample.db&quot;)                            .build();                }            }        }        return INSTANCE;    }</code></pre><p>这是单例模式对象 INSTANCE 的获得方法，不明白的同学可以去看我这篇 <a href="https://blog.csdn.net/qq_43377749/article/details/96324909" target="_blank" rel="noopener">单例模式-全局可用的 context 对象，这一篇就够了</a></p><h4 id="UserDataSource"><a href="#UserDataSource" class="headerlink" title="UserDataSource"></a>UserDataSource</h4><p>我们可以看到：绝大多数的数据库操作方法，都定义在了 <code>UserDao</code> 中，虽然一般注解类的方法不会被继承，但是有些被特殊标记的方法可能会被继承，但是我们之后要建立的很多功能类中，都需要去调用 <code>UserDao</code> 里的方法。所以我们这里定义 <code>UserDataSource</code> 接口：</p><pre><code class="java">public interface UserDataSource {    /**     * 从数据库中读取信息     * 由于读取速率可能 远大于 观察者处理速率，故使用背压 Flowable 模式     * Flowable：https://www.jianshu.com/p/ff8167c1d191/     */    Flowable&lt;User&gt; getUser();    /**     * 将数据写入数据库中     * 如果数据已经存在则进行更新     * Completable 可以看作是 RxJava 的 Runnale 接口     * 但他只能调用 onComplete 和 onError 方法，不能进行 map、flatMap 等操作     * Completable：https://www.jianshu.com/p/45309538ad94     */    Completable insertOrUpdateUser(User user);    /**     * 删除所有表中所有 User 对象     */    void  deleteAllUsers();}</code></pre><p>该接口很简单，就是一个工具，方法和  <code>UserDao</code>  一摸一样，这里我们就不赘述了。</p><h4 id="LocalUserDataSource"><a href="#LocalUserDataSource" class="headerlink" title="LocalUserDataSource"></a>LocalUserDataSource</h4><pre><code class="java">public class LocalUserDataSource implements UserDataSource {    private final UserDao mUserDao;    public LocalUserDataSource(UserDao userDao) {        this.mUserDao = userDao;    }    @Override    public Flowable&lt;User&gt; getUser() {        return mUserDao.getUser();    }    @Override    public Completable insertOrUpdateUser(User user) {        return mUserDao.insertUser(user);    }    @Override    public void deleteAllUsers() {        mUserDao.deleteAllUsers();    }}</code></pre><p>我们先看看官方的解析：“使用 <code>Room</code> 数据库作为一个数据源。”即通过该类的对象所持有的 <code>UserDao</code> 对象，进行数据库的增删改查操作。</p><ul><li>到此为止，有关于 Room 对数据库的操作部分就讲完了，接下来我们进行视图层搭建的解析。</li></ul><hr><h4 id="UserViewModel"><a href="#UserViewModel" class="headerlink" title="UserViewModel"></a>UserViewModel</h4><p>首先我们先实现 <code>ViewModel</code> 类，那什么是 <code>ViewModel</code> 类呢？从字面上理解的话，它肯定是跟视图 <code>View</code> 以及数据 <code>Model</code> 相关的。其实正像它字面意思一样，它是负责准备和管理和UI组件 <code>Fragment/Activity</code> 相关的数据类，也就是说 <code>ViewModel</code> 是用来管理UI相关的数据的，同时 <code>ViewModel</code> 还可以用来负责UI组件间的通信。那么现在就来看看他的具体实现：</p><pre><code class="java">public class UserViewModel extends ViewModel {    /**     * UserDataSource 接口     */    private final UserDataSource mDataSource;    private User mUser;    public UserViewModel(UserDataSource dataSource){        this.mDataSource = dataSource;    }    /**     * 从数据库中读取所有 user 名称     * @return 背压形式发出所有 User 的名字     *     * 由于数据库中 User 量可能很大，可能会因为背压导致内存溢出     * 故采用 Flowable 模式，取代 Observable     */    public Flowable&lt;String&gt; getUserName(){        return mDataSource.getUser()                .map(new Function&lt;User, String&gt;() {                    @Override                    public String apply(User user) throws Exception {                        return user.getUserName();                    }                });    }    /**     * 更新/添加 数据     *     * 判断是否为空，若为空则创建新 User 进行存储     * 若不为空，说明该 User 存在，这获得其主键 &#39;getId()&#39; 和传入的新 Name 拼接，生成新 User 存储     * 通过 insertOrUpdateUser 接口，返回 Comparable 对象，监听是否存储成功     * @param userName     * @return     */    public Completable updateUserName(String userName) {        mUser = mUser == null                ? new User(userName)                : new User(mUser.getId(), userName);        return mDataSource.insertOrUpdateUser(mUser);    }}</code></pre><p>代码结构非常简单，<code>mDataSource</code> 就是我们前面建立的 <code>UserDataSource</code> 接口对象，由于我们的数据库操作控制类：<code>LocalUserDataSource</code> 是通过是实现该接口的，所以我们就可以在外部将 <code>LocalUserDataSource</code> 对象传入，从而对他的方法进行相应的回调，也就是先实现了所需的数据库操作。每个方法的功能，我已经在注释中给出，这里就不再赘述</p><h4 id="ViewModelFactory"><a href="#ViewModelFactory" class="headerlink" title="ViewModelFactory"></a>ViewModelFactory</h4><p>有上面我们可以看到，我们已经有了进行数据处理的 <code>ViewModel</code> 类，那么我们这里的 <code>ViewModelFactory</code> 类又有什么作用呢？让我们先看下范例中的实现：</p><pre><code class="java">public class ViewModelFactory implements ViewModelProvider.Factory {    private final UserDataSource mDataSource;    public ViewModelFactory(UserDataSource dataSource) {        mDataSource = dataSource;    }    // 你需要通过 ViewModelProvider.Factory 的 create 方法来创建(自定义的) ViewModel    // 参考文档：https://medium.com/koderlabs/viewmodel-with-viewmodelprovider-factory-the-creator-of-viewmodel-8fabfec1aa4f    @Override    public &lt;T extends ViewModel&gt; T create(@NonNull Class&lt;T&gt; modelClass) {        // 为什么这里用 isAssignableFrom 来判断传入的 modelClass 类的类型， 而不直接用 isInstance 判断？        // 答：二者功能一样，但如果传入值（modelClass 为空）则 isInstance 会报错奔溃，而 isAssignableFrom 不会        if (modelClass.isAssignableFrom(UserViewModel.class)) {            return (T) new UserViewModel(mDataSource);        }        throw new IllegalArgumentException(&quot;Unknown ViewModel class&quot;);    }}</code></pre><p><code>ViewModelFactory</code> 继承自 <code>ViewModelProvider.Factory</code> ，它负责帮你创建 <code>ViewModel</code> 实例。但你也许会问，我们不是已经有了 <code>ViewModel</code> 的构造方法了吗？在用 <code>ViewModelFactory</code> 不是多此一举？如果还不熟悉 <code>ViewModelFactory</code> 有关内容的，可以看下这篇：<a href="https://blog.csdn.net/qq_43377749/article/details/100856599" target="_blank" rel="noopener">ViewModel 和 ViewModelProvider.Factory：ViewModel 的创建者</a></p><h4 id="Injection"><a href="#Injection" class="headerlink" title="Injection"></a>Injection</h4><p>关于 <code>Injection</code> ，这是个帮助类，它和 Room 的逻辑功能并没有关系。<code>Sample</code> 中将其独立出来用于各个对象、类型的注入，先让我们看下该类的实现：</p><pre><code class="java">public class Injection {    /**     * 通过该方法实例化出能操作数据库的 LocalUserDataSource 对象     * @param context     * @return     */    public static UserDataSource provideUserDateSource(Context context) {        // 获得 RoomDatabase        UsersDatabase database = UsersDatabase.getInstance(context);        // 将可操作 UserDao 传入        // 实例化出可操作 LocalUserDataSource 对象方便对数据库进行操作        return new LocalUserDataSource(database.userDao());    }    /**     * 获得 ViewModelFactory 对象     * 为 ViewModel 实例化作准备     * @param context     * @return     */    public static ViewModelFactory provideViewModelFactory(Context context) {        UserDataSource dataSource = provideUserDateSource(context);        return new ViewModelFactory(dataSource);    }}</code></pre><p>该类有两个方法组成，实现了各个类型数据相互间的转换，想再让我们先看下第一个方法：</p><pre><code class="java">    /**     * 通过该方法实例化出能操作数据库的 LocalUserDataSource 对象     * @param context     * @return     */    public static UserDataSource provideUserDateSource(Context context) {        // 获得 RoomDatabase        UsersDatabase database = UsersDatabase.getInstance(context);        // 将可操作 UserDao 传入        // 实例化出可操作 LocalUserDataSource 对象方便对数据库进行操作        return new LocalUserDataSource(database.userDao());    }</code></pre><p>在该方法中，我们首先接到了我们的 <code>context</code> 对象，通过 <code>UsersDatabase.getInstance(context)</code> 方法，让 <code>database</code> 持有 <code>context</code> ，实现数据库的链接和初始化。同时放回一个 <code>LocalUserDataSource</code> 对象，这样一来我们就可以对数据表中的内容惊醒相应的操作。</p><pre><code class="java">    /**     * 获得 ViewModelFactory 对象     * 为 ViewModel 实例化作准备     * @param context     * @return     */    public static ViewModelFactory provideViewModelFactory(Context context) {        UserDataSource dataSource = provideUserDateSource(context);        return new ViewModelFactory(dataSource);    }</code></pre><p>该方法的功能非常明确，就是为我们实例化出一个 <code>ViewModelFactory</code> 对象，为我们往后创建 <code>ViewModel</code> 作准备。可以看到，这里我们调用了前面的 <code>provideUserDateSource</code> 方法，通过该方法获得了对数据库操作的 <code>LocalUserDataSource</code> 对象，这里我们就看到了单例模式使用的先见性，使得数据库不会被反复的创建、连接。</p><ul><li>好了，至此所有准备工作都已经完成，让我们开始视图层 UserActivity 的调用</li><li>由于 <code>UserActivity</code> 的内容较多我就不贴完整的代码，我们逐步进行讲解</li></ul><hr><h4 id="准备数据成员"><a href="#准备数据成员" class="headerlink" title="准备数据成员"></a>准备数据成员</h4><p>首先我们准备了所需的给类数据成员：</p><pre><code class="java">    private static final String TAG = UserActivity.class.getSimpleName();    private TextView mUserName;    private EditText mUserNameInput;    private Button mUpdateButton;    // 一个 ViewModel 用于获得 Activity &amp; Fragment 实例    private ViewModelFactory mViewModelFactory;    // 用于访问数据库    private UserViewModel mViewModel;    // disposable 是订阅事件，可以用来取消订阅。防止在 activity 或者 fragment 销毁后仍然占用着内存，无法释放。    private final CompositeDisposable mDisposable = new CompositeDisposable();</code></pre><ul><li>首先界面操作的各个控件</li><li>接这就是 <code>mViewModelFactory</code> 、 <code>mViewModel</code> 两个数据成员，用于负责数据源的操作</li><li>再就是一个 <code>CompositeDisposable</code> 对象，用于管理订阅事件，防止 Activity 结束后，订阅仍在进行的情况</li></ul><h4 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate"></a>onCreate</h4><p>控件、数据源层、数据库等的初始化</p><pre><code class="java">    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_user);        mUserName = findViewById(R.id.user_name);        mUserNameInput = findViewById(R.id.user_name_input);        mUpdateButton = findViewById(R.id.update_user);        // 实例化 ViewModelFactory 对象，准备实例化 ViewModel        mViewModelFactory = Injection.provideViewModelFactory(this);        mViewModel = new ViewModelProvider(this, mViewModelFactory).get(UserViewModel.class);        mUpdateButton.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                updateUserName();            }        });    }</code></pre><ul><li>首先是各类控件的初始化</li><li>接着是 <code>ViewModel</code> 的初始化，在这过程中，也就实现了数据库的链接</li><li>用户信息按钮监听器绑定，点击执行 <code>updateUserName</code> 方法如下</li></ul><h4 id="updateUserName"><a href="#updateUserName" class="headerlink" title="updateUserName"></a>updateUserName</h4><p>修改数据库中用户信息</p><pre><code class="java">    private void updateUserName() {        String userName = mUserNameInput.getText().toString();        // 在完成用户名更新之前禁用“更新”按钮        mUpdateButton.setEnabled(false);        // 开启观察者模式        // 更新用户信息，结束后重新开启按钮        mDisposable.add(mViewModel.updateUserName(userName)        .subscribeOn(Schedulers.io())        .observeOn(AndroidSchedulers.mainThread())        .subscribe(new Action() {            @Override            public void run() throws Exception {                mUpdateButton.setEnabled(true);            }        }, new Consumer&lt;Throwable&gt;() {            @Override            public void accept(Throwable throwable) throws Exception {                Log.d(TAG, &quot;accept: Unable to update username&quot;);            }        }));    }</code></pre><ul><li>获得新的用户名</li><li>将按钮设为不可点击</li><li>在 <code>io</code> 线程中访问数据库进行修改</li><li>切换到主线程进行相应处理，比如让按钮恢复到可点击状态</li></ul><h4 id="onStart"><a href="#onStart" class="headerlink" title="onStart"></a>onStart</h4><p>初始化用户信息，修改 <code>UI</code> 界面内容</p><pre><code class="java">    @Override    protected void onStart() {        super.onStart();        // 观察者模式        // 通过 ViewModel 从数据库中读取 UserName 显示        // 如果读取失败，显示错误信息        mDisposable.add(mViewModel.getUserName()                .subscribeOn(Schedulers.io())                .observeOn(AndroidSchedulers.mainThread())        .subscribe(new Consumer&lt;String&gt;() {            @Override            public void accept(String s) throws Exception {                mUserName.setText(s);            }        }, new Consumer&lt;Throwable&gt;() {            @Override            public void accept(Throwable throwable) throws Exception {                Log.e(TAG, &quot;Unable to update username&quot;);            }        }));    }</code></pre><ul><li>在 <code>io</code> 线程中进行数据库访问</li><li>切换到主线程，修改 <code>UI</code> 信息</li></ul><h4 id="onStop"><a href="#onStop" class="headerlink" title="onStop"></a>onStop</h4><p>取消订阅</p><pre><code class="java">    @Override    protected void onStop() {        super.onStop();        // 取消订阅。防止在 activity 或者 fragment 销毁后仍然占用着内存，无法释放。        mDisposable.clear();    }</code></pre><ul><li>通过我们之前实例化的 <code>CompositeDisposable</code> 对象，解除订阅关系</li></ul><hr><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h4 id="Demo-地址"><a href="#Demo-地址" class="headerlink" title="Demo 地址"></a>Demo 地址</h4><p><a href="https://github.com/FishInWater-1999/ArchitectureComponentsStudy" target="_blank" rel="noopener">ArchitectureComponentsStudy</a></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>学会使用 <code>Android Architecture Components</code> 提供的组件简化我们的开发，能够使我们开发的应用模块更解耦更稳定，视图与数据持久层分离，以及更好的扩展性与灵活性。最后，码字不易，别忘了点个赞哦</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Room</tag>
      
      <tag>RxJava</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>