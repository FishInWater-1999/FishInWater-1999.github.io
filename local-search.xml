<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>在 Mac 上安装 Git ，生成 SSH 密钥用于 GitHub 授权</title>
    <link href="undefined2019/10/04/%E5%9C%A8-Mac-%E4%B8%8A%E5%AE%89%E8%A3%85-Git-%EF%BC%8C%E7%94%9F%E6%88%90-SSH-%E5%AF%86%E9%92%A5%E7%94%A8%E4%BA%8E-GitHub-%E6%8E%88%E6%9D%83/"/>
    <url>2019/10/04/%E5%9C%A8-Mac-%E4%B8%8A%E5%AE%89%E8%A3%85-Git-%EF%BC%8C%E7%94%9F%E6%88%90-SSH-%E5%AF%86%E9%92%A5%E7%94%A8%E4%BA%8E-GitHub-%E6%8E%88%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在本教程中，将介绍如何在 Mac 上安装 Git，如何生成SSH密钥，以及如何将您的公共 SSH 密钥上传到 GitHub 帐户进行授权。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190920090245710.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="如何在你的-Mac-上安装-Git-？"><a href="#如何在你的-Mac-上安装-Git-？" class="headerlink" title="如何在你的 Mac 上安装 Git ？"></a>如何在你的 Mac 上安装 Git ？</h1><p>打开‘终端’输入如下命令：</p><pre><code class="xml">$ brew install git</code></pre><blockquote><p> 具体方法查看其官方文档 ：<a href="https://brew.sh/" target="_blank" rel="noopener">https://brew.sh/</a></p></blockquote><p>这将在您的系统上安装 Git。<br>若要确认是否安装成功，请输入：</p><pre><code class="xml">$ git --version</code></pre><p>这样你就能看到目前的 Git 版本。</p><h1 id="如何为-GitHub-授权生成-SSH-密钥"><a href="#如何为-GitHub-授权生成-SSH-密钥" class="headerlink" title="如何为 GitHub 授权生成 SSH 密钥"></a>如何为 GitHub 授权生成 SSH 密钥</h1><h4 id="打开你的终端"><a href="#打开你的终端" class="headerlink" title="打开你的终端"></a>打开你的终端</h4><h4 id="输入-cd-来到你的根目录下"><a href="#输入-cd-来到你的根目录下" class="headerlink" title="输入  cd ~/  来到你的根目录下"></a>输入  <strong>cd ~/</strong>  来到你的根目录下</h4><h4 id="输入以下指令："><a href="#输入以下指令：" class="headerlink" title="输入以下指令："></a>输入以下指令：</h4><pre><code class="xml">ssh-keygen -t rsa</code></pre><ul><li>这时系统将提示您输入一个文件名来存储密钥 </li><li>只需按 ‘回车’ 接受默认文件 (/Users/you/.ssh/id_rsa) 即可</li><li>然后它会要求您创建一个密码。你可以进行设定，但我一般选择直接回车（这样密码就为空，不用专门去记）</li></ul><h4 id="当你再次按下‘回车’时，以下两个文件就会被建立了"><a href="#当你再次按下‘回车’时，以下两个文件就会被建立了" class="headerlink" title="当你再次按下‘回车’时，以下两个文件就会被建立了"></a>当你再次按下‘回车’时，以下两个文件就会被建立了</h4><pre><code class="xml">~/.ssh/id_rsa~/.ssh/id_rsa.pub</code></pre><h4 id="最后一步："><a href="#最后一步：" class="headerlink" title="最后一步："></a>最后一步：</h4><p>我们需要的 SSH 公钥存储在以.pub结尾的文件中，即：<br><code>~/.ssh/id_rsa.pub</code></p><h1 id="如何复制公共-SSH-密钥"><a href="#如何复制公共-SSH-密钥" class="headerlink" title="如何复制公共 SSH 密钥"></a>如何复制公共 SSH 密钥</h1><p>为了使用 GitHub 验证您自己和您的设备，您需要将上面生成的公共 SSH密钥 上传到你的 GitHub 帐户。</p><p><strong>复制公共SSH密钥</strong></p><p>你不需要去寻找这个 .pub 文件，你只需要打开终端并输入：</p><pre><code class="xml">$ pbcopy &lt; ~/.ssh/id_rsa.pub</code></pre><p>这将直接复制 <code>id_rsa</code> 文件内的内容。</p><h1 id="如何上传您的公共-SSH-密钥到-GitHub"><a href="#如何上传您的公共-SSH-密钥到-GitHub" class="headerlink" title="如何上传您的公共 SSH 密钥到 GitHub"></a>如何上传您的公共 SSH 密钥到 GitHub</h1><ol><li>复制了公共SSH密钥后，登录到GitHub帐户并转到 <a href="https://github.com/settings/profile" target="_blank" rel="noopener">https://github.com/settings/profile</a></li><li>在左侧菜单中，您将看到一个链接“SSH和GPG密钥”</li><li>单击该链接，它将带您进入一个页面，您可以在这里输入您之前复制的公共SSH密钥。</li><li>点击“新建SSH密钥”按钮</li><li>然后输入一个标题名称——可以是任何东西，例如 newMac</li><li>将公共SSH密钥粘贴到密钥文本框中</li><li>点击“添加SSH密钥”</li></ol><h1 id="大功告成！测试你的GitHub授权"><a href="#大功告成！测试你的GitHub授权" class="headerlink" title="大功告成！测试你的GitHub授权:"></a>大功告成！测试你的GitHub授权:</h1><p>打开你的终端输入</p><pre><code class="xml">$ git clone git@github.com:你的用户名/你的某个仓库名.git</code></pre><ol><li>它会问你是否想继续连接，输入 <code>yes</code></li><li>如果您在生成公钥时创建了一个密码，那么它将要求您输入它。</li><li>输入密码并按<code>Enter</code>键。</li><li>然后，它将开始将项目克隆到您当前的目录中。</li></ol><p><strong>现在，您已经准备好使用Git和GitHub了。有问题欢迎在评论区留言</strong></p><blockquote><p>欢迎关注我的博客获得更多知识</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>每个人都要学的图片压缩终极奥义，有效解决 Android 程序 OOM</title>
    <link href="undefined2019/10/03/101837623/"/>
    <url>2019/10/03/101837623/</url>
    
    <content type="html"><![CDATA[<h1 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h1><hr><blockquote><p>在我们编写 <code>Android</code> 程序的时候，几乎永远逃避不了图片压缩的难题。除了应用图标之外，我们所要显示的图片基本上只有两个来源：</p><ul><li>来自网络下载</li><li>本地相册中加载</li></ul></blockquote><p>不管是网上下载下来的也好，还是从系统图片库中读取的图片，都有一个相同的特点：像素一帮较高。同时我们都知道，<code>Android</code> 系统分配给我们每个应用的内存是有限的，由于解析、加载一张图片，需要占用的内存大小，是远大于图片自身大小的。所以，这时程序就可能因为占用了过多的内存，从而出现<code>OOM</code> 现象。那么什么是 <code>OOM</code> 呢？</p><p><code>OOM</code> 即 <code>OutOfMemory</code> 异常，也就是我们所说的 内存溢出 ，其一般表现为应用闪退等现象。那么我们该如何下手去解决呢？</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><hr><p>首先我们发现，我们所加载的这些图片的分辨率，要比我们手机屏幕高得多，更有甚者，我们在一个拇指大的控件上，去加载一个 4k 大图是完全没有必要的，也就是说，如果我们能让每个控件上都去显示相应大小的图片，那么这个问题也就迎刃而解了</p><p>那么，要怎样才能达到图片与控件的对号入座？这时我们就引进了图片压缩的方案：</p><ul><li>首先，获得原图片大小</li><li>其次，获取控件大小</li><li>接着，获取我们图片和控件的比例</li><li>最后，根据这一比例，将图片压缩为适合显示的大小</li></ul><p>那么就让我们开始吧：</p><h1 id="获取原图大小"><a href="#获取原图大小" class="headerlink" title="获取原图大小"></a>获取原图大小</h1><hr><p>我们都知道，<code>Android 向我们提供了 BitmapFactory</code> 这个类，在这个类中有着诸如：<code>decodeResource()</code>  <code>decodeFile()</code>   <code>decodeStream()</code> 等。其中：</p><ul><li>decodeResource()  ：    用于解析资源文件，即 res 文件夹下的图片</li><li>decodeFile() ：               用于解析系统相册中的图片  </li><li>decodeStream() ：        用于解析输入输出流中图片通常，是采用 HttpClient 从下载的图片</li></ul><p>其他的方法这里就不多说了，因为在源码中我们可有i看到，几乎所有的方法，最后都会将图片解析为流的形式，最后调用 <code>decodeStream()</code> 方法，实例化出我们的 <code>Bitmap</code> 对象。</p><p>虽然这些方法对我们是再熟悉不过的了，但对于某些初学者而言，却经常忽略了一个重要的内部类 ：<code>BitmapFactory.Options</code> ，然而他确实我们图片压缩必不可少的，为什么需要这个参数呢？<code>Options</code> 的对象用于确定需要生成的 Bitmap 即目标图片的参数。<br>他的用法很简单，我们先 new 一个 <code>BitmapFactory.Options</code> 对象。再去调用含有 <code>Options</code> 参数的方法，如</p><ul><li><code>public static Bitmap decodeResource(Resources res, int id, Options opts)</code></li><li><code>public static Bitmap decodeResourceStream(@Nullable Resources res,@Nullable TypedValue value,@Nullable InputStream is, @Nullable Rect pad, @Nullable Options opts)</code></li></ul><p>调用完之后我们发现，除了方法放回给我们一个实例化出来的 <code>Bitmap</code> 图片之外，这个 <code>Options</code> 对象中长度、宽度、类型等等属性，也都被设置成了了我们图片的相应属性。所以，我们很容易想到：通过将 <code>Options</code> 对象传入，来获得图片的原始尺寸，为后期的压缩做准备，说干就干，我们将 <code>Options</code> 对象，和 <code>Resources</code>中一张 4k 图片的<code>id</code> 一块传入上诉方法中，来尝试获得它的尺寸，结果我们发现：程序 <code>OOM</code> 崩溃了！</p><p>为什么会发生这种情况？首先我们想想我们为什么要获得这个<code>Options</code> 对象？时为了获得图片的尺寸大小；那我们为什么要获得原图尺寸大小？是为了按照原图尺寸和控件尺寸的比例，将其压缩为适合显示的大小？那我们又为什么要去压缩它为合适的大小呢？是因为如果按照原大小去调用相应的 <code>decode...()</code>方法解析图片，会导致内存占有率过高触发<code>OOM</code> 异常，进而导致程序崩溃啊！没想到的是：结果我们为了获得 <code>Options</code> 而调用了相应的 <code>decode...()</code> 方法，的确 <code>Options</code> 是复制了，但由于该方法适用于生成图片，也就是 <code>Bitmap</code> 对象的。所以程序也在解析这张超大图的过程中<code>OOM</code> 崩溃了</p><p>那么难道就没方法了吗？</p><p>有的，我之前说过：<code>Option</code> 内部有着众多参数，其中有一个叫做：  <code>inJustDecodeBounds</code> 。这个参数默认值为<code>false</code> 。但如果我们先把这个参数设置为 true  时，该方法便不在会去生成相应的 <code>Bitmap</code> ，而仅仅是去测量图片的各种属性，如长度、宽度、类型等等，然后放回一个 <code>null</code> 。所以，我们很容易想到：可以先通过将 <code>inJustDecodeBounds</code> 的值设为 <code>true</code> ，再去调用相应的相应的 <code>decode...()</code>方法，最后再将<code>inJustDecodeBounds</code> 的值改回 <code>false</code> 。这种做法有两个好处：</p><ol><li>既能获得图片大小，由于后续操作</li><li>又成功避免了去解析图片，导致程序 <code>OOM</code> 而崩溃。</li></ol><p>但这恰恰是被很多人所忽略的一点。</p><h4 id="好了，现在给出具体的实现："><a href="#好了，现在给出具体的实现：" class="headerlink" title="好了，现在给出具体的实现："></a>好了，现在给出具体的实现：</h4><pre><code class="java">    public static void calculateOptionsById(@NonNull Resources res,@NonNull BitmapFactory.Options options, int imgId) {        BitmapFactory.decodeResource(res, imgId, options);    }</code></pre><blockquote><p>大家可能发现，这里只将 <code>inJustDecodeBounds</code> 设为<code>true</code>却没有改回<code>false</code> ，这是因为获得 <code>Options</code> 只是图片压缩的第一步，我们在后续方法中将会进行修改</p></blockquote><h1 id="如何进行压缩"><a href="#如何进行压缩" class="headerlink" title="如何进行压缩"></a>如何进行压缩</h1><hr><p>我们继续看 <code>Options</code> 的构成。我们发现，其中有个名为 <code>inSampleSize</code> 的数据成员，他就是关键所在，那么他有着什么意义呢？</p><p>这里我给大家举个例子，比如我这有张 4000*1000 像素的图片：</p><ul><li>当我们把 <code>inSampleSize</code>  的值设为 <code>4</code>时，最后生成出来的图片大小将会是：1000 x 250 像素 </li><li>当我们把<code>inSampleSize</code> 的值设为<code>5</code>时，最后生成出来的图片大小将会是：800 x 200 像素。这是个什么概念？</li></ul><p>这不仅仅是长宽都变为原来四分之一或者五分之一这么简单，而是其图片大小，直接变为原图的 <code>1/(n^2)</code>！也就是说：</p><ul><li>如果原图 <code>2MB</code>，那么当 <code>inSampleSize</code>  赋值为<code>4</code>加载时就只需要 <code>0.125MB</code></li><li>那 如果 <code>inSampleSize</code>  赋值为 <code>5</code> 呢？只需要 <code>0.08 MB</code>！连<code>100k</code> 都不到的小图啊！</li></ul><h4 id="那么下面我就给出这个方法的具体实现："><a href="#那么下面我就给出这个方法的具体实现：" class="headerlink" title="那么下面我就给出这个方法的具体实现："></a>那么下面我就给出这个方法的具体实现：</h4><pre><code class="java">    public static int calculateInSamplesizeByOptions(@NonNull BitmapFactory.Options options, int reqWidth, int reqHeight) {        int inSamplesize   = 1;        int originalWidth  = options.outWidth;        int originalHeight = options.outHeight;        if (originalHeight &gt; reqHeight || originalWidth &gt; reqWidth) {            int heightRatio = originalHeight / reqHeight;            int widthRatio  = originalWidth  / reqWidth;            inSamplesize = heightRatio &gt; widthRatio ? heightRatio : widthRatio;        }        return inSamplesize;    }</code></pre><p>我们发现，这里我先计算出了，原图尺寸与目标大小大比例，在三目运算符中，将<code>inSamplesize</code> 赋值为较大的一个。为什么不用小的那一个呢？这里我就卖个关子，大家可以在评论区中发表自己的想法</p><h1 id="生成目标图片"><a href="#生成目标图片" class="headerlink" title="生成目标图片"></a>生成目标图片</h1><hr><p>经过前面的两个步骤，想必大家已经能勾勒处这最后一步的做法了，思路非常简单：</p><ol><li>先生成一个 <code>Options</code>对象</li><li>将 <code>Options 的 inJustDecodeBounds</code>设置为<code>true</code></li><li>接着调用方法一<code>calculateOptionsById</code>获得原图尺寸到<code>Options</code>中</li><li>调用方法三<code>calculateInSamplesizeByOptions</code> 获得相应的<code>inSampleSize</code> 对象</li><li>将 <code>Options</code>的<code>inJustDecodeBounds</code>改回 <code>false</code></li><li>再次调用 <code>decode...()</code>方法（这里是 <code>decodeResource</code> ）获得压缩后的 <code>Bitmap</code>对象</li></ol><h4 id="具体实现如下"><a href="#具体实现如下" class="headerlink" title="具体实现如下"></a>具体实现如下</h4><pre><code class="java">    public static Bitmap decodeBitmapById (@NonNull Resources res, int resId, int reqWidth, int reqHeight) {        BitmapFactory.Options options = new BitmapFactory.Options();        options.inJustDecodeBounds = true;        calculateOptionsById(res, options, resId);        options.inSampleSize = calculateInSamplesizeByOptions(options, reqWidth, reqHeight);        options.inJustDecodeBounds = false;        Bitmap bitmap = BitmapFactory.decodeResource(res, resId, options);        return bitmap;    }</code></pre><p>非常棒，我们赶紧看看效果：</p><p><img src="https://img-blog.csdnimg.cn/2019100116455266.png" srcset="/img/loading.gif" alt></p><p>太棒了，几乎和原图效果一摸一样，但软件运行的流畅性确大大提高了！但是，这真的就完美了吗？</p><p>最求完美的我们可能会有个想法：如果调用我们方法的人，或者说特殊时候的我们。不想用这个已经写好的 <code>decodeBitmapById</code>方法，而是像自己通过前两个方法：<code>calculateOptionsById</code>  <code>calculateInSamplesizeByOptions</code> 来实现图片压缩功能，这是问题就出现了：</p><ul><li>调用 <code>calculateOptionsById</code>  前可能忘记，设置 <code>inJustDecodeBound</code> 为 <code>true</code> ，进而导致计算超大图时，直接发生 <code>OOM</code></li><li>调用完 <code>calculateInSamplesizeByOptions</code> 后可能忘记，设置<code>inJustDecodeBounds</code> 为 <code>false</code>，进而导致无法获得<code>Bitmap</code> 对象，一脸懵逼</li><li>啥都做了结果调用完 <code>calculateInSamplesizeByOptions</code> 没把没回的值赋给 <code>options.inSampleSize</code> ，白忙活一场</li></ul><p>所以，我们需要在优化一下：</p><p>首先，在<code>calculateOptionsById</code>中，默认将 <code>options.inJustDecodeBounds</code> 设置为<code>true</code>：</p><pre><code class="java">    public static void calculateOptionsById(@NonNull Resources res,@NonNull BitmapFactory.Options options, int imgId) {        options.inJustDecodeBounds = true;        BitmapFactory.decodeResource(res, imgId, options);    }</code></pre><p>其次，在 <code>calculateInSamplesizeByOptions</code>最后，默认将 <code>options.inJustDecodeBounds</code>设置为<code>false</code>：</p><pre><code class="java">    public static int calculateInSamplesizeByOptions(@NonNull BitmapFactory.Options options, int reqWidth, int reqHeight) {        int inSamplesize   = 1;        int originalWidth  = options.outWidth;        int originalHeight = options.outHeight;        if (originalHeight &gt; reqHeight || originalWidth &gt; reqWidth) {            int heightRatio = originalHeight / reqHeight;            int widthRatio  = originalWidth  / reqWidth;            inSamplesize = heightRatio &gt; widthRatio ? heightRatio : widthRatio;        }        options.inJustDecodeBounds = false;        return inSamplesize;    }</code></pre><p>为什么不在该方法后面，对 <code>options.inSampleSize</code>进行赋值呢？这主要是防止，有时我们可能只想得到计算相应比例来做其他操作，而不想改变原有属性，所以是否赋值，就交给用户去选择吧</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>好了，到这里为止，历时有关图片压缩的所有坑坑洼洼都已经总结好了，我们从头理以边思路：</p><ol><li>借助<code>options.inJustDecodeBounds</code> 参数赋值<code>true</code>时，不生成图片的特性，将原图尺寸保存在 <code>Options</code> 中</li><li>通过 <code>options</code> 中原图尺寸与目标（控件）尺寸的比例，对 <code>options.inSampleSize</code> 进行设置</li><li>生成目标图片</li><li>压缩的问题解决了，但是每次打开图片都压缩也太麻烦了！下面我将针对这个问题进行更有效地解决 ，有兴趣可以继续关注 <strong><a href="https://blog.csdn.net/qq_43377749" target="_blank" rel="noopener">_yuanhao 的编程世界</a></strong></li></ol><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><hr><p><a href="https://blog.csdn.net/qq_43377749/article/details/101197865" target="_blank" rel="noopener">Android 让你的 Room 搭上 RxJava 的顺风车 从重复的代码中解脱出来</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/100856599" target="_blank" rel="noopener">ViewModel 和 ViewModelProvider.Factory：ViewModel 的创建者</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/96324909" target="_blank" rel="noopener">单例模式-全局可用的 context 对象，这一篇就够了</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/94156207" target="_blank" rel="noopener">缩放手势 ScaleGestureDetector 源码解析，这一篇就够了</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/94155960" target="_blank" rel="noopener">看完这篇还不会 GestureDetector 手势检测，我跪搓衣板！</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/92629161" target="_blank" rel="noopener">Android 属性动画框架 ObjectAnimator、ValueAnimator ，这一篇就够了</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/92425865" target="_blank" rel="noopener">Android 逐帧动画（ Drawable 动画），这一篇就够了</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/91890323" target="_blank" rel="noopener">看完这篇再不会 View 的动画框架，我跪搓衣板</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/91474208" target="_blank" rel="noopener">Android 自定义时钟控件 时针、分针、秒针的绘制这一篇就够了</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/91379915" target="_blank" rel="noopener">android 自定义控件之-绘制钟表盘</a></p><h3 id="请点赞！因为你的鼓励是我写作的最大动力！"><a href="#请点赞！因为你的鼓励是我写作的最大动力！" class="headerlink" title="请点赞！因为你的鼓励是我写作的最大动力！"></a>请点赞！因为你的鼓励是我写作的最大动力！</h3><hr><p>源码 Demo 链接：<strong><a href="https://github.com/FishInWater-1999/Drop/blob/master/app/src/main/java/com/example/drop/utils/BitmapBuilder.java" target="_blank" rel="noopener">Drop 我第一次写的 Android 项目，希望大家点歌 star~ 谢谢！</a></strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android 让你的 Room 搭上 RxJava 的顺风车 从重复的代码中解脱出来</title>
    <link href="undefined2019/10/03/101197865/"/>
    <url>2019/10/03/101197865/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-Room-？"><a href="#什么是-Room-？" class="headerlink" title="什么是 Room ？"></a>什么是 Room ？</h1><hr><p>谷歌为了帮助开发者解决 Android 架构设计问题，在 Google I/O 2017 发布一套帮助开发者解决 Android 架构设计的方案：Android Architecture Components，而我们的 Room 正是这套方案的两大模块之一。</p><ul><li>定义：数据库解决方案</li><li>组成：Database、Entity、DAO</li></ul><h1 id="为什么本文叫谷歌范例？"><a href="#为什么本文叫谷歌范例？" class="headerlink" title="为什么本文叫谷歌范例？"></a>为什么本文叫谷歌范例？</h1><hr><p>为了方便开发者进行学习和理解，Google 在 GitHub 上上传了一系列的 Android Architecture Components 开源代码：<a href="https://github.com/googlesamples/android-architecture-components" target="_blank" rel="noopener">googlesamples/android-architecture-components</a> 本文就是通过解析这套范例的第一部分：<a href="https://github.com/googlesamples/android-architecture-components/tree/master/BasicRxJavaSample" target="_blank" rel="noopener">BasicRxJavaSample</a> 来对 Room 的使用进行分析。</p><p>关于本文中的代码以及后续文章中的代码，我已经上传至我的 GitHub 欢迎大家围观、star<br>详见-&gt; <a href="https://github.com/FishInWater-1999/ArchitectureComponentsStudy" target="_blank" rel="noopener">FishInWater-1999/ArchitectureComponentsStudy</a></p><h1 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h1><hr><h4 id="为什么我们要学-Room"><a href="#为什么我们要学-Room" class="headerlink" title="为什么我们要学 Room"></a>为什么我们要学 Room</h4><p>相比于我们直接使用传统方式，如果直接使用 <code>Java</code> 代码进行 <code>SQLite</code> 操作，每次都需要手写大量重复的代码，对于我们最求梦想的程序员来说，这种无聊的过程简直是一种折磨。于是，<code>Room</code> 也就应运而生了</p><ul><li>它通过注解处理器的形式，将繁琐无趣的代码封装起来，我们只需要添加一个简单的注解，就可以完成一系列复杂的功能！</li></ul><blockquote><p>首先我们需要了解下 <code>Room</code> 的基本组成</p></blockquote><p>前面我们已经说过 Room 的使用，主要由 Database、Entity、DAO 三大部分组成，那么这三大组成部分又分别是什么呢？</p><ul><li>Database：创建一个由 Room 管理的数据库，并在其中自定义所需要操作的数据库表</li></ul><h6 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h6><pre><code>   1. 必须是abstract类而且的extends RoomDatabase。   2. 必须在类头的注释中包含与数据库关联的实体列表(Entity对应的类)。   3. 包含一个具有0个参数的抽象方法，并返回用@Dao注解的类。</code></pre><h6 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h6><p>通过单例模式实现，你可以通过静态 getInstance(…) 方法，获取数据库实例：</p><p><code>public static UsersDatabase getInstance(Context context)</code></p><ul><li><p>Entity：数据库中，某个表的实体类，如：<br><code>@Entity(tableName = &quot;users&quot;)</code><br><code>public class User {...}</code></p></li><li><p>DAO：具体访问数据库的方法的接口<br><code>@Dao</code><br><code>public interface UserDao {...}</code></p></li></ul><h1 id="BasicRxJavaSample-源码解析"><a href="#BasicRxJavaSample-源码解析" class="headerlink" title="BasicRxJavaSample 源码解析"></a>BasicRxJavaSample 源码解析</h1><hr><p>由于是源码解析，那我就以：从基础的类开始，一层层向上，抽丝剥茧，最后融为一体的方式，给大家进行解析。那么现在就让我们开始吧。</p><h4 id="表的搭建"><a href="#表的搭建" class="headerlink" title="表的搭建"></a>表的搭建</h4><p>Room 作为一个 Android 数据库操作的注解集合，最基本操作就是对我们数据库进行的。所以，先让我们试着建立一张名为 “users” 的数据表</p><pre><code class="java">/** * 应用测试的表结构模型 */@Entity(tableName = &quot;users&quot;)// 表名注解public class User {    /**     * 主键     * 由于主键不能为空，所以需要 @NonNull 注解     */    @NonNull    @PrimaryKey    @ColumnInfo(name = &quot;userid&quot;)// Room 列注解    private String mId;    /**     * 用户名     * 普通列     */    @ColumnInfo(name = &quot;username&quot;)    private String mUserName;    /**     * 构造方法     * 设置为 @Ignore 将其忽视     * 这样以来，这个注解方法就不会被传入 Room 中，做相应处理     * @param mUserName     */    @Ignore    public User(String mUserName){        this.mId    = UUID.randomUUID().toString();        this.mUserName = mUserName;    }    /**     * 我们发现与上个方法不同，该方法没有标记 @Ignore 标签     *      * 所以编译时该方法会被传入 Room 中相应的注解处理器，做相应处理     * 这里的处理应该是 add 新数据     * @param id     * @param userName     */    public User(String id, String userName) {        this.mId = id;        this.mUserName = userName;    }    public String getId() {        return mId;    }    public String getUserName() {        return mUserName;    }}</code></pre><p>首先在表头部分，我们就见到了之前说过的 <code>@Entity(...)</code> 标签，之前说过该标签表示数据库中某个表的实体类，我们查看它的源码：</p><pre><code class="java">@Target(ElementType.TYPE)@Retention(RetentionPolicy.CLASS)public @interface Entity {...}</code></pre><p>从中我们可以知道该注解实在编译注解所在的类时触发的，这是我们注意到 Google 对该类的介绍是：</p><pre><code class="xml">Marks a class as an entity. This class will have a mapping SQLite table in the database.</code></pre><p>由此可知当注解所在的类，比如我们的这个 <code>User</code> 类编译时，相应的注解处理器就会调用其内部相应的代码，建立一个名为 <code>users</code> （在 <code>@Entity(tableName = &quot;users&quot;)</code> 中传入的数据表 ）</p><p><strong>我们再往下看：</strong></p><ul><li>@ColumnInfo(name = “userid”) ：该注解注解的数据成员，将会在表中生成相应的名为：<code>userid</code> 的列</li><li>@PrimaryKey ：顾名思义该注解与<code>@ColumnInfo(name = &quot;...&quot;)</code> 注解一起使用，表示表中的主键，这里要注意一点，在 <code>@Entity</code> 的源码中强调：Each entity must have at least 1 field annotated with {@link PrimaryKey}. 也就是说一个被 <code>@Entity(...)</code>  标注的数据表类中至少要有一个主键</li><li>@Ignore ：被该注解注释的数据成员、方法，将会被注解处理器忽略，不进行处理</li></ul><p>这里我们发现，代码中有存在两个构造方法，为什么 GoogleSample 中会存在这种看似多此一举的情况呢？我们再仔细观察就会发想，上方的构造方法标记了 <code>@Ignore</code> 标签，而下方的构造方法却没有。由于在 <code>@Entity</code> 标注的类中，构造方法和列属性的 <code>get()</code> 方法都会被注解处理器自动识别处理。我们就不难想到，Google 之所以这样设计，是因为我们于是需要创建临时的 <code>User</code> 对象，但我们又不希望 <code>@Entity</code> 在我们调用构造方法时，就将其存入数据库。所以我们就有了这个被 <code>@Ignore</code> 的构造方法，用于创建不被自动存入数据库的临时对象，等到我们想将这个对象存入数据库时，调用<code>User(String id, String userName)</code> 即可。</p><h4 id="UserDao"><a href="#UserDao" class="headerlink" title="UserDao"></a>UserDao</h4><p>上面我们通过 <code>@Entity</code> 建立了一张 <code>users</code> 表，下面就让我们用 <code>@Dao</code> 注解来变写 <code>UserDao</code> 接口。</p><pre><code class="java">@Daopublic interface UserDao {    /**     * 为了简便，我们只在表中存入1个用户信息     * 这个查询语句可以获得 所有 User 但我们只需要第一个即可     * @return     */    @Query(&quot;SELECT * FROM Users LIMIT 1&quot;)    Flowable&lt;User&gt; getUser();    /**     * 想数据库中插入一条 User 对象     * 若数据库中已存在，则将其替换     * @param user     * @return     */    @Insert(onConflict = OnConflictStrategy.REPLACE)    Completable insertUser(User user);    /**     * 清空所有数据     */    @Query(&quot;DELETE FROM Users&quot;)    void deleteAllUsers();}</code></pre><p>按照我们正常编写的习惯，我们会在该类中，编写相应的数据库操作代码。但与之不同的是采用 <code>Room</code> 之后，我们将其变为一个接口类，并且只需要编写和设定相应的标签即可，不用再去关心存储操作的具体实现。</p><pre><code class="java">    /**     * 为了简便，我们只在表中存入1个用户信息     * 这个查询语句可以获得 所有 User 但我们只需要第一个即可     * @return     */    @Query(&quot;SELECT * FROM Users LIMIT 1&quot;)    Flowable&lt;User&gt; getUser();</code></pre><p> 这里我们看到，该查询方法使用的是 <code>@Query</code> 注解，那么这个注解的具体功能是什么呢？Google 官方对它的解释是：在一个被标注了 <code>@Dao</code> 标签的类中，用于查询的方法。顾名思义被该注解标注的方法，会被 <code>Room</code> 的注解处理器识别，当作一个数据查询方法，至于具体的查询逻辑并不需要我们关心，我们只需要将 <code>SQL 语句</code> 作为参数，传入 <code>@Query(...)</code> 中即可。之后我们发现，该方法返回的是一个背压 <code>Flowable&lt;...&gt;</code> 类型的对象，这是为了防止表中数据过多，读取速率远大于接收数据，从而导致内存溢出的问题，具体详见 <code>RxJava</code> 的教程，这里我就不赘述了。</p><pre><code class="java">    /**     * 想数据库中插入一条 User 对象     * 若数据库中已存在，则将其替换     * @param user     * @return     */    @Insert(onConflict = OnConflictStrategy.REPLACE)    Completable insertUser(User user);</code></pre><p>我们看到，上述方法被 <code>@Insert</code> 注解所标注，从名字就能看出，这将会是一个插入方法。顾名思义被 <code>@Insert</code> 标注的方法，会用于向数据库中插入数据，唯一让我们迷茫的是括号中的这个 <code>onConflict</code>  参数，<code>onConflict</code>  意为“冲突”，再联想下我们日常生活中的数据库操作，就不难想到：这是用来设定，当插入数据库中的数据，与原数据发生冲突时的处理方法。这里我们传入的是 <code>OnConflictStrategy.REPLACE</code> ，意为“如果数据发生冲突，则用其替换掉原数据”，除此之外还有很多相应操作的参数，比如<code>ROLLBACK</code> <code>ABORT</code> 等，篇幅原因就不详细说明了，大家可以自行查阅官方文档。还有一点值得说的是这个 <code>Completable</code> ，该返回值是 <code>RxJava</code> 的基本类型，它只处理 <code>onComplete</code> <code>onError</code> 事件，可以看成是Rx的Runnable。</p><pre><code class="java">    /**     * 清空所有数据     */    @Query(&quot;DELETE FROM Users&quot;)    void deleteAllUsers();</code></pre><p>最后这个方法就是清空 <code>users</code> 表中的所有内容，很简单，这里就不做说明了。唯一需要注意的是，这里使用了 <code>DELETE FROM 表名</code> 的形式，而不是 <code>truncate table 表名</code> ，区别就在于：效率上<code>truncate</code>比<code>delete</code>快，但<code>truncate</code> 相当于保留表的结构，重新创建了这个表，所以删除后不记录日志，不可以恢复数据。</p><h4 id="UsersDatabase"><a href="#UsersDatabase" class="headerlink" title="UsersDatabase"></a>UsersDatabase</h4><p>有关于 <code>Room</code> 的三大组成我们已经讲完了两个，现在就让我们看看最后一个 <code>@Database</code> 注解：</p><pre><code class="java">@Database(entities = {User.class}, version = 1, exportSchema = false)public abstract class UsersDatabase extends RoomDatabase {    /**     * 单例模式     * volatile 确保线程安全     * 线程安全意味着改对象会被许多线程使用     * 可以被看作是一种 “程度较轻的 synchronized”     */    private static volatile UsersDatabase INSTANCE;    /**     * 该方法由于获得 DataBase 对象     * abstract     * @return     */    public abstract UserDao userDao();    public static UsersDatabase getInstance(Context context) {        // 若为空则进行实例化        // 否则直接返回        if (INSTANCE == null) {            synchronized (UsersDatabase.class) {                if (INSTANCE == null){                    INSTANCE = Room.databaseBuilder(context.getApplicationContext(),                            UsersDatabase.class, &quot;Sample.db&quot;)                            .build();                }            }        }        return INSTANCE;    }}</code></pre><p>老样子， <code>Google</code> 定义中是这么写的：将一个类标记为 <code>Room</code> 数据库。顾名思义，我们需要在标记了该标签的类里，做具体的数据库操作，比如数据库的建立、版本更新等等。我们看到，我们向其中传入了多个参数，包括：<code>entities</code> 以数组结构，标记一系列数据库中的表，这个例子中我们只有一个 <code>User</code> 表，所以只传入一个； <code>version</code> 数据库版本；<code>exportSchema</code> 用于历史版本库的导出</p><pre><code class="java">    /**     * 单例模式     * volatile 确保线程安全     * 线程安全意味着改对象会被许多线程使用     * 可以被看作是一种 “程度较轻的 synchronized”     */    private static volatile UsersDatabase INSTANCE;</code></pre><p> 可以看出这是一个单例模式，用于创建一个全局可获得的 UsersDatabase 对象。</p><pre><code class="java">    public static UsersDatabase getInstance(Context context) {        // 若为空则进行实例化        // 否则直接返回        if (INSTANCE == null) {            synchronized (UsersDatabase.class) {                if (INSTANCE == null){                    INSTANCE = Room.databaseBuilder(context.getApplicationContext(),                            UsersDatabase.class, &quot;Sample.db&quot;)                            .build();                }            }        }        return INSTANCE;    }</code></pre><p>这是单例模式对象 INSTANCE 的获得方法，不明白的同学可以去看我这篇 <a href="https://blog.csdn.net/qq_43377749/article/details/96324909" target="_blank" rel="noopener">单例模式-全局可用的 context 对象，这一篇就够了</a></p><h4 id="UserDataSource"><a href="#UserDataSource" class="headerlink" title="UserDataSource"></a>UserDataSource</h4><p>我们可以看到：绝大多数的数据库操作方法，都定义在了 <code>UserDao</code> 中，虽然一般注解类的方法不会被继承，但是有些被特殊标记的方法可能会被继承，但是我们之后要建立的很多功能类中，都需要去调用 <code>UserDao</code> 里的方法。所以我们这里定义 <code>UserDataSource</code> 接口：</p><pre><code class="java">public interface UserDataSource {    /**     * 从数据库中读取信息     * 由于读取速率可能 远大于 观察者处理速率，故使用背压 Flowable 模式     * Flowable：https://www.jianshu.com/p/ff8167c1d191/     */    Flowable&lt;User&gt; getUser();    /**     * 将数据写入数据库中     * 如果数据已经存在则进行更新     * Completable 可以看作是 RxJava 的 Runnale 接口     * 但他只能调用 onComplete 和 onError 方法，不能进行 map、flatMap 等操作     * Completable：https://www.jianshu.com/p/45309538ad94     */    Completable insertOrUpdateUser(User user);    /**     * 删除所有表中所有 User 对象     */    void  deleteAllUsers();}</code></pre><p>该接口很简单，就是一个工具，方法和  <code>UserDao</code>  一摸一样，这里我们就不赘述了。</p><h4 id="LocalUserDataSource"><a href="#LocalUserDataSource" class="headerlink" title="LocalUserDataSource"></a>LocalUserDataSource</h4><pre><code class="java">public class LocalUserDataSource implements UserDataSource {    private final UserDao mUserDao;    public LocalUserDataSource(UserDao userDao) {        this.mUserDao = userDao;    }    @Override    public Flowable&lt;User&gt; getUser() {        return mUserDao.getUser();    }    @Override    public Completable insertOrUpdateUser(User user) {        return mUserDao.insertUser(user);    }    @Override    public void deleteAllUsers() {        mUserDao.deleteAllUsers();    }}</code></pre><p>我们先看看官方的解析：“使用 <code>Room</code> 数据库作为一个数据源。”即通过该类的对象所持有的 <code>UserDao</code> 对象，进行数据库的增删改查操作。</p><ul><li>到此为止，有关于 Room 对数据库的操作部分就讲完了，接下来我们进行视图层搭建的解析。</li></ul><hr><h4 id="UserViewModel"><a href="#UserViewModel" class="headerlink" title="UserViewModel"></a>UserViewModel</h4><p>首先我们先实现 <code>ViewModel</code> 类，那什么是 <code>ViewModel</code> 类呢？从字面上理解的话，它肯定是跟视图 <code>View</code> 以及数据 <code>Model</code> 相关的。其实正像它字面意思一样，它是负责准备和管理和UI组件 <code>Fragment/Activity</code> 相关的数据类，也就是说 <code>ViewModel</code> 是用来管理UI相关的数据的，同时 <code>ViewModel</code> 还可以用来负责UI组件间的通信。那么现在就来看看他的具体实现：</p><pre><code class="java">public class UserViewModel extends ViewModel {    /**     * UserDataSource 接口     */    private final UserDataSource mDataSource;    private User mUser;    public UserViewModel(UserDataSource dataSource){        this.mDataSource = dataSource;    }    /**     * 从数据库中读取所有 user 名称     * @return 背压形式发出所有 User 的名字     *     * 由于数据库中 User 量可能很大，可能会因为背压导致内存溢出     * 故采用 Flowable 模式，取代 Observable     */    public Flowable&lt;String&gt; getUserName(){        return mDataSource.getUser()                .map(new Function&lt;User, String&gt;() {                    @Override                    public String apply(User user) throws Exception {                        return user.getUserName();                    }                });    }    /**     * 更新/添加 数据     *     * 判断是否为空，若为空则创建新 User 进行存储     * 若不为空，说明该 User 存在，这获得其主键 &#39;getId()&#39; 和传入的新 Name 拼接，生成新 User 存储     * 通过 insertOrUpdateUser 接口，返回 Comparable 对象，监听是否存储成功     * @param userName     * @return     */    public Completable updateUserName(String userName) {        mUser = mUser == null                ? new User(userName)                : new User(mUser.getId(), userName);        return mDataSource.insertOrUpdateUser(mUser);    }}</code></pre><p>代码结构非常简单，<code>mDataSource</code> 就是我们前面建立的 <code>UserDataSource</code> 接口对象，由于我们的数据库操作控制类：<code>LocalUserDataSource</code> 是通过是实现该接口的，所以我们就可以在外部将 <code>LocalUserDataSource</code> 对象传入，从而对他的方法进行相应的回调，也就是先实现了所需的数据库操作。每个方法的功能，我已经在注释中给出，这里就不再赘述</p><h4 id="ViewModelFactory"><a href="#ViewModelFactory" class="headerlink" title="ViewModelFactory"></a>ViewModelFactory</h4><p>有上面我们可以看到，我们已经有了进行数据处理的 <code>ViewModel</code> 类，那么我们这里的 <code>ViewModelFactory</code> 类又有什么作用呢？让我们先看下范例中的实现：</p><pre><code class="java">public class ViewModelFactory implements ViewModelProvider.Factory {    private final UserDataSource mDataSource;    public ViewModelFactory(UserDataSource dataSource) {        mDataSource = dataSource;    }    // 你需要通过 ViewModelProvider.Factory 的 create 方法来创建(自定义的) ViewModel    // 参考文档：https://medium.com/koderlabs/viewmodel-with-viewmodelprovider-factory-the-creator-of-viewmodel-8fabfec1aa4f    @Override    public &lt;T extends ViewModel&gt; T create(@NonNull Class&lt;T&gt; modelClass) {        // 为什么这里用 isAssignableFrom 来判断传入的 modelClass 类的类型， 而不直接用 isInstance 判断？        // 答：二者功能一样，但如果传入值（modelClass 为空）则 isInstance 会报错奔溃，而 isAssignableFrom 不会        if (modelClass.isAssignableFrom(UserViewModel.class)) {            return (T) new UserViewModel(mDataSource);        }        throw new IllegalArgumentException(&quot;Unknown ViewModel class&quot;);    }}</code></pre><p><code>ViewModelFactory</code> 继承自 <code>ViewModelProvider.Factory</code> ，它负责帮你创建 <code>ViewModel</code> 实例。但你也许会问，我们不是已经有了 <code>ViewModel</code> 的构造方法了吗？在用 <code>ViewModelFactory</code> 不是多此一举？如果还不熟悉 <code>ViewModelFactory</code> 有关内容的，可以看下这篇：<a href="https://blog.csdn.net/qq_43377749/article/details/100856599" target="_blank" rel="noopener">ViewModel 和 ViewModelProvider.Factory：ViewModel 的创建者</a></p><h4 id="Injection"><a href="#Injection" class="headerlink" title="Injection"></a>Injection</h4><p>关于 <code>Injection</code> ，这是个帮助类，它和 Room 的逻辑功能并没有关系。<code>Sample</code> 中将其独立出来用于各个对象、类型的注入，先让我们看下该类的实现：</p><pre><code class="java">public class Injection {    /**     * 通过该方法实例化出能操作数据库的 LocalUserDataSource 对象     * @param context     * @return     */    public static UserDataSource provideUserDateSource(Context context) {        // 获得 RoomDatabase        UsersDatabase database = UsersDatabase.getInstance(context);        // 将可操作 UserDao 传入        // 实例化出可操作 LocalUserDataSource 对象方便对数据库进行操作        return new LocalUserDataSource(database.userDao());    }    /**     * 获得 ViewModelFactory 对象     * 为 ViewModel 实例化作准备     * @param context     * @return     */    public static ViewModelFactory provideViewModelFactory(Context context) {        UserDataSource dataSource = provideUserDateSource(context);        return new ViewModelFactory(dataSource);    }}</code></pre><p>该类有两个方法组成，实现了各个类型数据相互间的转换，想再让我们先看下第一个方法：</p><pre><code class="java">    /**     * 通过该方法实例化出能操作数据库的 LocalUserDataSource 对象     * @param context     * @return     */    public static UserDataSource provideUserDateSource(Context context) {        // 获得 RoomDatabase        UsersDatabase database = UsersDatabase.getInstance(context);        // 将可操作 UserDao 传入        // 实例化出可操作 LocalUserDataSource 对象方便对数据库进行操作        return new LocalUserDataSource(database.userDao());    }</code></pre><p>在该方法中，我们首先接到了我们的 <code>context</code> 对象，通过 <code>UsersDatabase.getInstance(context)</code> 方法，让 <code>database</code> 持有 <code>context</code> ，实现数据库的链接和初始化。同时放回一个 <code>LocalUserDataSource</code> 对象，这样一来我们就可以对数据表中的内容惊醒相应的操作。</p><pre><code class="java">    /**     * 获得 ViewModelFactory 对象     * 为 ViewModel 实例化作准备     * @param context     * @return     */    public static ViewModelFactory provideViewModelFactory(Context context) {        UserDataSource dataSource = provideUserDateSource(context);        return new ViewModelFactory(dataSource);    }</code></pre><p>该方法的功能非常明确，就是为我们实例化出一个 <code>ViewModelFactory</code> 对象，为我们往后创建 <code>ViewModel</code> 作准备。可以看到，这里我们调用了前面的 <code>provideUserDateSource</code> 方法，通过该方法获得了对数据库操作的 <code>LocalUserDataSource</code> 对象，这里我们就看到了单例模式使用的先见性，使得数据库不会被反复的创建、连接。</p><ul><li>好了，至此所有准备工作都已经完成，让我们开始视图层 UserActivity 的调用</li><li>由于 <code>UserActivity</code> 的内容较多我就不贴完整的代码，我们逐步进行讲解</li></ul><hr><h4 id="准备数据成员"><a href="#准备数据成员" class="headerlink" title="准备数据成员"></a>准备数据成员</h4><p>首先我们准备了所需的给类数据成员：</p><pre><code class="java">    private static final String TAG = UserActivity.class.getSimpleName();    private TextView mUserName;    private EditText mUserNameInput;    private Button mUpdateButton;    // 一个 ViewModel 用于获得 Activity &amp; Fragment 实例    private ViewModelFactory mViewModelFactory;    // 用于访问数据库    private UserViewModel mViewModel;    // disposable 是订阅事件，可以用来取消订阅。防止在 activity 或者 fragment 销毁后仍然占用着内存，无法释放。    private final CompositeDisposable mDisposable = new CompositeDisposable();</code></pre><ul><li>首先界面操作的各个控件</li><li>接这就是 <code>mViewModelFactory</code> 、 <code>mViewModel</code> 两个数据成员，用于负责数据源的操作</li><li>再就是一个 <code>CompositeDisposable</code> 对象，用于管理订阅事件，防止 Activity 结束后，订阅仍在进行的情况</li></ul><h4 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate"></a>onCreate</h4><p>控件、数据源层、数据库等的初始化</p><pre><code class="java">    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_user);        mUserName = findViewById(R.id.user_name);        mUserNameInput = findViewById(R.id.user_name_input);        mUpdateButton = findViewById(R.id.update_user);        // 实例化 ViewModelFactory 对象，准备实例化 ViewModel        mViewModelFactory = Injection.provideViewModelFactory(this);        mViewModel = new ViewModelProvider(this, mViewModelFactory).get(UserViewModel.class);        mUpdateButton.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                updateUserName();            }        });    }</code></pre><ul><li>首先是各类控件的初始化</li><li>接着是 <code>ViewModel</code> 的初始化，在这过程中，也就实现了数据库的链接</li><li>用户信息按钮监听器绑定，点击执行 <code>updateUserName</code> 方法如下</li></ul><h4 id="updateUserName"><a href="#updateUserName" class="headerlink" title="updateUserName"></a>updateUserName</h4><p>修改数据库中用户信息</p><pre><code class="java">    private void updateUserName() {        String userName = mUserNameInput.getText().toString();        // 在完成用户名更新之前禁用“更新”按钮        mUpdateButton.setEnabled(false);        // 开启观察者模式        // 更新用户信息，结束后重新开启按钮        mDisposable.add(mViewModel.updateUserName(userName)        .subscribeOn(Schedulers.io())        .observeOn(AndroidSchedulers.mainThread())        .subscribe(new Action() {            @Override            public void run() throws Exception {                mUpdateButton.setEnabled(true);            }        }, new Consumer&lt;Throwable&gt;() {            @Override            public void accept(Throwable throwable) throws Exception {                Log.d(TAG, &quot;accept: Unable to update username&quot;);            }        }));    }</code></pre><ul><li>获得新的用户名</li><li>将按钮设为不可点击</li><li>在 <code>io</code> 线程中访问数据库进行修改</li><li>切换到主线程进行相应处理，比如让按钮恢复到可点击状态</li></ul><h4 id="onStart"><a href="#onStart" class="headerlink" title="onStart"></a>onStart</h4><p>初始化用户信息，修改 <code>UI</code> 界面内容</p><pre><code class="java">    @Override    protected void onStart() {        super.onStart();        // 观察者模式        // 通过 ViewModel 从数据库中读取 UserName 显示        // 如果读取失败，显示错误信息        mDisposable.add(mViewModel.getUserName()                .subscribeOn(Schedulers.io())                .observeOn(AndroidSchedulers.mainThread())        .subscribe(new Consumer&lt;String&gt;() {            @Override            public void accept(String s) throws Exception {                mUserName.setText(s);            }        }, new Consumer&lt;Throwable&gt;() {            @Override            public void accept(Throwable throwable) throws Exception {                Log.e(TAG, &quot;Unable to update username&quot;);            }        }));    }</code></pre><ul><li>在 <code>io</code> 线程中进行数据库访问</li><li>切换到主线程，修改 <code>UI</code> 信息</li></ul><h4 id="onStop"><a href="#onStop" class="headerlink" title="onStop"></a>onStop</h4><p>取消订阅</p><pre><code class="java">    @Override    protected void onStop() {        super.onStop();        // 取消订阅。防止在 activity 或者 fragment 销毁后仍然占用着内存，无法释放。        mDisposable.clear();    }</code></pre><ul><li>通过我们之前实例化的 <code>CompositeDisposable</code> 对象，解除订阅关系</li></ul><hr><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h4 id="Demo-地址"><a href="#Demo-地址" class="headerlink" title="Demo 地址"></a>Demo 地址</h4><p><a href="https://github.com/FishInWater-1999/ArchitectureComponentsStudy" target="_blank" rel="noopener">ArchitectureComponentsStudy</a></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>学会使用 <code>Android Architecture Components</code> 提供的组件简化我们的开发，能够使我们开发的应用模块更解耦更稳定，视图与数据持久层分离，以及更好的扩展性与灵活性。最后，码字不易，别忘了点个赞哦</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Room</tag>
      
      <tag>RxJava</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>