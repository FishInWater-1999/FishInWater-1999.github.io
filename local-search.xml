<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Activity 的 36 大难点，你会几个？「建议收藏」</title>
    <link href="undefined2019/11/03/Activity%20%E7%9A%84%2036%20%E5%A4%A7%E9%9A%BE%E7%82%B9%EF%BC%8C%E4%BD%A0%E4%BC%9A%E5%87%A0%E4%B8%AA%EF%BC%9F%E3%80%8C%E5%BB%BA%E8%AE%AE%E6%94%B6%E8%97%8F%E3%80%8D/"/>
    <url>2019/11/03/Activity%20%E7%9A%84%2036%20%E5%A4%A7%E9%9A%BE%E7%82%B9%EF%BC%8C%E4%BD%A0%E4%BC%9A%E5%87%A0%E4%B8%AA%EF%BC%9F%E3%80%8C%E5%BB%BA%E8%AE%AE%E6%94%B6%E8%97%8F%E3%80%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>学 <code>Android</code> 有一段时间了，一直都只顾着学新的东西，最近发现很多平常用的少的东西竟让都忘了，趁着这两天，打算把有关 <code>Activity</code> 的内容以问题的形式梳理出来，也供大家查缺补漏。</li></ul><blockquote><p>本文中，我将一改往日写博客的习惯，全文用 <code>XMind</code> 将所有知识点以思维导图的形式呈现，欢迎大家食用～～</p></blockquote><h1 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h1><hr><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab263bcee1cb?w=1172&h=2174&f=png&s=309415" srcset="/img/loading.gif" alt="文章目录"></p><h1 id="方便大家学习，我在-GitHub-上建立个-仓库"><a href="#方便大家学习，我在-GitHub-上建立个-仓库" class="headerlink" title="方便大家学习，我在 GitHub 上建立个 仓库"></a>方便大家学习，我在 GitHub 上建立个 仓库</h1><hr><ul><li><p>仓库内容与博客同步更新。由于我在 <code>稀土掘金</code> <code>简书</code> <code>CSDN</code> <code>博客园</code> 等站点，都有新内容发布。所以大家可以直接关注该仓库，以免错过精彩内容！</p></li><li><p>仓库地址：<br><a href="https://github.com/FishInWater-1999/android_interviews" target="_blank" rel="noopener">超级干货！精心归纳 <code>Android</code> 、<code>JVM</code> 、算法等，各位帅气的老铁支持一下！给个 Star ！</a></p></li></ul><h1 id="神图"><a href="#神图" class="headerlink" title="神图"></a>神图</h1><hr><ul><li>在开始之前，先让我们看看 <code>Android</code> 的 <code>activity</code> 到底都有哪些东西？</li><li>借一张网上很火的图带你了解 <code>Activity</code></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab263d2eccd9?w=1996&h=1912&f=png&s=155210" srcset="/img/loading.gif" alt="一张图带你了解 Activity"></p><h1 id="一、生命周期"><a href="#一、生命周期" class="headerlink" title="一、生命周期"></a>一、生命周期</h1><hr><ul><li>先贴一张闻名遐迩的图</li><li>我们生命周期先看看具体有哪些方法回调，在逐一攻破：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab263d483f3c?w=545&h=711&f=webp&s=28710" srcset="/img/loading.gif" alt="生命周期"></p><h2 id="1-1-Dialog-弹出时"><a href="#1-1-Dialog-弹出时" class="headerlink" title="1.1 Dialog 弹出时"></a>1.1 Dialog 弹出时</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2640bfa92b?w=658&h=198&f=png&s=17847" srcset="/img/loading.gif" alt="dialog弹出时"></p><ul><li>如果是单纯是创建的 <code>dialog</code> ，<code>Activity</code> 并不会执行生命周期的方法</li><li>但是如果是跳转到一个不是全屏的 <code>Activity</code> 的话, 当然就是按照正常的生命周期来执行了</li><li>即 <code>onPasue()</code> -&gt; <code>onPause()</code> (  不会执行原 <code>Activity</code> 的 <code>onStop()</code> , 否则上个页面就不显示了 )</li></ul><h2 id="1-2-横竖屏切换时"><a href="#1-2-横竖屏切换时" class="headerlink" title="1.2 横竖屏切换时"></a>1.2 横竖屏切换时</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2640d09989?w=1145&h=293&f=png&s=44492" srcset="/img/loading.gif" alt="横竖屏切换时"></p><ul><li><p>不设置 <code>Activity</code> 的 <code>android:configChanges</code> 时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次</p></li><li><p>设置 <code>Activity</code> 的 <code>android:configChanges=&quot;orientation&quot;</code> 时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次</p></li><li><p>设置 <code>Activity</code> 的 <code>android:configChanges=&quot;orientation|keyboardHidden&quot;</code> 时，切屏不会重新调用各个生命周期，只会执行 <code>onConfigurationChanged</code> 方法</p></li><li><p>注意：还有一点，非常重要，一个 <code>Android</code> 的变更细节！当 <code>API &gt;12</code> 时，需要加入 <code>screenSize</code> 属性，否则屏幕切换时即使你设置了 <code>orientation</code> 系统也会重建 <code>Activity</code> ！</p></li><li><p><a href="https://developer.android.com/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">横竖屏切换生命周期的执行</a></p></li></ul><h2 id="1-3-不同场景下-Activity-生命周期的变化过程"><a href="#1-3-不同场景下-Activity-生命周期的变化过程" class="headerlink" title="1.3 不同场景下 Activity 生命周期的变化过程"></a>1.3 不同场景下 Activity 生命周期的变化过程</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2662135b32?w=738&h=299&f=png&s=30009" srcset="/img/loading.gif" alt="不同场景下Activity生命周期的变化过程"></p><ul><li>启动 <code>Activity</code> ： <code>onCreate()</code> —&gt; <code>onStart()</code> —&gt; <code>onResume()</code> ，<code>Activity</code> 进入运行状态。</li><li>锁屏时会执行 <code>onPause()</code> 和 <code>onStop()</code> , 而开屏时则应该执行 <code>onStart()</code>  <code>onResume()</code></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2662bc3f51?w=820&h=301&f=png&s=35306" srcset="/img/loading.gif" alt="已启动的 Activity 生命周期的变化"></p><ul><li><code>Activity</code> 退居后台： 当前 <code>Activity</code> 转到新的 <code>Activity</code> 界面或按 <code>Home</code> 键回到主屏： <code>onPause()</code> —&gt; <code>onStop()</code> ，进入停滞状态。</li><li><code>Activity</code> 返回前台： <code>onRestart()</code> —&gt; <code>onStart()</code> —&gt; <code>onResume()</code> ，再次回到运行状态。</li><li><code>Activity</code> 退居后台： 且系统内存不足， 系统会杀死这个后台状态的 <code>Activity</code> ，若再次回到这个 <code>Activity</code> ,则会走 <code>onCreate()</code> –&gt; <code>onStart()</code> —&gt; <code>onResume()</code></li></ul><h2 id="1-4-将一个-Activity-设置成窗口的样式"><a href="#1-4-将一个-Activity-设置成窗口的样式" class="headerlink" title="1.4 将一个 Activity 设置成窗口的样式"></a>1.4 将一个 Activity 设置成窗口的样式</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2666b5baec?w=688&h=193&f=png&s=12952" srcset="/img/loading.gif" alt="设置 Activity 成窗口样式"></p><p>只需要给我们的 <code>Activity</code> 配置如下属性即可。<br><code>android:theme=&quot;@android:style/Theme.Dialog&quot;</code></p><h2 id="1-5-退出已调用多个-Activity-的-Application"><a href="#1-5-退出已调用多个-Activity-的-Application" class="headerlink" title="1.5 退出已调用多个 Activity 的 Application"></a>1.5 退出已调用多个 Activity 的 Application</h2><ul><li>通常情况用户退出一个 <code>Activity</code> 只需按返回键,我们写代码想退出 <code>activity</code> 直接调用 <code>finish()</code> 方法就行。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2668399456?w=1113&h=406&f=png&s=64712" srcset="/img/loading.gif" alt="退出调用多个 Activity 的 Application"></p><ul><li>发送特定广播:</li></ul><ol><li>在需要结束应用时, 发送一个特定的广播,每个 <code>Activity</code> 收到广播后,关闭 即可。</li><li>给某个 <code>activity</code> 注册接受接受广播的意图 <code>registerReceiver(receiver, filter)</code></li><li>如果过接受到的是 关闭 <code>activity</code> 的广播 <code>activity finish()</code> 掉</li></ol><ul><li>递归退出</li></ul><ol><li>就调用 <code>finish()</code> 方法 把当前的 <code>Activity</code> 退出</li><li>在打开新的 <code>Activity</code> 时使用 <code>startActivityForResult</code> , 然后自己加标志, 在 <code>onActivityResult</code> 中处理, 递归关闭。</li></ol><ul><li>其实 </li></ul><ol><li>也可以通过 <code>intent</code> 的 <code>flag</code> 来实现 <code>intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)</code> 激活一个新的 <code>activity</code>。 </li><li>此时如果该任务栈中已经有该 <code>Activity</code> , 那么系统会把这个 <code>Activity</code> 上面的所有 <code>Activity</code> 干掉。</li><li>其实相当于给 <code>Activity</code> 配置的启动模式为 <code>singleTask</code> 。</li></ol><ul><li>记录打开的 <code>Activity</code> </li></ul><ol><li>每打开一个 <code>Activity</code> , 就记录下来。</li><li>在需要退出时 , 关闭每一个 <code>Activity</code></li></ol><h2 id="1-6-锁定屏与解锁屏幕，Activity-如何执行生命周期"><a href="#1-6-锁定屏与解锁屏幕，Activity-如何执行生命周期" class="headerlink" title="1.6 锁定屏与解锁屏幕，Activity 如何执行生命周期"></a>1.6 锁定屏与解锁屏幕，Activity 如何执行生命周期</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1b5f0ff6a9d15?w=767&h=204&f=png&s=20121" srcset="/img/loading.gif" alt="锁定屏与解锁屏幕，Activity如何执行生命周期"></p><ul><li>锁屏时会执行 <code>onPause()</code> 和 <code>onStop()</code> , 而开屏时则应该执行 <code>onStart()</code>  <code>onResume()</code></li></ul><h2 id="1-7-修改-Activity-进入和退出动画"><a href="#1-7-修改-Activity-进入和退出动画" class="headerlink" title="1.7 修改 Activity 进入和退出动画"></a>1.7 修改 Activity 进入和退出动画</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2666eae897?w=1072&h=216&f=png&s=30643" srcset="/img/loading.gif" alt="修改 Activity 进入和退出动画"></p><ul><li>可以通过两种方式 ， 一是通过定义 <code>Activity</code> 的主题 ，二是通过覆写 <code>Activity</code> 的 <code>overridePendingTransition</code> 方法。</li><li>通过设置主题样式在 <code>styles.xml</code> 中编辑代码 ,  添加 <code>themes.xml</code> 文件：在 <code>AndroidManifest.xml</code> 中给指定的 <code>Activity</code> 指定 <code>theme</code>。</li><li>覆写 <code>overridePendingTransition</code> 方法：<code>overridePendingTransition(R.anim.fade, R.anim.hold)</code>; </li></ul><h2 id="1-8-Activity-的四种状态"><a href="#1-8-Activity-的四种状态" class="headerlink" title="1.8 Activity 的四种状态"></a>1.8 Activity 的四种状态</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab26844b8ee7?w=864&h=275&f=png&s=30322" srcset="/img/loading.gif" alt="四种状态"></p><ul><li><code>runnig</code> ：用户可以点击，<code>activity</code> 处于栈顶状态。</li><li><code>paused</code> ：<code>activity</code> 失去焦点的时候，被一个非全屏的 <code>activity</code> 占据或者被一个透明的 <code>activity</code> 覆盖，这个状态的 <code>activity</code> 并没有销毁，它所有的状态信息和成员变量仍然存在，只是不能够被点击。(内存紧张的情况，这个 <code>activity</code> 有可能被回收)</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2687e2a13a?w=525&h=211&f=png&s=18803" srcset="/img/loading.gif" alt="关闭"></p><ul><li><code>stopped</code> ：这个 <code>activity</code> 被另外一个 <code>activity</code> 完全覆盖，但是这个 <code>activity</code> 的所有状态信息和成员变量仍然存在(除了内存紧张)</li><li><code>killed</code> ：这个 <code>activity</code> 已经被销毁，其所有的状态信息和成员变量已经不存在了。</li></ul><h2 id="1-9-如何处理异常退出"><a href="#1-9-如何处理异常退出" class="headerlink" title="1.9 如何处理异常退出"></a>1.9 如何处理异常退出</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab268bcbf377?w=1096&h=232&f=png&s=38735" srcset="/img/loading.gif" alt="如何处理异常退出"></p><ul><li><code>Activity</code> 异常退出的时候 –&gt; <code>onPause()</code> –&gt; <code>onSaveInstanceState()</code> –&gt; <code>onStop()</code> –&gt; <code>onDestory()</code></li><li>需要注意的是 <code>onSaveInstanceState()</code> 方法与 <code>onPause</code> 并没有严格的先后关系，有可能在 <code>onPause</code> 之前，也有可能在其后面调用，但会在 <code>onStop()</code> 方法之前调用</li><li>异常退出后又重新启动该 <code>Activity</code>  –&gt; <code>onCreate()</code> –&gt; <code>onStart()</code> –&gt; <code>onRestoreInstanceState()</code> –&gt; <code>onResume()</code></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab268c50ae91?w=714&h=259&f=png&s=44082" srcset="/img/loading.gif" alt="异常退出后又重新启动"></p><ul><li>搞懂这个生命周期的执行后就可以回答了，首先要知道面试官的意思：是要重新启动并恢复这个 <code>Activity</code> 还是说直接退出整个 <code>app</code> </li><li>如果要恢复则要在 <code>onSaveInstanceState()</code> 中进行保存数据并在 <code>onRestoreInstanceState()</code> 中进行恢复</li><li>如果是要退出 <code>app</code> 的话就要捕获全局的异常信息，并退出 <code>app</code> </li><li>当然个人建议是使用 <code>UncaughtExceotionHandler</code> 来捕获全局异常进行退出 <code>app</code> 的操作，这样会减少之前崩溃所造成的后遗症！</li></ul><h2 id="1-10-什么是-onNewIntent"><a href="#1-10-什么是-onNewIntent" class="headerlink" title="1.10 什么是 onNewIntent"></a>1.10 什么是 onNewIntent</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab26900d9292?w=909&h=231&f=png&s=22086" srcset="/img/loading.gif" alt="onNewIntent"></p><ul><li><p>如果 <code>IntentActivity</code> 处于任务栈的顶端，也就是说之前打开过的 <code>Activity</code> ，现在处于 <code>onPause</code> 、 <code>onStop</code> 状态的话，其他应用再发送 <code>Intent</code> 的话</p></li><li><p>执行顺序为：<code>onNewIntent</code>，<code>onRestart</code>，<code>onStart</code>，<code>onResume</code>。</p></li></ul><h1 id="二、启动模式"><a href="#二、启动模式" class="headerlink" title="二、启动模式"></a>二、启动模式</h1><hr><h2 id="2-1-启动模式"><a href="#2-1-启动模式" class="headerlink" title="2.1 启动模式"></a>2.1 启动模式</h2><p> <img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2695ac3863?w=412&h=198&f=png&s=9462" srcset="/img/loading.gif" alt="启动模式"></p><ul><li><code>Activity</code> 一共有四种 <code>launchMode</code> ：<code>standard</code> 、<code>singleTop</code> 、<code>singleTask</code> 、<code>singleInstance</code> 。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab26af18ff50?w=865&h=276&f=png&s=34230" srcset="/img/loading.gif" alt="Standard"></p><ul><li><code>Standard</code> 模式（默认模式）</li></ul><ol><li><p>说明： 每次启动一个 <code>Activity</code> 都会又一次创建一个新的实例入栈，无论这个实例是否存在。</p></li><li><p>生命周期：每次被创建的实例 <code>Activity</code> 的生命周期符合典型情况，它的 <code>onCreate</code> 、<code>onStart</code> 、<code>onResume</code> 都会被调用。</p></li><li><p>举例：此时 <code>Activity</code> 栈中以此有 <code>A</code> 、<code>B</code> 、<code>C</code> 三个 <code>Activity</code> ，此时C处于栈顶，启动模式为 <code>Standard</code> 模式。若在 <code>C Activity</code> 中加入点击事件，须要跳转到还有一个同类型的 <code>C Activity</code> 。结果是还有一个 <code>C Activity</code> 进入栈中，成为栈顶。</p></li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab26af2f73ef?w=826&h=298&f=png&s=50008" srcset="/img/loading.gif" alt="SingleTop"></p><ul><li><code>SingleTop</code> 模式（栈顶复用模式）</li></ul><ol><li><p>说明：分两种处理情况：须要创建的 <code>Activity</code> 已经处于栈顶时，此时会直接复用栈顶的 <code>Activity</code> 。不会再创建新的 <code>Activity</code> ；若须要创建的 <code>Activity</code> 不处于栈顶，此时会又一次创建一个新的 <code>Activity</code> 入栈，同 <code>Standard</code> 模式一样。</p></li><li><p>生命周期：若情况一中栈顶的 <code>Activity</code> 被直接复用时，它的 <code>onCreate</code> 、<code>onStart</code> 不会被系统调用，由于它并没有发生改变。可是一个新的方法 <code>onNewIntent</code> 会被回调（ <code>Activity</code> 被正常创建时不会回调此方法）。</p></li><li><p>举例：此时 <code>Activity</code> 栈中以此有 <code>A</code> 、<code>B</code> 、<code>C</code> 三个 <code>Activity</code> ，此时 <code>C</code> 处于栈顶，启动模式为 <code>SingleTop</code> 模式。情况一：在 <code>C Activity</code> 中加入点击事件，须要跳转到还有一个同类型的 <code>C Activity</code> 。结果是直接复用栈顶的 <code>C Activity</code>。情况二：在 <code>C Activity</code> 中加入点击事件，须要跳转到还有一个 <code>A Activity</code>。结果是创建一个新的 <code>Activity</code> 入栈。成为栈顶。</p></li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab26b234a4cb?w=933&h=310&f=png&s=55368" srcset="/img/loading.gif" alt="SingleTask"></p><ul><li><code>SingleTask</code> 模式（栈内复用模式）</li></ul><ol><li><p>说明：若须要创建的 <code>Activity</code> 已经处于栈中时，此时不会创建新的 <code>Activity</code> ，而是将存在栈中的 <code>Activity</code> 上面的其他 <code>Activity</code> 所有销毁，使它成为栈顶。</p></li><li><p>如果是在别的应用程序中启动它，则会新建一个 <code>task</code> ，并在该task中启动这个 <code>Activity</code> ，<code>singleTask</code> 允许别的 <code>Activity</code> 与其在一个 <code>task</code> 中共存，也就是说，如果我在这个 <code>singleTask</code> 的实例中再打开新的 <code>Activity</code> ，这个新的 <code>Activity</code> 还是会在 <code>singleTask</code> 的实例的 <code>task</code> 中。</p></li><li><p>生命周期：同 <code>SingleTop</code> 模式中的情况一同样。仅仅会又一次回调 <code>Activity</code> 中的 <code>onNewIntent</code> 方法</p></li><li><p>举例：此时 <code>Activity</code> 栈中以此有 <code>A</code> 、<code>B</code> 、<code>C</code> 三个 <code>Activity</code> 。此时 <code>C</code> 处于栈顶，启动模式为 <code>SingleTask</code> 模式。情况一：在 <code>C Activity</code> 中加入点击事件，须要跳转到还有一个同类型的 <code>C Activity</code> 。结果是直接用栈顶的 <code>C Activity</code> 。情况二：在 <code>C Activity</code> 中加入点击事件，须要跳转到还有一个 <code>A Activity</code> 。结果是将 <code>A Activity</code> 上面的 <code>B</code> 、<code>C</code> 所有销毁，使 <code>A Activity</code> 成为栈顶。</p></li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab26b197fba4?w=823&h=295&f=png&s=43520" srcset="/img/loading.gif" alt="ingleInstance"></p><ul><li><code>SingleInstance</code> 模式（单实例模式）</li></ul><ol><li><p>说明： <code>SingleInstance</code> 比较特殊，是全局单例模式，是一种加强的 <code>SingleTask</code> 模式。它除了具有它所有特性外，还加强了一点：只有一个实例，并且这个实例独立运行在一个 <code>task</code> 中，这个 <code>task</code> 只有这个实例，不允许有别的 <code>Activity</code> 存在。</p></li><li><p>这个经常使用于系统中的应用，比如 <code>Launch</code> 、锁屏键的应用等等，整个系统中仅仅有一个！所以在我们的应用中一般不会用到。了解就可以。</p></li><li><p>举例：比方 <code>A Activity</code> 是该模式，启动 <code>A</code> 后。系统会为它创建一个单独的任务栈，由于栈内复用的特性。兴许的请求均不会创建新的 <code>Activity</code> ，除非这个独特的任务栈被系统销毁。</p></li></ol><h2 id="2-2-启动模式的使用方式"><a href="#2-2-启动模式的使用方式" class="headerlink" title="2.2 启动模式的使用方式"></a>2.2 启动模式的使用方式</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab26b281455b?w=1068&h=273&f=png&s=48274" srcset="/img/loading.gif" alt="启动模式的使用方式"></p><ul><li>在 <code>Manifest.xml</code> 中指定 <code>Activity</code> 启动模式</li></ul><ol><li>一种静态的指定方法</li><li>在 <code>Manifest.xml</code> 文件里声明 <code>Activity</code> 的同一时候指定它的启动模式</li><li>这样在代码中跳转时会依照指定的模式来创建 <code>Activity</code> 。</li></ol><ul><li>启动 <code>Activity</code> 时。在 <code>Intent</code> 中指定启动模式去创建 <code>Activity</code></li></ul><ol><li>一种动态的启动模式</li><li>在 <code>new</code> 一个 <code>Intent</code> 后</li><li>通过 <code>Intent</code> 的 <code>addFlags</code> 方法去动态指定一个启动模式。</li></ol><ul><li>注意：以上两种方式都能够为 <code>Activity</code> 指定启动模式，可是二者还是有差别的。</li></ul><ol><li><p>优先级：动态指定方式即另外一种比第一种优先级要高，若两者同一时候存在，以另外一种方式为准。</p></li><li><p>限定范围：第一种方式无法为 <code>Activity</code> 直接指定 <code>FLAG_ACTIVITY_CLEAR_TOP</code> 标识，另外一种方式无法为 <code>Activity</code> 指定 <code>singleInstance</code> 模式。</p></li></ol><h2 id="2-3-启动模式的实际应用场景"><a href="#2-3-启动模式的实际应用场景" class="headerlink" title="2.3 启动模式的实际应用场景"></a>2.3 启动模式的实际应用场景</h2><blockquote><p>这四种模式中的 <code>Standard</code> 模式是最普通的一种，没有什么特别注意。而 <code>SingleInstance</code> 模式是整个系统的单例模式，在我们的应用中一般不会应用到。所以，这里就具体解说  <code>SingleTop</code> 和 <code>SingleTask</code> 模式的运用场景：</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab26b65bb92a?w=1084&h=355&f=png&s=77629" srcset="/img/loading.gif" alt="启动模式的实际应用场景"></p><ul><li><code>SingleTask</code> 模式的运用场景</li></ul><ol><li>最常见的应用场景就是保持我们应用开启后仅仅有一个 <code>Activity</code> 的实例。</li><li>最典型的样例就是应用中展示的主页（ <code>Home</code> 页）。</li><li>假设用户在主页跳转到其他页面，运行多次操作后想返回到主页，假设不使用 <code>SingleTask</code> 模式，在点击返回的过程中会多次看到主页，这明显就是设计不合理了。</li></ol><ul><li><code>SingleTop</code> 模式的运用场景</li></ul><ol><li>假设你在当前的 <code>Activity</code> 中又要启动同类型的 <code>Activity</code> </li><li>此时建议将此类型 <code>Activity</code> 的启动模式指定为 <code>SingleTop</code> ，能够降低Activity的创建，节省内存！</li></ol><ul><li>注意：复用 <code>Activity</code> 时的生命周期回调</li></ul><ol><li>这里还须要考虑一个 <code>Activity</code> 跳转时携带页面參数的问题。</li><li>由于当一个 <code>Activity</code> 设置了 <code>SingleTop</code> 或者 <code>SingleTask</code> 模式后，跳转此 <code>Activity</code> 出现复用原有 <code>Activity</code> 的情况时，此 <code>Activity</code> 的 <code>onCreate</code> 方法将不会再次运行。<code>onCreate</code> 方法仅仅会在第一次创建 <code>Activity</code> 时被运行。</li><li>而一般 <code>onCreate</code> 方法中会进行该页面的数据初始化、<code>UI</code> 初始化，假设页面的展示数据无关页面跳转传递的參数，则不必操心此问题</li><li>若页面展示的数据就是通过 <code>getInten()</code> 方法来获取，那么问题就会出现：<code>getInten()</code> 获取的一直都是老数据，根本无法接收跳转时传送的新数据！</li></ol><ul><li>以下，通过一个样例来具体解释：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab26cff841e2?w=474&h=604&f=png&s=27141" srcset="/img/loading.gif" alt="图片描述"></p><ul><li><p>以上代码中的 <code>CourseDetailActivity</code> 在配置文件里设置了启动模式是 <code>SingleTop</code> 模式，依据上面启动模式的介绍可得知，当 <code>CourseDetailActivity</code> 处于栈顶时。</p></li><li><p>再次跳转页面到 <code>CourseDetailActivity</code> 时会直接复用原有的 <code>Activity</code> ，并且此页面须要展示的数据是从 <code>getIntent()</code> 方法得来，可是 <code>initData()</code> 方法不会再次被调用，此时页面就无法显示新的数据。</p></li><li><p>当然这样的情况系统早就为我们想过了，这时我们须要另外一个回调 <code>onNewIntent（Intent intent）</code>方法。此方法会传入最新的 <code>intent</code> ，这样我们就能够解决上述问题。这里建议的方法是又一次去 <code>setIntent</code> 。然后又一次去初始化数据和 <code>UI</code> 。代码例如以下所看到的：</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab26f4794839?w=377&h=242&f=png&s=8470" srcset="/img/loading.gif" alt="图片描述"></p><ul><li>这样，在一个页面中能够反复跳转并显示不同的内容。</li></ul><h2 id="2-4-快速启动一个-Activity"><a href="#2-4-快速启动一个-Activity" class="headerlink" title="2.4 快速启动一个 Activity"></a>2.4 快速启动一个 Activity</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab26f46155c8?w=720&h=229&f=png&s=21333" srcset="/img/loading.gif" alt="快速启动一个 Activity"></p><ul><li>这个问题其实也是比较简单的，就是不要在 <code>Activity</code> 的 <code>onCreate</code> 方法中执行过多繁重的操作，并且在 <code>onPasue</code> 方法中同样不能做过多的耗时操作。</li></ul><h2 id="2-5-启动流程"><a href="#2-5-启动流程" class="headerlink" title="2.5 启动流程"></a>2.5 启动流程</h2><ul><li><p>注意！这里并不是要回答 <code>Activity</code> 的生命周期！</p></li><li><p><a href="https://juejin.im/entry/58f5b68e61ff4b005807ab47" target="_blank" rel="noopener">3 分钟看懂 <code>Activity</code> 启动流程</a></p></li></ul><h2 id="2-6-Activity-的-Flags"><a href="#2-6-Activity-的-Flags" class="headerlink" title="2.6 Activity 的 Flags"></a>2.6 Activity 的 Flags</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab26f431a604?w=703&h=240&f=png&s=24947" srcset="/img/loading.gif" alt="Activity 的 Flags"></p><ul><li><p>标记位既能够设定Activity的启动模式，如同上面介绍的，在动态指定启动模式，比方 <code>FLAG_ACTIVITY_NEW_TASK</code> 和 <code>FLAG_ACTIVITY_SINGLE_TOP</code> 等。它还能够影响 <code>Activity</code> 的运行状态 ，比方 <code>FLAG_ACTIVITY_CLEAN_TOP</code> 和 <code>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</code> 等。</p></li><li><p>以下介绍几个基本的标记位，切勿死记，理解几个就可以，须要时再查官方文档。</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab26f64ed138?w=1217&h=336&f=png&s=56661" srcset="/img/loading.gif" alt="几个基本的标记位"></p><ul><li><code>FLAG_ACTIVITY_NEW_TASK</code></li></ul><ol><li>作用是为 <code>Activity</code> 指定 <code>“SingleTask”</code> 启动模式。跟在 <code>AndroidMainfest.xml</code> 指定效果同样</li></ol><ul><li><code>FLAG_ACTIVITY_SINGLE_TOP</code></li></ul><ol><li>作用是为 <code>Activity</code> 指定 <code>“SingleTop”</code> 启动模式，跟在 <code>AndroidMainfest.xml</code> 指定效果同样。</li></ol><ul><li><code>FLAG_ACTIVITY_CLEAN_TOP</code></li></ul><ol><li>具有此标记位的 <code>Activity</code> ，启动时会将与该 <code>Activity</code> 在同一任务栈的其他 <code>Activity</code> 出栈。</li><li>一般与 <code>SingleTask</code> 启动模式一起出现。</li><li>它会完毕 <code>SingleTask</code> 的作用。</li><li>但事实上 <code>SingleTask</code> 启动模式默认具有此标记位的作用</li></ol><ul><li><code>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</code></li></ul><ol><li>具有此标记位的 <code>Activity</code> 不会出如今历史 <code>Activity</code> 的列表中</li><li>使用场景：当某些情况下我们不希望用户通过历史列表回到 <code>Activity</code> 时，此标记位便体现了它的效果。</li><li>它等同于在 <code>xml</code> 中指定 <code>Activity</code> 的属性.</li></ol><h2 id="2-7-onNewInstent-方法什么时候执行"><a href="#2-7-onNewInstent-方法什么时候执行" class="headerlink" title="2.7 onNewInstent()方法什么时候执行"></a>2.7 onNewInstent()方法什么时候执行</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2713491d3c?w=800&h=229&f=png&s=21903" srcset="/img/loading.gif" alt="onNewInstent()方法什么时候执行"></p><p>这个是启动模式中的了，当此 <code>Activity</code> 的实例已经存在，并且此时的启动模式为 <code>SingleTask</code> 和 <code>SingleInstance</code> ，另外当这个实例位于栈顶且启动模式为 <code>SingleTop</code> 时也会触发 <code>onNewInstent()</code> 。</p><h1 id="三、数据"><a href="#三、数据" class="headerlink" title="三、数据"></a>三、数据</h1><hr><h2 id="3-1-Activity-间通过-Intent-传递数据大小限制"><a href="#3-1-Activity-间通过-Intent-传递数据大小限制" class="headerlink" title="3.1 Activity 间通过 Intent 传递数据大小限制"></a>3.1 Activity 间通过 Intent 传递数据大小限制</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2718c279eb?w=814&h=239&f=png&s=36222" srcset="/img/loading.gif" alt="Activity 间通过 Intent 传递数据大小限制"></p><ul><li><code>Intent</code> 在传递数据时是有大小限制的，这里官方并未详细说明，不过通过实验的方法可以测出数据应该被限制在 <code>1MB</code> 之内（ <code>1024KB</code> ）</li><li>我们采用传递 <code>Bitmap</code> 的方法，发现当图片大小超过 <code>1024</code>（准确地说是 <code>1020</code> 左右）的时候，程序就会出现闪退、停止运行等异常(不同的手机反应不同)</li><li>因此可以判断 <code>Intent</code> 的传输容量在 <code>1MB</code> 之内。</li></ul><h2 id="3-2-内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行"><a href="#3-2-内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行" class="headerlink" title="3.2 内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行"></a>3.2 内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab271cea5c35?w=1020&h=279&f=png&s=53811" srcset="/img/loading.gif" alt="onSaveInstanceState()"></p><ul><li><p><code>Activity</code> 的 <code>onSaveInstanceState()</code> 和 <code>onRestoreInstanceState()</code> 并不是生命周期方法，它们不同于 <code>onCreate()</code> 、<code>onPause()</code> 等生命周期方法，它们并不一定会被触发。</p></li><li><p><code>onSaveInstanceState()</code> 方法，当应用遇到意外情况（如：内存不足、用户直接按 <code>Home</code> 键）由系统销毁一个 <code>Activity</code> ，<code>onSaveInstanceState()</code> 会被调用。</p></li><li><p>但是当用户主动去销毁一个 <code>Activity</code> 时，例如在应用中按返回键，<code>onSaveInstanceState()</code> 就不会被调用。</p></li><li><p>除非该 <code>activity</code> 不是被用户主动销毁的，通常 <code>onSaveInstanceState()</code> 只适合用于保存一些临时性的状态，而 <code>onPause()</code> 适合用于数据的持久化保存。</p></li></ul><h2 id="3-3-onSaveInstanceState-被执行的场景"><a href="#3-3-onSaveInstanceState-被执行的场景" class="headerlink" title="3.3 onSaveInstanceState() 被执行的场景"></a>3.3 onSaveInstanceState() 被执行的场景</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2734eb5c0d?w=1020&h=279&f=png&s=53811" srcset="/img/loading.gif" alt="onSaveInstanceState() 被执行的场景"></p><ul><li>系统不知道你按下 <code>HOME</code> 后要运行多少其他的程序，自然也不知道 <code>activity A</code> 是否会被销毁</li><li>因此系统都会调用 <code>onSaveInstanceState()</code> ，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则：</li></ul><ol><li>当用户按下 <code>HOME</code> 键时</li><li>长按 <code>HOME</code> 键，选择运行其他的程序时</li><li>锁屏时</li><li>从 <code>activity A</code> 中启动一个新的 <code>activity</code> 时</li><li>屏幕方向切换时</li></ol><h2 id="3-4-两个-Activity-之间跳转时必然会执行的方法"><a href="#3-4-两个-Activity-之间跳转时必然会执行的方法" class="headerlink" title="3.4 两个 Activity 之间跳转时必然会执行的方法"></a>3.4 两个 Activity 之间跳转时必然会执行的方法</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2729e02a24?w=1117&h=241&f=png&s=34792" srcset="/img/loading.gif" alt="两个 Activity 之间跳转时必然会执行的方法"></p><p>一般情况下比如说有两个 <code>activity</code> , 分别叫 <code>A</code> , <code>B</code> ,当在 <code>A</code> 里面激活 <code>B</code> 组件的时候, <code>A</code> 会调用 <code>onPause()</code> 方法,然后 <code>B</code> 调用 <code>onCreate()</code> , <code>onStart()</code> , <code>onResume()</code> 。</p><p>这个时候 <code>B</code> 覆盖了窗体, <code>A</code> 会调用 <code>onStop()</code> 方法. 如果 <code>B</code> 是个透明的,或者 是对话框的样式, 就不会调用 <code>A</code> 的 <code>onStop()</code> 方法。</p><h2 id="3-5-用-Intent-去启动一个Activity-之外的方法"><a href="#3-5-用-Intent-去启动一个Activity-之外的方法" class="headerlink" title="3.5 用 Intent 去启动一个Activity 之外的方法"></a>3.5 用 Intent 去启动一个Activity 之外的方法</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2724c3da3d?w=1104&h=235&f=png&s=25212" srcset="/img/loading.gif" alt="用 Intent 去启动一个Activity 之外的方法"></p><ul><li>使用 <code>adb shell am</code> 命令</li></ul><ol><li><code>am</code> 启动一个 <code>activity</code></li><li><code>adb shell am start com.example.fuchenxuan/.MainActivity</code></li><li><code>am</code> 发送一个广播，使用 <code>action</code></li><li><code>adb shell am broadcast -a magcomm.action.TOUCH_LETTER</code></li></ol><h2 id="3-6-scheme-跳转协议"><a href="#3-6-scheme-跳转协议" class="headerlink" title="3.6 scheme 跳转协议"></a>3.6 scheme 跳转协议</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab273d2660f7?w=1311&h=949&f=png&s=213009" srcset="/img/loading.gif" alt="scheme跳转协议"></p><h4 id="3-6-1-定义"><a href="#3-6-1-定义" class="headerlink" title="3.6.1 定义"></a>3.6.1 定义</h4><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab273f2b0b6b?w=566&h=229&f=png&s=16944" srcset="/img/loading.gif" alt="定义"></p><ul><li><p>服务器可以定制化跳转 <code>app</code> 页面</p></li><li><p><code>app</code> 可以通过 <code>Scheme</code> 跳转到另一个 <code>app</code> 页面</p></li><li><p>可以通过 <code>h5</code> 页面跳转 <code>app</code> 原生页面</p></li></ul><h4 id="3-6-2-协议格式："><a href="#3-6-2-协议格式：" class="headerlink" title="3.6.2 协议格式："></a>3.6.2 协议格式：</h4><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab27484aabff?w=615&h=50&f=png&s=4554" srcset="/img/loading.gif" alt="协议格式"></p><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab275b9808fe?w=439&h=325&f=png&s=24178" srcset="/img/loading.gif" alt="协议格式"></p><ul><li><p><code>qh</code> 代表 <code>Scheme</code> 协议名称</p></li><li><p><code>test</code> 代表 <code>Scheme</code> 作用的地址域</p></li><li><p><code>8080</code> 代表改路径的端口号</p></li><li><p><code>/goods</code> 代表的是指定页面(路径)</p></li><li><p><code>goodsId</code> 和 <code>name</code> 代表传递的两个参数</p></li></ul><h4 id="3-6-3-Scheme使用"><a href="#3-6-3-Scheme使用" class="headerlink" title="3.6.3 Scheme使用"></a>3.6.3 Scheme使用</h4><ul><li>定义一个 <code>Scheme</code></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2743ad29d1?w=790&h=403&f=png&s=33849" srcset="/img/loading.gif" alt></p><ul><li>获取 <code>Scheme</code> 跳转的参数</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2765f5a51a?w=685&h=484&f=png&s=49836" srcset="/img/loading.gif" alt></p><ul><li>调用方式</li></ul><ol><li>原生调用</li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2766001c6d?w=949&h=44&f=png&s=6706" srcset="/img/loading.gif" alt></p><ol start="2"><li>html调用</li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab276d16ed37?w=582&h=30&f=png&s=3615" srcset="/img/loading.gif" alt></p><ol start="3"><li>判断某个Scheme是否有效</li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab278265ad01?w=976&h=106&f=png&s=15178" srcset="/img/loading.gif" alt></p><ul><li>关于scheme跳转协议，可以查看下面的博客，站在巨人的肩膀上，才能看得更远 <a href="https://link.jianshu.com/?t=http://blog.csdn.net/qq_23547831/article/details/51685310" target="_blank" rel="noopener">Android产品研发（十一）–&gt;应用内跳转Scheme协议</a></li></ul><br><h1 id="四、Context"><a href="#四、Context" class="headerlink" title="四、Context"></a>四、Context</h1><hr><h2 id="4-1-Context-Activity-Appliction-的区别"><a href="#4-1-Context-Activity-Appliction-的区别" class="headerlink" title="4.1 Context , Activity , Appliction 的区别"></a>4.1 Context , Activity , Appliction 的区别</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2780c638c9?w=1139&h=223&f=png&s=32214" srcset="/img/loading.gif" alt="Context, Activity, Appliction 的区别"></p><ul><li>相同:<code>Activity</code> 和 <code>Application</code> 都是 <code>Context</code> 的子类。</li><li><code>Context</code> 从字面上理解就是上下文的意思, 在实际应用中它也确实是起到了管理 上下文环境中各个参数和变量的总用, 方便我们可以简单的访问到各种资源。</li><li>不同:维护的生命周期不同。<code>Context</code> 维护的是当前的 <code>Activity</code> 的生命周期, <code>Application</code> 维护的是整个项目的生命周期。</li><li>使用 <code>context</code> 的时候,  小心内存泄露, 防止内存泄露</li></ul><h2 id="4-2-Context-是什么"><a href="#4-2-Context-是什么" class="headerlink" title="4.2 Context 是什么"></a>4.2 Context 是什么</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab278295b2b0?w=1256&h=236&f=png&s=33907" srcset="/img/loading.gif" alt="Context 是什么"></p><ul><li><p>它描述的是一个应用程序环境的信息,即上下文。</p></li><li><p>该类是一个抽象( <code>abstract class</code> )类,  <code>Android</code> 提供了该抽象类的具体实 现类( <code>ContextIml</code> )。</p></li><li><p>通过它我们可以获取应用程序的资源和类, 也包括一些应用级别操作,  例如:启动一个 <code>Activity</code> ,发送广播,接受 <code>Intent</code> ,信息,等。</p></li></ul><h4 id="4-2-1-附加一张-Context-继承关系图"><a href="#4-2-1-附加一张-Context-继承关系图" class="headerlink" title="4.2.1 附加一张 Context 继承关系图"></a>4.2.1 附加一张 Context 继承关系图</h4><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2782c145c5?w=737&h=544&f=webp&s=12866" srcset="/img/loading.gif" alt="Context继承关系图"></p><h2 id="4-3-获取当前屏幕-Activity-的对象"><a href="#4-3-获取当前屏幕-Activity-的对象" class="headerlink" title="4.3 获取当前屏幕 Activity 的对象"></a>4.3 获取当前屏幕 Activity 的对象</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab278bb02fa6?w=808&h=255&f=png&s=29077" srcset="/img/loading.gif" alt="获取当前屏幕Activity的对象"></p><ul><li><p>使用 ActivityLifecycleCallbacks</p></li><li><p><a href="https://link.jianshu.com/?t=http://blog.csdn.net/vfush/article/details/51483436" target="_blank" rel="noopener">Android 如何获取当前Activity实例对象？</a></p></li></ul><h2 id="4-4-Activity-的管理机制"><a href="#4-4-Activity-的管理机制" class="headerlink" title="4.4 Activity 的管理机制"></a>4.4 Activity 的管理机制</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2799c85ff1?w=1467&h=299&f=png&s=80622" srcset="/img/loading.gif" alt="Activity的管理机制"></p><ul><li><p><a href="https://www.jianshu.com/p/33729a7a66da" target="_blank" rel="noopener">Activity的管理机制</a></p></li><li><p>面试官问这个问题，想看看大家对Activity了解是否深入：</p></li></ul><ol><li>什么是 ActivityRecord</li><li>什么是 TaskRecord</li><li>什么是 ActivityManagerService</li></ol><h2 id="4-5-什么是-Activity"><a href="#4-5-什么是-Activity" class="headerlink" title="4.5 什么是 Activity"></a>4.5 什么是 Activity</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab279e0daf15?w=782&h=237&f=png&s=27101" srcset="/img/loading.gif" alt="什么是 Activity"></p><ul><li>四大组件之一，通常一个用户交互界面对应一个 <code>activity</code> 。</li><li><code>activity</code> 是 <code>Context</code> 的子类，同时实现了 <code>window.callback</code> 和 <code>keyevent.callback</code> ，可以处理与窗体用户交互的事件。</li><li>开发中常用的有 <code>FragmentActivity</code> 、<code>ListActivity</code> 、<code>TabActivity</code>（ <code>Android 4.0</code> 被 <code>Fragment</code> 取代）</li></ul><h1 id="五、进程"><a href="#五、进程" class="headerlink" title="五、进程"></a>五、进程</h1><hr><h2 id="5-1-Android-进程优先级"><a href="#5-1-Android-进程优先级" class="headerlink" title="5.1 Android 进程优先级"></a>5.1 Android 进程优先级</h2><ul><li>前台 / 可见 / 服务 / 后台 / 空</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab279eee3314?w=499&h=395&f=png&s=29435" srcset="/img/loading.gif" alt="前台 / 可见 / 服务 / 后台 / 空"></p><h4 id="5-1-1-前台进程：Foreground-process"><a href="#5-1-1-前台进程：Foreground-process" class="headerlink" title="5.1.1 前台进程：Foreground process"></a>5.1.1 前台进程：Foreground process</h4><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab27a5c1b536?w=657&h=325&f=png&s=29327" srcset="/img/loading.gif" alt="前台进程：Foreground process"></p><ul><li>用户正在交互的 <code>Activity</code>（ <code>onResume()</code> ）</li><li>当某个 <code>Service</code> 绑定正在交互的 <code>Activity</code></li><li>被主动调用为前台 <code>Service</code>（ <code>startForeground()</code> ）</li><li>组件正在执行生命周期的回调（ <code>onCreate()</code> 、<code>onStart()</code> 、<code>onDestory()</code> ）</li><li><code>BroadcastReceiver</code> 正在执行 <code>onReceive()</code></li></ul><h4 id="5-1-2-可见进程：Visible-process"><a href="#5-1-2-可见进程：Visible-process" class="headerlink" title="5.1.2 可见进程：Visible process"></a>5.1.2 可见进程：Visible process</h4><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab27a9560902?w=538&h=185&f=png&s=12282" srcset="/img/loading.gif" alt="可见进程：Visible process"></p><ul><li>我们的 <code>Activity</code> 处在 <code>onPause()</code>（没有进入 <code>onStop()</code> ）</li><li>绑定到前台 <code>Activity</code> 的 <code>Service</code></li></ul><h4 id="5-1-3-服务进程：Service-process"><a href="#5-1-3-服务进程：Service-process" class="headerlink" title="5.1.3 服务进程：Service process"></a>5.1.3 服务进程：Service process</h4><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab27ba678cf4?w=395&h=144&f=png&s=6342" srcset="/img/loading.gif" alt="服务进程"></p><ul><li>简单的 <code>startService()</code> 启动。</li></ul><h4 id="5-1-4-后台进程：Background-process"><a href="#5-1-4-后台进程：Background-process" class="headerlink" title="5.1.4 后台进程：Background process"></a>5.1.4 后台进程：Background process</h4><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab27ba9dbb3b?w=595&h=185&f=png&s=12119" srcset="/img/loading.gif" alt="后台进程：Background process"></p><ul><li>对用户没有直接影响的进程 — <code>Activity</code> 处于 <code>onStop()</code> 的时候。</li><li><code>android:process=&quot;:xxx&quot;</code></li></ul><h4 id="5-1-5-空进程：Empty-process"><a href="#5-1-5-空进程：Empty-process" class="headerlink" title="5.1.5 空进程：Empty process"></a>5.1.5 空进程：Empty process</h4><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab27cee0b839?w=833&h=144&f=png&s=11686" srcset="/img/loading.gif" alt="空进程：Empty process"></p><ul><li>不含有任何的活动的组件。（ <code>Android</code> 设计的，处于缓存的目的，为了第二次启动更快，采取的一个权衡）</li></ul><h2 id="5-2-可见进程"><a href="#5-2-可见进程" class="headerlink" title="5.2 可见进程"></a>5.2 可见进程</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab28553037aa?w=1854&h=236&f=png&s=98227" srcset="/img/loading.gif" alt="可见进程"></p><blockquote><p>可见进程指部分程序界面能够被用户看见，却不在前台与用户交互的进程。例如，我们在一个界面上弹出一个对话框（该对话框是一个新的 <code>Activity</code> ），那么在对话框后面的原界面是可见的，但是并没有与用户进行交互，那么原界面就是可见进程。</p></blockquote><ul><li>一个进程满足下面任何一个条件都被认为是可视的：</li></ul><ol><li>寄宿着一个不是前台的活动，但是它对用户仍可见（它的 <code>onPause()</code> 方法已经被调用）。举例来说，这可能发生在，如果一个前台活动在一个对话框（其他进程的）运行之后仍然是可视的，比如输入法的弹出时。</li><li>寄宿着一个服务，该服务绑定到一个可视的活动。</li></ol><ul><li>一个可视进程被认为是及其重要的且不会被杀死，除非为了保持前台进程运行。</li></ul><h2 id="5-3-服务进程"><a href="#5-3-服务进程" class="headerlink" title="5.3 服务进程"></a>5.3 服务进程</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab285541faaa?w=675&h=227&f=png&s=25103" srcset="/img/loading.gif" alt="服务进程"></p><ul><li><p>服务进程是通过 <code>startService()</code> 方法启动的进程，但不属于前台进程和可见进程。例如，在后台播放音乐或者在后台下载就是服务进程。</p></li><li><p>系统保持它们运行，除非没有足够内存来保证所有的前台进程和可视进程。</p></li></ul><h2 id="5-4-后台进程"><a href="#5-4-后台进程" class="headerlink" title="5.4 后台进程"></a>5.4 后台进程</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2855867adb?w=1418&h=237&f=png&s=55303" srcset="/img/loading.gif" alt="后台进程"></p><ul><li>后台进程是一个保持着一个当前对用户不可视的活动（已经调用 <code>Activity</code> 对象的 <code>onStop()</code> 方法）（如果还有除了 <code>UI</code> 线程外其他线程在运行话，不受影响）。</li></ul><blockquote><p>例如我正在使用 <code>qq</code> 和别人聊天，这个时候 <code>qq</code> 是前台进程，但是当我点击 <code>Home</code> 键让 <code>qq</code> 界面消失的时候，这个时候它就转换成了后台进程。</p></blockquote><ul><li>这些进程没有直接影响用户体验，并且可以在任何时候被杀以收回内存用于一个前台、可视、服务进程。</li><li>一般地有很多后台进程运行着，因此它们保持在一个 <code>LRU</code>（ <code>least recently used</code> ，即最近最少使用，如果您学过操作系统的话会觉得它很熟悉，跟内存的页面置换算法 <code>LRU</code> 一样）列表以确保最近使用最多的活动的进程最后被杀。</li></ul><h2 id="5-5-空进程"><a href="#5-5-空进程" class="headerlink" title="5.5 空进程"></a>5.5 空进程</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2855c30501?w=978&h=230&f=png&s=34145" srcset="/img/loading.gif" alt="空进程"></p><ul><li><p>空进程是一个没有保持活跃的应用程序组件的进程，不包含任何活跃组件。</p></li><li><p>保持这个进程可用的唯一原因是作为一个 <code>cache</code> 以提高下次启动组件的速度。系统进程杀死这些进程，以在进程 <code>cache</code> 和潜在的内核 <code>cache</code> 之间平衡整个系统资源。</p></li><li><p><code>android</code> 进程的回收顺序从先到后分别是：空进程，后台进程，服务进程，可见进程，前台进程。</p></li></ul><h2 id="5-6-什么是-ANR，如何避免"><a href="#5-6-什么是-ANR，如何避免" class="headerlink" title="5.6 什么是 ANR，如何避免"></a>5.6 什么是 ANR，如何避免</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab285772443a?w=1629&h=293&f=png&s=78165" srcset="/img/loading.gif" alt="什么是 ANR，如何避免"></p><h4 id="5-6-1-什么是ANR"><a href="#5-6-1-什么是ANR" class="headerlink" title="5.6.1 什么是ANR"></a>5.6.1 什么是ANR</h4><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2865765c07?w=1007&h=219&f=png&s=27032" srcset="/img/loading.gif" alt="什么是ANR"></p><ul><li><code>ANR</code> ，全称为 <code>Application Not Responding</code> 。</li><li>在 <code>Android</code> 中，如果你的应用程序有一段时间没有响应，系统会向用户显示一个对话框，这个对话框称作应用程序无响应对话框。</li></ul><h4 id="5-6-2-用户行为"><a href="#5-6-2-用户行为" class="headerlink" title="5.6.2 用户行为"></a>5.6.2 用户行为</h4><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab287022cf69?w=667&h=227&f=png&s=23177" srcset="/img/loading.gif" alt="用户行为"></p><ul><li>用户可以选择让程序继续运行，也可以让程序停止运行。</li><li>他们在使用你的应用程序时，并不希望每次都要处理这个对话框。</li><li>因此，在程序里对响应性能的设计很重要，这样，系统不会显示 <code>ANR</code> 给用户。</li></ul><h4 id="5-6-3-Android不同组件ANR超时时间不同"><a href="#5-6-3-Android不同组件ANR超时时间不同" class="headerlink" title="5.6.3 Android不同组件ANR超时时间不同"></a>5.6.3 Android不同组件ANR超时时间不同</h4><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2878933ee5?w=647&h=229&f=png&s=17948" srcset="/img/loading.gif" alt="Android不同组件ANR超时时间不同"></p><ul><li>不同的组件发生 <code>ANR</code> 的时间不一样，主线程（ <code>Activity</code> 、<code>Service</code> ）是 <code>5</code> 秒，<code>BroadCastReceiver</code> 是 <code>10</code> 秒。</li></ul><h4 id="5-6-4-解决方案"><a href="#5-6-4-解决方案" class="headerlink" title="5.6.4 解决方案"></a>5.6.4 解决方案</h4><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab2875e5a963" srcset="/img/loading.gif" alt="解决方案"></p><ol><li>将所有耗时操作，比如访问网络，<code>Socket</code> 通信，查询大量 <code>SQL</code> 语句，复杂逻辑计算等都放在子线程中去，然后通过 <code>handler.sendMessage</code> 、<code>runonUITread</code> 、<code>AsyncTask</code> 等方式更新 <code>UI</code> ，以确保用户界面操作的流畅度。</li><li>如果耗时操作需要让用户等待，那么可以在界面上显示进度条。</li></ol><h2 id="5-7-android的任务栈-Task"><a href="#5-7-android的任务栈-Task" class="headerlink" title="5.7 android的任务栈 Task"></a>5.7 android的任务栈 Task</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab287980fd1a?w=1067&h=179&f=png&s=22428" srcset="/img/loading.gif" alt="android的任务栈 Task"></p><ul><li>一个 <code>Task</code> 包含的就是 <code>activity</code> 集合，<code>android</code> 系统可以通过任务栈有序的管理 <code>activity</code> </li><li>一个app当中可能不止一个任务栈，在某些情况下，一个 <code>activity</code> 也可以独享一个任务栈（ <code>singleInstance</code> 模式启动的 <code>activity</code> ）</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><ol><li>本文基本涵盖了 <code>Android Activity</code> 的所有知识点。对于 <code>App</code> 启动、<code>AMS</code> 希望大家能根据文中链接或者 <code>Google</code> 搜索的形式继续展开学习。</li><li><strong><code>重点</code></strong>：关于 <code>Android</code> 的四大组件，到现在为止我才总结完 Activity ，马上我将继续针对，<code>Service</code> ，<code>BroadcastRecevier</code> 等，以及事件分发、滑动冲突、新能优化等重要模块，进行全面总结，欢迎大家关注 <a href="https://juejin.im/user/5d00b2ee6fb9a07ef5622eed" target="_blank" rel="noopener">_yuanhao 的 掘金</a> ，方便及时接收更新</li></ol><h1 id="码字不易，你的点赞是我总结的最大动力！"><a href="#码字不易，你的点赞是我总结的最大动力！" class="headerlink" title="码字不易，你的点赞是我总结的最大动力！"></a>码字不易，你的点赞是我总结的最大动力！</h1><hr><ul><li><p>由于我在「稀土掘金」「简书」「<code>CSDN</code>」「博客园」等站点，都有新内容发布。所以大家可以直接关注我的 <code>GitHub</code> 仓库，以免错过精彩内容！</p></li><li><p>仓库地址：<br><a href="https://github.com/FishInWater-1999/android_interviews" target="_blank" rel="noopener">超级干货！精心归纳 <code>Android</code> 、<code>JVM</code> 、算法等，各位帅气的老铁支持一下！给个 Star ！</a></p></li><li><p>一万多字长文，加上精美思维导图，<strong>记得点赞哦</strong>，欢迎关注 <strong><a href="https://juejin.im/user/5d00b2ee6fb9a07ef5622eed" target="_blank" rel="noopener">_yuanhao 的 掘金</a></strong> ，我们下篇文章见！</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/10/30/16e1ab287ee35ce8?w=2000&h=1215&f=jpeg&s=190057" srcset="/img/loading.gif" alt="Android"></p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>四大组件</tag>
      
      <tag>Activity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>“23个重难点，带你吃透Service知识点”</title>
    <link href="undefined2019/11/01/23%E4%B8%AA%E9%87%8D%E9%9A%BE%E7%82%B9%EF%BC%8C%E5%B8%A6%E4%BD%A0%E5%90%83%E9%80%8FService%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>2019/11/01/23%E4%B8%AA%E9%87%8D%E9%9A%BE%E7%82%B9%EF%BC%8C%E5%B8%A6%E4%BD%A0%E5%90%83%E9%80%8FService%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>学 <code>Android</code> 有一段时间了，想必不少人也和我一样，平时经常东学西凑，感觉知识点有些凌乱难成体系。所以趁着这几天忙里偷闲，把学的东西归纳下，捋捋思路。</li></ul><blockquote><p>这篇文章主要针对 <code>Service</code> 相关的知识点，进行详细的梳理，祝大家食用愉快！</p></blockquote><h1 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h1><p><img src="https://img-blog.csdnimg.cn/20191030211339772.png" srcset="/img/loading.gif" alt="文章目录"></p><h1 id="方便大家学习，我在-GitHub-建立了-仓库"><a href="#方便大家学习，我在-GitHub-建立了-仓库" class="headerlink" title="方便大家学习，我在 GitHub 建立了 仓库"></a>方便大家学习，我在 <a href="https://github.com/FishInWater-1999" target="_blank" rel="noopener">GitHub</a> 建立了 仓库</h1><hr><ul><li><p>仓库内容与博客同步更新。由于我在 <code>稀土掘金</code> <code>简书</code> <code>CSDN</code> <code>博客园</code> 等站点，都有新内容发布。所以大家可以直接关注该仓库，以免错过精彩内容！</p></li><li><p>仓库地址：<br><a href="https://github.com/FishInWater-1999/android_interviews" target="_blank" rel="noopener">超级干货！精心归纳 <code>Android</code> 、<code>JVM</code> 、算法等，各位帅气的老铁支持一下！给个 Star ！</a></p></li></ul><h1 id="第一篇：Service-是什么"><a href="#第一篇：Service-是什么" class="headerlink" title="第一篇：Service 是什么"></a>第一篇：Service 是什么</h1><hr><p><img src="https://img-blog.csdnimg.cn/20191030211618158.png" srcset="/img/loading.gif" alt="Service 是什么"></p><h2 id="1-1-什么是-Service"><a href="#1-1-什么是-Service" class="headerlink" title="1.1 什么是 Service"></a>1.1 什么是 Service</h2><p><img src="https://img-blog.csdnimg.cn/20191030150202294.png" srcset="/img/loading.gif" alt="什么是 Service"></p><ul><li><code>Service</code> (服务) 是一个一种可以在后台执行长时间运行操作而没有用户界面的应用组件。</li><li>服务可由其他应用组件启动（如 <code>Activity</code> ），服务一旦被启动将在后台一直运行，即使启动服务的组件（ <code>Activity</code> ）已销毁也不受影响。</li><li>此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 ( <code>IPC</code> )。</li></ul><h2 id="1-2-Service-通常总是称之为-“后台服务”"><a href="#1-2-Service-通常总是称之为-“后台服务”" class="headerlink" title="1.2 Service 通常总是称之为 “后台服务”"></a>1.2 Service 通常总是称之为 “后台服务”</h2><p><img src="https://img-blog.csdnimg.cn/20191030150457197.png" srcset="/img/loading.gif" alt="Service 通常总是称之为 “后台服务”"></p><ul><li>其中 “后台” 一词是相对于前台而言的，具体是指：其本身的运行并不依赖于用户可视的 <code>UI</code> 界面</li><li>因此，从实际业务需求上来理解，<code>Service</code> 的适用场景应该具备以下条件：</li></ul><ol><li><p>并不依赖于用户可视的 <code>UI</code> 界面（当然，这一条其实也不是绝对的，如前台 <code>Service</code> 就是与 <code>Notification</code> 界面结合使用的）</p></li><li><p>具有较长时间的运行特性</p></li><li><p>注意: 是运行在主线程当中的</p></li></ol><h2 id="1-3-服务进程"><a href="#1-3-服务进程" class="headerlink" title="1.3 服务进程"></a>1.3 服务进程</h2><p><img src="https://img-blog.csdnimg.cn/20191030151353117.png" srcset="/img/loading.gif" alt="服务进程"></p><ul><li><p>服务进程是通过 <code>startService()</code> 方法启动的进程，但不属于前台进程和可见进程。例如，在后台播放音乐或者在后台下载就是服务进程。</p></li><li><p>系统保持它们运行，除非没有足够内存来保证所有的前台进程和可视进程。</p></li></ul><h1 id="第二篇：生命周期"><a href="#第二篇：生命周期" class="headerlink" title="第二篇：生命周期"></a>第二篇：生命周期</h1><hr><p><img src="https://img-blog.csdnimg.cn/20191030211730817.png" srcset="/img/loading.gif" alt="生命周期"></p><h2 id="2-1-Service-的生命周期"><a href="#2-1-Service-的生命周期" class="headerlink" title="2.1 Service 的生命周期"></a>2.1 Service 的生命周期</h2><ul><li>我们先来看看 <code>Service</code> 的生命周期 的基本流程</li><li>一张闻名遐迩的图<br><img src="https://img-blog.csdnimg.cn/20191030122322717.png" srcset="/img/loading.gif" alt="Service的生命周期"></li></ul><h2 id="2-2-开启-Service-的两种方式"><a href="#2-2-开启-Service-的两种方式" class="headerlink" title="2.2 开启 Service 的两种方式"></a>2.2 开启 Service 的两种方式</h2><p><img src="https://img-blog.csdnimg.cn/20191030151926486.png" srcset="/img/loading.gif" alt="开启 Service 的两种方式"></p><h4 id="2-2-1-startService"><a href="#2-2-1-startService" class="headerlink" title="2.2.1 startService()"></a>2.2.1 startService()</h4><p><img src="https://img-blog.csdnimg.cn/20191030154116608.png" srcset="/img/loading.gif" alt="startService()"></p><ol><li><p>定义一个类继承 <code>Service</code></p></li><li><p>在 <code>Manifest.xml</code> 文件中配置该 <code>Service</code> </p></li><li><p>使用 <code>Context</code> 的 <code>startService(intent)</code> 方法开启服务。</p></li><li><p>使用 <code>Context</code> 的 <code>stopService(intent)</code> 方法关闭服务。</p></li><li><p>该启动方式，<code>app</code> 杀死、<code>Activity</code> 销毁没有任何影响，服务不会停止销毁。</p></li></ol><h4 id="2-2-2-bindService"><a href="#2-2-2-bindService" class="headerlink" title="2.2.2 bindService()"></a>2.2.2 bindService()</h4><p><img src="https://img-blog.csdnimg.cn/20191030154935424.png" srcset="/img/loading.gif" alt="bindService()"></p><ol><li><p>创建 <code>BindService</code> 服务端，继承 <code>Service</code> 并在类中，创建一个实现 <code>IBinder</code> 接口的实例对象，并提供公共方法给客户端（ <code>Activity</code> ）调用。</p></li><li><p>从 <code>onBinder()</code> 回调方法返回该 <code>Binder</code> 实例。</p></li><li><p>在客户端（ <code>Activity</code> ）中, 从 <code>onServiceConnection()</code> 回调方法参数中接收 <code>Binder</code> ，通过 <code>Binder</code> 对象即可访问 <code>Service</code> 内部的数据。</p></li><li><p>在 <code>manifests</code> 中注册 <code>BindService</code> , 在客户端中调用  <code>bindService()</code> 方法开启绑定 <code>Service</code> , 调用 <code>unbindService()</code> 方法注销解绑 <code>Service</code> 。</p></li><li><p>该启动方式依赖于客户端生命周期，当客户端 <code>Activity</code> 销毁时,  没有调用 <code>unbindService()</code> 方法 , <code>Service</code> 也会停止销毁。</p></li></ol><h2 id="2-3-Service-有哪些启动方法，有什么区别，怎样停用-Service"><a href="#2-3-Service-有哪些启动方法，有什么区别，怎样停用-Service" class="headerlink" title="2.3 Service 有哪些启动方法，有什么区别，怎样停用 Service"></a>2.3 Service 有哪些启动方法，有什么区别，怎样停用 Service</h2><p><img src="https://img-blog.csdnimg.cn/20191030153659609.png" srcset="/img/loading.gif" alt="Service 的启动与绑定"></p><ul><li>在 <code>Service</code> 的生命周期中，被回调的方法比 <code>Activity</code> 少一些，只有 <code>onCreate</code> , <code>onStart</code> , <code>onDestroy</code> , <code>onBind</code> 和 <code>onUnbind</code> 。</li></ul><ul><li>通常有两种方式启动一个 <code>Service</code> , 他们对 <code>Service</code> 生命周期的影响是不一样的。</li></ul><h4 id="2-3-1-通过-startService"><a href="#2-3-1-通过-startService" class="headerlink" title="2.3.1 通过 startService"></a>2.3.1 通过 <code>startService</code></h4><p><img src="https://img-blog.csdnimg.cn/20191030160201163.png" srcset="/img/loading.gif" alt="被启动的服务的生命周期"></p><ul><li><code>Service</code> 会经历 <code>onCreate</code> 到 <code>onStart</code> ，然后处于运行状态，<code>stopService</code> 的时候调用 <code>onDestroy</code><br>方法。</li></ul><blockquote><p>如果是调用者自己直接退出而没有调用 <code>stopService</code> 的话，<code>Service</code> 会一直在后台运行。</p></blockquote><h4 id="2-3-2-通过-bindService"><a href="#2-3-2-通过-bindService" class="headerlink" title="2.3.2 通过 bindService"></a>2.3.2 通过 <code>bindService</code></h4><p><img src="https://img-blog.csdnimg.cn/2019103016034362.png" srcset="/img/loading.gif" alt="被绑定的服务的生命周期"></p><p><code>Service</code> 会运行 <code>onCreate</code> ，然后是调用 <code>onBind</code> ， 这个时候调用者和 <code>Service</code> 绑定在一起。调用者退出了，<code>Srevice</code> 就会调用 <code>onUnbind</code> -&gt; <code>onDestroyed</code> 方法。</p><blockquote><p>所谓绑定在一起就共存亡了。调用者也可以通过调用 <code>unbindService</code> 方法来停止服务，这时候 <code>Srevice</code> 就会调用 <code>onUnbind</code> -&gt; <code>onDestroyed</code>  方法。</p></blockquote><h4 id="2-3-3-需要注意的是如果这几个方法交织在一起的话，会出现什么情况呢？"><a href="#2-3-3-需要注意的是如果这几个方法交织在一起的话，会出现什么情况呢？" class="headerlink" title="2.3.3 需要注意的是如果这几个方法交织在一起的话，会出现什么情况呢？"></a>2.3.3 需要注意的是如果这几个方法交织在一起的话，会出现什么情况呢？</h4><p><img src="https://img-blog.csdnimg.cn/20191030160446342.png" srcset="/img/loading.gif" alt="被启动又被绑定的服务的生命周期"></p><ol><li><p>一个原则是 <code>Service</code> 的 <code>onCreate</code> 的方法只会被调用一次，就是你无论多少次的 <code>startService</code> 又 <code>bindService</code> ，<code>Service</code> 只被创建一次。</p></li><li><p>如果先是 <code>bind</code> 了，那么 <code>start</code> 的时候就直接运行 <code>Service</code> 的 <code>onStart</code> 方法，如果先是 <code>start</code> ，那么 <code>bind</code> 的时候就直接运行 <code>onBind</code> 方法。</p></li><li><p>如果 <code>service</code> 运行期间调用了 <code>bindService</code> ，这时候再调用 <code>stopService</code> 的话，<code>service</code> 是不会调用 <code>onDestroy</code> 方法的，<code>service</code> 就 <code>stop</code> 不掉了，只能调用 <code>UnbindService</code> , <code>service</code> 就会被销毁</p></li><li><p>如果一个 <code>service</code> 通过 <code>startService</code> 被 <code>start</code> 之后，多次调用 <code>startService</code> 的话，<code>service</code> 会多次调<br>用 <code>onStart</code> 方法。多次调用 <code>stopService</code> 的话，<code>service</code> 只会调用一次 <code>onDestroyed</code> 方法。</p></li><li><p>如果一个 <code>service</code> 通过 <code>bindService</code> 被 <code>start</code> 之后，多次调用 <code>bindService</code> 的话，<code>service</code> 只会调用一次 <code>onBind</code> 方法。多次调用 <code>unbindService</code> 的话会抛出异常。</p></li></ol><h1 id="第三篇：Service-与-Thread"><a href="#第三篇：Service-与-Thread" class="headerlink" title="第三篇：Service 与 Thread"></a>第三篇：Service 与 Thread</h1><hr><p><img src="https://img-blog.csdnimg.cn/20191030211830725.png" srcset="/img/loading.gif" alt="Service 与 Thread"></p><h2 id="3-1-Service-和-Thread-的区别"><a href="#3-1-Service-和-Thread-的区别" class="headerlink" title="3.1 Service 和 Thread 的区别"></a>3.1 Service 和 Thread 的区别</h2><p><img src="https://img-blog.csdnimg.cn/20191030191205256.png" srcset="/img/loading.gif" alt="Service 和 Thread 的区别"></p><h4 id="3-1-1-首先第一点定义上"><a href="#3-1-1-首先第一点定义上" class="headerlink" title="3.1.1 首先第一点定义上"></a>3.1.1 首先第一点定义上</h4><p><img src="https://img-blog.csdnimg.cn/20191030191334271.png" srcset="/img/loading.gif" alt="定义上"></p><ol><li><code>thread</code> 是程序执行的最小单元，他是分配 <code>cpu</code> 的基本单位安卓系统中，我们常说的主线程，<code>UI</code> 线程，也是线程的一种。当然，线程里面还可以执行一些耗时的异步操作。</li><li>而 <code>service</code> 大家记住，它是安卓中的一种特殊机制，<code>service</code> 是运行在主线程当中的，所以说它不能做耗时操作，它是由系统进程托管，其实 <code>service</code>  也是一种轻量级的 <code>IPC</code> 通信，因为 <code>activity</code> 可以和 <code>service</code> 绑定，可以和 <code>service</code> 进行数据通信。</li><li>而且有一种情况，<code>activity</code> 和 <code>service</code> 是处于不同的进程当中，所以说它们之间的数据通信，要通过 <code>IPC</code> 进程间通信的机制来进行操作。</li></ol><h4 id="3-1-2-第二点是在实际开发的过程当中"><a href="#3-1-2-第二点是在实际开发的过程当中" class="headerlink" title="3.1.2 第二点是在实际开发的过程当中"></a>3.1.2 第二点是在实际开发的过程当中</h4><p><img src="https://img-blog.csdnimg.cn/20191030191415511.png" srcset="/img/loading.gif" alt="第二点是在实际开发的过程当中"></p><ol><li>在安卓系统当中，线程一般指的是工作线程，就是后台线程，做一些耗时操作的线程，而主线程是一种特殊的线程，它只是负责处理一些 <code>UI</code> 线程的绘制，<code>UI</code> 线程里面绝对不能做耗时操作，这里是最基本最重要的一点。（这是 <code>Thread</code> 在实际开发过程当中的应用）</li><li>而 <code>service</code> 是安卓当中，四大组件之一，一般情况下也是运行在主线程当中，因此 <code>service</code> 也是不可以做耗时操作的，否则系统会报 ANR 异常（ <code>ANR</code> 全称：<code>Application Not Responding</code> ），就是程序无法做出响应。</li><li>如果一定要在 <code>service</code> 里面进行耗时操作，一定要记得开启单独的线程去做。</li></ol><h4 id="3-1-3-第三点是应用场景上"><a href="#3-1-3-第三点是应用场景上" class="headerlink" title="3.1.3 第三点是应用场景上"></a>3.1.3 第三点是应用场景上</h4><p><img src="https://img-blog.csdnimg.cn/20191030191453697.png" srcset="/img/loading.gif" alt="应用场景上"></p><ol><li>当你需要执行耗时的网络，或者这种文件数据的查询，以及其它阻塞 <code>UI</code> 线程的时候，都应该使用工作线程，也就是开启一个子线程的方式。</li><li>这样才能保证 <code>UI</code> 线程不被占用，而影响用户体验。</li><li>而 <code>service</code> 来说，我们经常需要长时间在后台运行，而且不需要进行交互的情况下才会使用到服务，比如说，我们在后台播放音乐，开启天气预报的统计，还有一些数据的统计等等。</li></ol><h2 id="3-2-为什么要用-Service-而不是-Thread"><a href="#3-2-为什么要用-Service-而不是-Thread" class="headerlink" title="3.2 为什么要用 Service 而不是 Thread"></a>3.2 为什么要用 Service 而不是 Thread</h2><p><img src="https://img-blog.csdnimg.cn/20191030191642698.png" srcset="/img/loading.gif" alt="为什么要用 Service 而不是 Thread "></p><ul><li><code>Thread</code> 的运行是独立于 <code>Activity</code> 的，也就是当一个 <code>Activity</code> 被 <code>finish</code> 之后，如果没有主动停止 <code>Thread</code> 或者 <code>Thread</code> 中的 <code>run</code> 没有执行完毕时那么这个线程会一直执行下去。</li><li>因此这里会出现一个问题：当 <code>Activity</code> 被 <code>finish</code> 之后，你不再持有该 <code>Thread</code> 的引用。</li><li>另一方面，你没有办法在不同的 <code>Activity</code> 中对同一 <code>Thread</code> 进行控制。</li></ul><h2 id="3-3-Service-里面是否能执行耗时的操作"><a href="#3-3-Service-里面是否能执行耗时的操作" class="headerlink" title="3.3 Service 里面是否能执行耗时的操作"></a>3.3 Service 里面是否能执行耗时的操作</h2><p><img src="https://img-blog.csdnimg.cn/20191030192517180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzc3NzQ5,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Service 里面是否能执行耗时的操作"></p><ul><li><p>service 里面不能执行耗时的操作(网络请求,拷贝数据库,大文件 )</p></li><li><p><code>Service</code> 不是独立的进程，也不是独立的线程，它是依赖于应用程序的主线程的，也就是说，在更多时候不建议在 <code>Service</code> 中编写耗时的逻辑和操作（比如:网络请求，拷贝数据库，大文件），否则会引起 <code>ANR</code> 。</p></li><li><p>如果想在服务中执行耗时的任务。有以下解决方案：</p></li></ul><ol><li>在 <code>service</code> 中开启一个子线程</li></ol><pre><code class="java">new Thread(){}.start();</code></pre><ol start="2"><li>可以使用 <code>IntentService</code> 异步管理服务（ 有关 <code>IntentService</code> 的内容在后文中给出 ）</li></ol><h2 id="3-4-Service-是否在-main-thread-中执行"><a href="#3-4-Service-是否在-main-thread-中执行" class="headerlink" title="3.4 Service 是否在 main thread 中执行"></a>3.4 Service 是否在 main thread 中执行</h2><p><img src="https://img-blog.csdnimg.cn/20191030192703436.png" srcset="/img/loading.gif" alt="Service 是否在 main thread 中执行"></p><ul><li>默认情况, 如果没有显示的指 <code>service</code> 所运行的进程, <code>Service</code> 和 <code>activity</code> 是运 行在当前 <code>app</code> 所在进程的 <code>main thread</code> ( <code>UI</code> 主线程)里面。</li><li><code>Service</code> 和 <code>Activity</code> 在同一个线程，对于同一 <code>app</code> 来说默认情况下是在同一个线程中的 <code>main Thread</code> ( <code>UI Thread</code> )</li><li>特殊情况 ,可以在清单文件配置 <code>service</code> 执行所在的进程 ,让 <code>service</code> 在另 外的进程中执行 <code>Service</code> 不死之身</li></ul><h4 id="3-4-1-在-onStartCommand-方法中将-flag-设置为-START-STICKY"><a href="#3-4-1-在-onStartCommand-方法中将-flag-设置为-START-STICKY" class="headerlink" title="3.4.1 在 onStartCommand 方法中将 flag 设置为 START_STICKY ;"></a>3.4.1 在 <code>onStartCommand</code> 方法中将 <code>flag</code> 设置为 <code>START_STICKY</code> ;</h4><pre><code class="xml">&lt;service android:name=&quot;com.baidu.location.f&quot; android:enabled=&quot;true&quot; android:process=&quot;:remote&quot; &gt;&lt;/service&gt;</code></pre><pre><code class="java">return Service.START_STICKY;</code></pre><h4 id="3-4-2-在-xml-中设置了-android-priority"><a href="#3-4-2-在-xml-中设置了-android-priority" class="headerlink" title="3.4.2 在 xml 中设置了 android:priority"></a>3.4.2 在 xml 中设置了 <code>android:priority</code></h4><pre><code class="xml">&lt;!--设置服务的优先级为MAX_VALUE--&gt; &lt;service android:name=&quot;.MyService&quot;          android:priority=&quot;2147483647&quot;          &gt; &lt;/service&gt;</code></pre><h4 id="3-4-3-在-onStartCommand-方法中设置为前台进程"><a href="#3-4-3-在-onStartCommand-方法中设置为前台进程" class="headerlink" title="3.4.3 在 onStartCommand 方法中设置为前台进程"></a>3.4.3 在 <code>onStartCommand</code> 方法中设置为前台进程</h4><pre><code class="java">@Overridepublic int onStartCommand(Intent intent, int flags, int startId) {  Notification notification = new Notification(R.mipmap.ic_launcher, &quot;服务正在运行&quot;,System.currentTimeMillis());   Intent notificationIntent = new Intent(this, MainActivity.class);    PendingIntent pendingIntent = PendingIntent.getActivity(this, 0,notificationIntent,0);    RemoteViews remoteView = new RemoteViews(this.getPackageName(),R.layout.notification);    remoteView.setImageViewResource(R.id.image, R.mipmap.ic_launcher);    remoteView.setTextViewText(R.id.text , &quot;Hello,this message is in a custom expanded view&quot;);    notification.contentView = remoteView;    notification.contentIntent = pendingIntent;    startForeground(1, notification);    return Service.START_STICKY;}</code></pre><h4 id="3-4-4-在-onDestroy-方法中重启-service"><a href="#3-4-4-在-onDestroy-方法中重启-service" class="headerlink" title="3.4.4 在 onDestroy 方法中重启 service"></a>3.4.4 在 <code>onDestroy</code> 方法中重启 <code>service</code></h4><pre><code class="java">@Overridepublic void onDestroy() {    super.onDestroy();    startService(new Intent(this, MyService.class));}</code></pre><h4 id="3-4-5-用-AlarmManager-setRepeating-…-方法循环发送闹钟广播-接收的时候调用-service-的-onstart-方法"><a href="#3-4-5-用-AlarmManager-setRepeating-…-方法循环发送闹钟广播-接收的时候调用-service-的-onstart-方法" class="headerlink" title="3.4.5 用 AlarmManager.setRepeating(…) 方法循环发送闹钟广播, 接收的时候调用 service 的 onstart 方法"></a>3.4.5 用 <code>AlarmManager.setRepeating(…)</code> 方法循环发送闹钟广播, 接收的时候调用 <code>service</code> 的 <code>onstart</code> 方法</h4><pre><code class="java">Intent intent = new Intent(MainActivity.this,MyAlarmReciver.class);PendingIntent sender = PendingIntent.getBroadcast( MainActivity.this, 0, intent, 0);// We want the alarm to go off 10 seconds from now.Calendar calendar = Calendar.getInstance();calendar.setTimeInMillis(System.currentTimeMillis());calendar.add(Calendar.SECOND, 1);AlarmManager am = (AlarmManager) getSystemService(ALARM_SERVICE);//重复闹钟/** *  @param type * @param triggerAtMillis t 闹钟的第一次执行时间，以毫秒为单位 * go off, using the appropriate clock (depending on the alarm type). * @param intervalMillis 表示两次闹钟执行的间隔时间，也是以毫秒为单位 * of the alarm. * @param operation 绑定了闹钟的执行动作，比如发送一个广播、给出提示等等 */am.setRepeating(AlarmManager.RTC_WAKEUP, calendar.getTimeInMillis(), 2 * 1000, sender);</code></pre><h4 id="3-4-6-目前市场面的很多三方的消息推送-SDK-唤醒-APP-例如-Jpush"><a href="#3-4-6-目前市场面的很多三方的消息推送-SDK-唤醒-APP-例如-Jpush" class="headerlink" title="3.4.6 目前市场面的很多三方的消息推送 SDK 唤醒 APP , 例如 Jpush"></a>3.4.6 目前市场面的很多三方的消息推送 <code>SDK</code> 唤醒 <code>APP</code> , 例如 <code>Jpush</code></h4><blockquote><p><code>PS</code>: 以上这些方法并不代表着你的 <code>Service</code> 就永生不死了，只能说是提高了进程的优先级。迄今为止我没有发现能够通过常规方法达到流氓需求 (通过长按 <code>home</code> 键清除都清除不掉) 的方法，目前所有方法都是指通过 <code>Android</code> 的内存回收机制和普通的第三方内存清除等手段后仍然保持运行的方法，有些手机厂商把这些知名的 <code>app</code> 放入了自己的白名单中，保证了进程不死来提高用户体验（如微信、<code>QQ</code> 、陌陌都在小米的白名单中）。如果从白名单中移除，他们终究还是和普通 <code>app</code> 一样躲避不了被杀的命运。</p></blockquote><h1 id="第四篇：InterService"><a href="#第四篇：InterService" class="headerlink" title="第四篇：InterService"></a>第四篇：InterService</h1><hr><ul><li>作为一个老司机，如果连 <code>Interservice</code> 都没听说过，那就有点那个啥了</li></ul><p><img src="https://img-blog.csdnimg.cn/20191030211924789.png" srcset="/img/loading.gif" alt="InterService"></p><h2 id="4-1-什么是-IntentService"><a href="#4-1-什么是-IntentService" class="headerlink" title="4.1 什么是 IntentService"></a>4.1 什么是 IntentService</h2><p><img src="https://img-blog.csdnimg.cn/20191030193330325.png" srcset="/img/loading.gif" alt="什么是 IntentService "></p><ul><li><p><code>IntentService</code> 是 <code>Service</code> 的子类，比普通的 <code>Service</code> 增加了额外的功能。</p></li><li><p>我们常用的 <code>Service</code> 存在两个问题：</p></li></ul><ol><li><p><code>Service</code> 不会专门启动一条单独的进程，<code>Service</code> 与它所在应用位于同一个进程中</p></li><li><p><code>Service</code> 也不是专门一条新线程，因此不应该在 <code>Service</code> 中直接处理耗时的任务</p></li></ol><h2 id="4-2-IntentService-的特征"><a href="#4-2-IntentService-的特征" class="headerlink" title="4.2 IntentService 的特征"></a>4.2 IntentService 的特征</h2><p><img src="https://img-blog.csdnimg.cn/20191030193534387.png" srcset="/img/loading.gif" alt="IntentService 的特征"></p><ul><li><p>会创建独立的 <code>worker</code> 线程来处理所有的 <code>Intent</code> 请求</p></li><li><p>会创建独立的 <code>worker</code> 线程来处理 <code>onHandleIntent()</code> 方法实现的代码，无需处理多线程问题</p></li><li><p>所有请求处理完成后，<code>IntentService</code> 会自动停止，无需调用 <code>stopSelf()</code> 方法停止 <code>Service</code></p></li><li><p>为 <code>Service</code> 的 <code>onBind()</code> 提供默认实现，返回 <code>null</code></p></li><li><p>为 <code>Service</code> 的 <code>onStartCommand</code> 提供默认实现，将请求 <code>Intent</code> 添加到队列中</p></li></ul><h2 id="4-3-Service-和-IntentService-区别"><a href="#4-3-Service-和-IntentService-区别" class="headerlink" title="4.3 Service 和 IntentService 区别"></a>4.3 Service 和 IntentService 区别</h2><p><img src="https://img-blog.csdnimg.cn/20191030194349958.png" srcset="/img/loading.gif" alt="Service 和 IntentService 区别"></p><h4 id="4-3-1-Service-是用于后台服务的"><a href="#4-3-1-Service-是用于后台服务的" class="headerlink" title="4.3.1 Service 是用于后台服务的"></a>4.3.1 <code>Service</code> 是用于后台服务的</h4><p><img src="https://img-blog.csdnimg.cn/20191030194447352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzc3NzQ5,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Service 是用于后台服务的"></p><ol><li>当应用程序被挂到后台的时候，为了保证应用某些组件仍然可以工作而引入了 <code>Service</code> 这个概念</li><li>那么这里面要强调的是：<code>Service</code> 不是独立的进程，也不是独立的线程，它是依赖于应用程序的主线程的，也就是说，在更多时候不建议在 <code>Service</code> 中编写耗时的逻辑和操作，否则会引起 <code>ANR</code> 。</li></ol><blockquote><p>也就是，service 里面不可以进行耗时的操作。虽然在后台服务。但是也是在主线程里面。</p></blockquote><h4 id="4-3-2-当我们编写的耗时逻辑，不得不被-service-来管理的时候，就需要引入-IntentService-。"><a href="#4-3-2-当我们编写的耗时逻辑，不得不被-service-来管理的时候，就需要引入-IntentService-。" class="headerlink" title="4.3.2 当我们编写的耗时逻辑，不得不被 service 来管理的时候，就需要引入 IntentService 。"></a>4.3.2 当我们编写的耗时逻辑，不得不被 <code>service</code> 来管理的时候，就需要引入 <code>IntentService</code> 。</h4><p><img src="https://img-blog.csdnimg.cn/2019103019465514.png" srcset="/img/loading.gif" alt="耗时逻辑"></p><ol><li><code>IntentService</code> 是继承 <code>Service</code> 的，那么它包含了 <code>Service</code> 的全部特性，当然也包含 <code>service</code> 的生命周期。</li><li>那么与 <code>service</code> 不同的是，<code>IntentService</code> 在执行 <code>onCreate</code> 操作的时候，内部开了一个线程，去你执行你的耗时操作。</li></ol><h4 id="4-3-3-使用："><a href="#4-3-3-使用：" class="headerlink" title="4.3.3 使用："></a>4.3.3 使用：</h4><p><img src="https://img-blog.csdnimg.cn/2019103019475844.png" srcset="/img/loading.gif" alt="使用"></p><ol><li>重写 <code>protected abstract void onHandleIntent(Intent intent)</code></li></ol><h4 id="4-3-4-IntentService-是一个通过-Context-startService-Intent-启动可以处理异步请求的-Service"><a href="#4-3-4-IntentService-是一个通过-Context-startService-Intent-启动可以处理异步请求的-Service" class="headerlink" title="4.3.4 IntentService 是一个通过 Context.startService(Intent) 启动可以处理异步请求的 Service"></a>4.3.4 <code>IntentService</code> 是一个通过 <code>Context.startService(Intent)</code> 启动可以处理异步请求的 <code>Service</code></h4><p><img src="https://img-blog.csdnimg.cn/2019103019485231.png" srcset="/img/loading.gif" alt="通过 Context.startService(Intent) 启动"></p><ol><li>使用时你只需要继承 <code>IntentService</code> 和重写其中的 <code>onHandleIntent(Intent)</code> 方法接收一个 <code>Intent</code> 对象 , 在适当的时候会停止自己 ( 一般在工作完成的时候 ) 。</li><li>所有的请求的处理都在一个工作线程中完成 , 它们会交替执行 ( 但不会阻塞主线程的执行 ) ，一次只能执行一个请求。</li></ol><h4 id="4-3-5-是一个基于消息的服务"><a href="#4-3-5-是一个基于消息的服务" class="headerlink" title="4.3.5 是一个基于消息的服务"></a>4.3.5 是一个基于消息的服务</h4><p><img src="https://img-blog.csdnimg.cn/20191030194948622.png" srcset="/img/loading.gif" alt="是一个基于消息的服务"></p><ol><li>每次启动该服务并不是马上处理你的工作，而是首先会创建对应的 <code>Looper</code> ，<code>Handler</code> 并且在 <code>MessageQueue</code> 中添加的附带客户 <code>Intent</code> 的 <code>Message</code> 对象。</li><li>当 <code>Looper</code> 发现有 <code>Message</code> 的时候接着得到 <code>Intent</code> 对象通过在 <code>onHandleIntent((Intent)msg.obj)</code> 中调用你的处理程序，处理完后即会停止自己的服务。</li><li>意思是 <code>Intent</code> 的生命周期跟你的处理的任务是一致的，所以这个类用下载任务中非常好，下载任务结束后服务自身就会结束退出。</li></ol><h4 id="4-3-6-总结-IntentService-的特征有："><a href="#4-3-6-总结-IntentService-的特征有：" class="headerlink" title="4.3.6 总结 IntentService 的特征有："></a>4.3.6 总结 <code>IntentService</code> 的特征有：</h4><p><img src="https://img-blog.csdnimg.cn/20191030195043218.png" srcset="/img/loading.gif" alt="总结 IntentService 的特征"></p><ol><li><p>会创建独立的 <code>worker</code> 线程来处理所有的 <code>Intent</code> 请求；</p></li><li><p>会创建独立的 <code>worker</code> 线程来处理 <code>onHandleIntent()</code> 方法实现的代码，无需处理多线程问题；</p></li><li><p>所有请求处理完成后，<code>IntentService</code>会自动停止，无需调用 <code>stopSelf()</code> 方法停止 <code>Service</code> ；</p></li></ol><h1 id="第五篇：Service-与-Activity"><a href="#第五篇：Service-与-Activity" class="headerlink" title="第五篇：Service 与 Activity"></a>第五篇：Service 与 Activity</h1><hr><p><img src="https://img-blog.csdnimg.cn/20191030212039452.png" srcset="/img/loading.gif" alt="Service 与 Activity"></p><h2 id="5-1-Activity-怎么和-Service-绑定，怎么在-Activity-中启动对应的-Service"><a href="#5-1-Activity-怎么和-Service-绑定，怎么在-Activity-中启动对应的-Service" class="headerlink" title="5.1 Activity 怎么和 Service 绑定，怎么在 Activity 中启动对应的 Service"></a>5.1 Activity 怎么和 Service 绑定，怎么在 Activity 中启动对应的 Service</h2><p><img src="https://img-blog.csdnimg.cn/20191030195513989.png" srcset="/img/loading.gif" alt="Service 与 Activity"></p><ul><li><p><code>Activity</code> 通过 <code>bindService(Intent service, ServiceConnection conn, int flags)</code> 跟 <code>Service</code> 进行绑定，当绑定成功的时候 <code>Service</code> 会将代理对象通过回调的形式传给 <code>conn</code> ，这样我们就拿到了 <code>Service</code> 提供的服务代理对象。</p></li><li><p>在 <code>Activity</code> 中可以通过 <code>startService</code> 和 <code>bindService</code> 方法启动 <code>Service</code>。一般情况下如果想获取 <code>Service</code> 的服务对象那么肯定需要通过  <code>bindService()</code> 方法，比如音乐播放器，第三方支付等。</p></li><li><p>如果仅仅只是为了开启一个后台任务那么可以使用 <code>startService()</code> 方法。</p></li></ul><h2 id="5-2-说说-Activity-、Intent-、Service-是什么关系"><a href="#5-2-说说-Activity-、Intent-、Service-是什么关系" class="headerlink" title="5.2 说说 Activity 、Intent 、Service 是什么关系"></a>5.2 说说 Activity 、Intent 、Service 是什么关系</h2><p><img src="https://img-blog.csdnimg.cn/20191030195652939.png" srcset="/img/loading.gif" alt="Activity 、Intent 、Service 是什么关系"></p><ul><li><p>他们都是 <code>Android</code> 开发中使用频率最高的类。其中 <code>Activity</code> 和 <code>Service</code> 都属于 <code>Android</code> 的四大组件。他俩都是 <code>Context</code> 类的子类 <code>ContextWrapper</code> 的子类，因此他俩可以算是兄弟关系吧。</p></li><li><p>不过他们各有各自的本领，<code>Activity</code> 负责用户界面的显示和交互，<code>Service</code> 负责后台任务的处理。</p></li><li><p><code>Activity</code> 和 <code>Service</code> 之间可以通过 <code>Intent</code> 传递数据，因此可以把 <code>Intent</code> 看作是通信使者。</p></li></ul><h2 id="5-3-Service-和-Activity-在同一个线程吗"><a href="#5-3-Service-和-Activity-在同一个线程吗" class="headerlink" title="5.3 Service 和 Activity 在同一个线程吗"></a>5.3 Service 和 Activity 在同一个线程吗</h2><p><img src="https://img-blog.csdnimg.cn/20191030195755891.png" srcset="/img/loading.gif" alt="Service 和 Activity 在同一个线程吗"></p><p>对于同一 <code>app</code> 来说默认情况下是在同一个线程中的，<code>main Thread</code> （ <code>UI Thread</code> ）。</p><h2 id="5-4-Service-里面可以弹吐司么"><a href="#5-4-Service-里面可以弹吐司么" class="headerlink" title="5.4 Service 里面可以弹吐司么"></a>5.4 Service 里面可以弹吐司么</h2><p><img src="https://img-blog.csdnimg.cn/20191030200308203.png" srcset="/img/loading.gif" alt="Service 里面可以弹吐司么"></p><ul><li>可以</li><li>弹吐司有个条件是：得有一个 <code>Context</code> 上下文，而 <code>Service</code> 本身就是 <code>Context</code> 的子类</li><li>因此在 <code>Service</code> 里面弹吐司是完全可以的。比如我们在 <code>Service</code> 中完成下载任务后可以弹一个吐司通知给用户。</li></ul><h2 id="5-5-与-Service-交互方式"><a href="#5-5-与-Service-交互方式" class="headerlink" title="5.5 与 Service 交互方式"></a>5.5 与 Service 交互方式</h2><p><img src="https://img-blog.csdnimg.cn/20191030200512497.png" srcset="/img/loading.gif" alt="与 Service 交互方式"></p><h4 id="5-5-1-广播交互"><a href="#5-5-1-广播交互" class="headerlink" title="5.5.1 广播交互"></a>5.5.1 广播交互</h4><p><img src="https://img-blog.csdnimg.cn/20191030200558464.png" srcset="/img/loading.gif" alt="广播交互"></p><ol><li><code>Server</code> 端将目前的下载进度，通过广播的方式发送出来，<code>Client</code> 端注册此广播的监听器，当获取到该广播后，将广播中当前的下载进度解析出来并更新到界面上。</li><li>定义自己的广播，这样在不同的 <code>Activity</code> 、<code>Service</code> 以及应用程序之间，就可以通过广播来实现交互。</li></ol><h4 id="5-5-2-共享文件交互"><a href="#5-5-2-共享文件交互" class="headerlink" title="5.5.2 共享文件交互"></a>5.5.2 共享文件交互</h4><p><img src="https://img-blog.csdnimg.cn/20191030200645853.png" srcset="/img/loading.gif" alt="共享文件交互"></p><ol><li>我们使用 <code>SharedPreferences</code> 来实现共享，当然也可以使用其它 <code>IO</code> 方法实现，通过这种方式实现交互时需要注意，对于文件的读写的时候，同一时间只能一方读一方写，不能两方同时写。</li><li><code>Server</code> 端将当前下载进度写入共享文件中，<code>Client</code> 端通过读取共享文件中的下载进度，并更新到主界面上。</li></ol><h4 id="5-5-3-Messenger-交互-信使交互"><a href="#5-5-3-Messenger-交互-信使交互" class="headerlink" title="5.5.3  Messenger 交互 ( 信使交互 )"></a>5.5.3  <code>Messenger</code> 交互 ( 信使交互 )</h4><p><img src="https://img-blog.csdnimg.cn/20191030200811472.png" srcset="/img/loading.gif" alt="Messenger 交互 ( 信使交互 ) "></p><ol><li><code>Messenger</code> 翻译过来指的是信使，它引用了一个 <code>Handler</code> 对象，别人能够向它发送消息 ( 使用 <code>mMessenger.send ( Message msg )</code> 方法)。</li><li>该类允许跨进程间基于 <code>Message</code> 通信，在服务端使用 <code>Handler</code> 创建一个 <code>Messenger</code> ，客户端只要获得这个服务端的 <code>Messenger</code> 对象就可以与服务端通信了</li><li>在 <code>Server</code> 端与 Client 端之间通过一个 <code>Messenger</code> 对象来传递消息，该对象类似于信息中转站，所有信息通过该对象携带</li></ol><h4 id="5-5-4-自定义接口交互"><a href="#5-5-4-自定义接口交互" class="headerlink" title="5.5.4 自定义接口交互"></a>5.5.4 自定义接口交互</h4><p><img src="https://img-blog.csdnimg.cn/20191030200911573.png" srcset="/img/loading.gif" alt="自定义接口交互"></p><ol><li>其实就是我们自己通过接口的实现来达到 <code>Activity</code> 与 <code>Service</code> 交互的目的，我们通过在 <code>Activity</code> 和 <code>Service</code> 之间架设一座桥樑，从而达到数据交互的目的，而这种实现方式和 <code>AIDL</code> 非常类似</li><li>自定义一个接口，该接口中有一个获取当前下载进度的空方法。<code>Server</code> 端用一个类继承自 <code>Binder</code> 并实现该接口，覆写了其中获取当前下载进度的方法。<code>Client</code> 端通过 <code>ServiceConnection</code> 获取到该类的对象，从而能够使用该获取当前下载进度的方法，最终实现实时交互。</li></ol><h4 id="5-5-5-AIDL-交互"><a href="#5-5-5-AIDL-交互" class="headerlink" title="5.5.5 AIDL 交互"></a>5.5.5 <code>AIDL</code> 交互</h4><p><img src="https://img-blog.csdnimg.cn/20191030200953375.png" srcset="/img/loading.gif" alt="AIDL交互"></p><ol><li>远程服务一般通过 <code>AIDL</code> 来实现，可以进行进程间通信，这种服务也就是远程服务。</li><li><code>AIDL</code> 属于 <code>Android</code> 的 <code>IPC</code> 机制，常用于跨进程通信，主要实现原理基于底层 <code>Binder</code> 机制。</li></ol><ul><li><a href="https://www.cnblogs.com/yydcdut/p/3961545.html" target="_blank" rel="noopener">Android 面试，与Service交互方式</a></li></ul><h1 id="第六篇：使用"><a href="#第六篇：使用" class="headerlink" title="第六篇：使用"></a>第六篇：使用</h1><hr><p><img src="https://img-blog.csdnimg.cn/20191030212157207.png" srcset="/img/loading.gif" alt="使用"></p><h2 id="6-1-什么情况下会使用-Service"><a href="#6-1-什么情况下会使用-Service" class="headerlink" title="6.1 什么情况下会使用 Service"></a>6.1 什么情况下会使用 Service</h2><p><img src="https://img-blog.csdnimg.cn/20191030201354809.png" srcset="/img/loading.gif" alt="什么情况下会使用 Service"></p><h4 id="6-1-1-经验总结："><a href="#6-1-1-经验总结：" class="headerlink" title="6.1.1 经验总结："></a>6.1.1 经验总结：</h4><p><img src="https://img-blog.csdnimg.cn/20191030202018516.png" srcset="/img/loading.gif" alt="经验总结"></p><ol><li><code>Service</code> 其实就是背地搞事情，又不想让别人知道</li><li>举一个生活当中的例子，你想知道一件事情不需要直接去问，你可以通过侧面了解。这就是 <code>Service</code> 设计的初衷</li></ol><h4 id="6-1-2-Service-为什么被设计出来"><a href="#6-1-2-Service-为什么被设计出来" class="headerlink" title="6.1.2 Service 为什么被设计出来"></a>6.1.2 <code>Service</code> 为什么被设计出来</h4><p><img src="https://img-blog.csdnimg.cn/2019103020205149.png" srcset="/img/loading.gif" alt="Service 为什么被设计出来"></p><ol start="3"><li>根据 <code>Service</code> 的定义，我们可以知道需要长期在后台进行的工作我们需要将其放在 <code>Service</code> 中去做。</li><li>得再通熟易懂一点，就是不能放在 <code>Activity</code> 中来执行的工作就必须得放到 <code>Service</code> 中去做。</li><li>如：音乐播放、下载、上传大文件、定时关闭应用等功能。这些功能如果放到 <code>Activity</code> 中做的话，那么 <code>Activity</code> 退出被销毁了的话，那这些功能也就停止了，这显然是不符合我们的设计要求的，所以要将他们放在 <code>Service</code> 中去执行。</li></ol><h2 id="6-2-onStartCommand-返回值-int-值的区别"><a href="#6-2-onStartCommand-返回值-int-值的区别" class="headerlink" title="6.2 onStartCommand() 返回值 int 值的区别"></a>6.2 onStartCommand() 返回值 int 值的区别</h2><ul><li>有四种返回值,不同值代表的意思如下:</li></ul><p><img src="https://img-blog.csdnimg.cn/20191030202417876.png" srcset="/img/loading.gif" alt="onStartCommand() 返回值 int 值的区别"></p><h4 id="6-2-1-START-STICKY"><a href="#6-2-1-START-STICKY" class="headerlink" title="6.2.1 START_STICKY :"></a>6.2.1 <code>START_STICKY</code> :</h4><ol><li>如果 <code>service</code> 进程被 kill 掉,保留 <code>service</code> 的状态为开始状态,但不保留递送的 <code>intent</code> 对象。</li><li>随后系统会尝试重新创建 <code>service</code>, 由于服务状态为开始状态,所以创建服务后一定会调用 <code>onStartCommand ( Intent, int, int )</code> 方法。</li><li>如果在此期间没有任何启动命令被传递到 <code>service</code> , 那么参数  <code>Intent</code> 将为 <code>null</code> 。</li></ol><h4 id="6-2-2-START-NOT-STICKY"><a href="#6-2-2-START-NOT-STICKY" class="headerlink" title="6.2.2 START_NOT_STICKY :"></a>6.2.2 <code>START_NOT_STICKY</code> :</h4><ol><li>“非粘性的”。</li><li>使用这个返回值时 , 如果在执行完 <code>onStartCommand</code> 后 , 服务被异常 <code>kill</code> 掉 ，系统不会自动重启该服务。</li></ol><h4 id="6-2-3-START-REDELIVER-INTENT"><a href="#6-2-3-START-REDELIVER-INTENT" class="headerlink" title="6.2.3 START_REDELIVER_INTENT:"></a>6.2.3 <code>START_REDELIVER_INTENT</code>:</h4><ol><li>重传 <code>Intent</code> 。</li><li>使用这个返回值时,如果在执行完 <code>onStartCommand</code> 后,服务被异常 kill 掉 </li><li>系统会自动重启该服务 , 并将 Intent 的值传入。</li></ol><h4 id="6-2-4-START-STICKY-COMPATIBILITY"><a href="#6-2-4-START-STICKY-COMPATIBILITY" class="headerlink" title="6.2.4 START_STICKY_COMPATIBILITY:"></a>6.2.4 <code>START_STICKY_COMPATIBILITY</code>:</h4><ol><li><code>START_STICKY</code> 的兼容版本 , 但不保证服务被 <code>kill</code> 后一定能重启。</li></ol><h2 id="6-3-在-service-的生命周期方法-onstartConmand-可不可以执行网络操作？如何在-service-中执行网络操作？"><a href="#6-3-在-service-的生命周期方法-onstartConmand-可不可以执行网络操作？如何在-service-中执行网络操作？" class="headerlink" title="6.3 在 service 的生命周期方法 onstartConmand() 可不可以执行网络操作？如何在 service 中执行网络操作？"></a>6.3 在 service 的生命周期方法 onstartConmand() 可不可以执行网络操作？如何在 service 中执行网络操作？</h2><p><img src="https://img-blog.csdnimg.cn/2019103020263992.png" srcset="/img/loading.gif" alt="onstartConmand() 可不可以执行网络操作？如何在 service 中执行网络操作？"></p><ul><li>可以直接在 <code>Service</code> 中执行网络操作 </li><li>在 <code>onStartCommand()</code> 方法中可以执行网络操作</li></ul><h2 id="6-4-提高-service-的优先级"><a href="#6-4-提高-service-的优先级" class="headerlink" title="6.4 提高 service 的优先级"></a>6.4 提高 service 的优先级</h2><p><img src="https://img-blog.csdnimg.cn/20191030203447453.png" srcset="/img/loading.gif" alt="提高 service 的优先级"></p><ul><li><p>在 <code>AndroidManifest.xml</code> 文件中对于 <code>intent-filter</code> 可以通过 <code>android:priority = “1000”</code> 这个属性设置最高优先级，<code>1000</code> 是最高值，如果数字越小则优先级越低，同时实用于广播。</p></li><li><p>在 <code>onStartCommand</code> 里面调用 <code>startForeground()</code> 方法把 <code>Service</code> 提升为前台进程级别，然后再 <code>onDestroy</code> 里面要记得调用 <code>stopForeground ()</code> 方法。</p></li><li><p><code>onStartCommand</code> 方法，手动返回 <code>START_STICKY</code> 。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20191030203558262.png" srcset="/img/loading.gif" alt="广播"></p><ul><li>在 <code>onDestroy</code> 方法里发广播重启 <code>service</code> 。</li></ul><ol><li><code>service</code> + <code>broadcast</code> 方式，就是当 <code>service</code> 走 <code>ondestory</code> 的时候，发送一个自定义的广播</li><li>当收到广播的时候，重新启动 <code>service</code> 。（ 第三方应用或是在 <code>setting</code> 里-应用强制停止时，<code>APP</code> 进程就直接被干掉了，<code>onDestroy</code> 方法都进不来，所以无法保证会执行 ）</li></ol><ul><li>监听系统广播判断 <code>Service</code> 状态。</li></ul><ol><li>通过系统的一些广播</li><li>比如：手机重启、界面唤醒、应用状态改变等等监听并捕获到，然后判断我们的 <code>Service</code> 是否还存活。</li></ol><ul><li><code>Application</code> 加上 <code>Persistent</code> 属性。</li></ul><h2 id="6-5-Service-的-onRebind-Intent-方法在什么情况下会执行"><a href="#6-5-Service-的-onRebind-Intent-方法在什么情况下会执行" class="headerlink" title="6.5 Service 的 onRebind ( Intent ) 方法在什么情况下会执行"></a>6.5 Service 的 onRebind ( Intent ) 方法在什么情况下会执行</h2><p><img src="https://img-blog.csdnimg.cn/20191030203656171.png" srcset="/img/loading.gif" alt="onRebind ( Intent ) 方法在什么情况下会执行"></p><ul><li>如果在 <code>onUnbind()</code> 方法返回 <code>true</code> 的情况下会执行 , 否则不执行。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><ol><li>本文基本涵盖了 <code>Android Service</code> 相关的知识点。由于篇幅原因，诸如 InterService 具体使用方法等，没办法详细的介绍，大家很容易就能在网上找到资料进行学习。</li><li><strong><code>重点</code></strong>：关于 <code>Android</code> 的四大组件，到现在为止我才总结完 <code>Activity</code> 和 <code>Service</code>，我将继续针对，<code>BroadcastRecevier</code> <code>ContentProvider</code> 等，以及四大组件之外的，事件分发、滑动冲突、新能优化等重要模块，进行全面总结，欢迎大家关注 <a href="https://blog.csdn.net/qq_43377749" target="_blank" rel="noopener">_yuanhao 的 CSDN</a> ，方便及时接收更新</li><li>开始前还以为总结不难，实际写文章的过程中，才知道什么是艰辛。也不知道自己能不能咬牙坚持下去，希望大家给我鼓励，就算只是一个赞，也是我坚持下去的理由！</li></ol><h1 id="码字不易，你的点赞是我总结的最大动力！"><a href="#码字不易，你的点赞是我总结的最大动力！" class="headerlink" title="码字不易，你的点赞是我总结的最大动力！"></a>码字不易，你的点赞是我总结的最大动力！</h1><hr><ul><li><p>由于我在「稀土掘金」「简书」「<code>CSDN</code>」「博客园」等站点，都有新内容发布。所以大家可以直接关注我的 <code>GitHub</code> 仓库，以免错过精彩内容！</p></li><li><p>仓库地址：<br><a href="https://github.com/FishInWater-1999/android_interviews" target="_blank" rel="noopener">超级干货！精心归纳 <code>Android</code> 、<code>JVM</code> 、算法等，各位帅气的老铁支持一下！给个 Star ！</a></p></li><li><p><code>1W</code> 多字长文，加上精美思维导图，记得<strong>点赞</strong>哦，欢迎关注 <strong><a href="https://blog.csdn.net/qq_43377749" target="_blank" rel="noopener">_yuanhao 的 CSDN</a></strong> </p></li><li><p>相关文章均可在我的主页、GitHub 上看到，这里限于篇幅原因，也为了保持界面整洁，让大家能有跟舒心的阅读体验就不给出了，我们下篇文章不见不散！<br><img src="https://img-blog.csdnimg.cn/20191029235448320.jpeg" srcset="/img/loading.gif" alt="Android"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Service</tag>
      
      <tag>四大组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>“面试必备：高频算法题终章「图文解析 + 范例代码」之 矩阵 二进制 + 位运算 + LRU 合集！”</title>
    <link href="undefined2019/10/26/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%9F%A9%E9%98%B5+%E4%BA%8C%E8%BF%9B%E5%88%B6+%E4%BD%8D%E8%BF%90%E7%AE%97+LRU%E5%90%88%E9%9B%86/"/>
    <url>2019/10/26/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%9F%A9%E9%98%B5+%E4%BA%8C%E8%BF%9B%E5%88%B6+%E4%BD%8D%E8%BF%90%E7%AE%97+LRU%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20191019105602815.png" srcset="/img/loading.gif" alt="面试"></p><h1 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h1><p>秋招接近尾声，我总结了 <code>牛客</code>、<code>WanAndroid</code> 上，有关笔试面经的帖子中出现的算法题，结合往年考题写了这一系列文章，所有文章均与 LeetCode 进行核对、测试。欢迎食用</p><hr><p><strong>本文将覆盖 「二进制」 + 「位运算」 和 Lru 方面的面试算法题，文中我将给出：</strong></p><ol><li>面试中的题目</li><li>解题的思路</li><li>特定问题的技巧和注意事项</li><li>考察的知识点及其概念</li><li>详细的代码和<code>解析</code></li></ol><h4 id="开始之前，我们先看下会有哪些重点案例："><a href="#开始之前，我们先看下会有哪些重点案例：" class="headerlink" title="开始之前，我们先看下会有哪些重点案例："></a>开始之前，我们先看下会有哪些重点案例：</h4><p><img src="https://img-blog.csdnimg.cn/20191021201644400.png" srcset="/img/loading.gif" alt="图片"></p><h1 id="为了方便大家跟进学习，我在-GitHub-建立了一个仓库"><a href="#为了方便大家跟进学习，我在-GitHub-建立了一个仓库" class="headerlink" title="为了方便大家跟进学习，我在 GitHub 建立了一个仓库"></a>为了方便大家跟进学习，我在 <code>GitHub</code> 建立了一个仓库</h1><p>仓库地址：<strong><a href="https://github.com/FishInWater-1999/android_interviews/tree/master/%E7%AE%97%E6%B3%95/%E8%B6%85%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">超级干货！精心归纳<code>视频、归类、总结</code>，各位路过的老铁支持一下！给个 Star ！</a></strong><br><br></p><p>现在就让我们开始吧！</p><br><hr><p><img src="https://img-blog.csdnimg.cn/20191024000511171.png" srcset="/img/loading.gif" alt="devider"></p><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><hr><p><img src="https://img-blog.csdnimg.cn/20191021201809145.png" srcset="/img/loading.gif" alt="矩阵"></p><br><br><p><img src="https://img-blog.csdnimg.cn/20191024000511171.png" srcset="/img/loading.gif" alt="devider"></p><h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><hr><p>给定一个包含 <code>m x n</code> 个要素的矩阵，（<code>m</code> 行, <code>n</code> 列），按照螺旋顺序，返回该矩阵中的所有要素。</p><p>示例 :</p><pre><code class="css">输入:[  [1, 2, 3, 4],  [5, 6, 7, 8],  [9,10,11,12]]输出: [1,2,3,4,8,12,11,10,9,5,6,7]</code></pre><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>我们定义矩阵的第 k 层是到最近边界距离为 k 的所有顶点。例如，下图矩阵最外层元素都是<code>第 1 层</code>，次外层元素都是<code>第 2 层</code>，然后是<code>第 3 层</code>的。</p><pre><code class="css">[[1, 1, 1, 1, 1, 1, 1], [1, 2, 2, 2, 2, 2, 1], [1, 2, 3, 3, 3, 2, 1], [1, 2, 2, 2, 2, 2, 1], [1, 1, 1, 1, 1, 1, 1]]</code></pre><p>对于每层，我们从左上方开始以顺时针的顺序遍历所有元素，假设当前层左上角坐标是 $\text{(r1, c1)}$，右下角坐标是 $\text{(r2, c2)}$。</p><p>首先，遍历上方的所有元素 <code>(r1, c)</code>，按照 <code>c = c1,...,c2</code>  的顺序。然后遍历右侧的所有元素 <code>(r, c2)</code>，按照 <code>r = r1+1,...,r2</code> 的顺序。如果这一层有四条边（也就是 <code>r1 &lt; r2</code> 并且 <code>c1 &lt; c2</code> ），我们以下图所示的方式遍历下方的元素和左侧的元素。</p><p><img src="https://img-blog.csdnimg.cn/20191021150901496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzc3NzQ5,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="螺旋矩阵"></p><pre><code class="java">public List &lt; Integer &gt; spiralOrder(int[][] matrix) {    List ans = newArrayList();    if (matrix.length == 0)        return ans;    int r1 = 0, r2 = matrix.length - 1;    int c1 = 0, c2 = matrix[0].length - 1;    while (r1 &lt;= r2 &amp;&amp; c1 &lt;= c2) {        for (int c = c1; c &lt;= c2; c++) ans.add(matrix[r1][c]);        for (int r = r1 + 1; r &lt;= r2; r++) ans.add(matrix[r][c2]);        if (r1 &lt; r2 &amp;&amp; c1 &lt; c2) {            for (int c = c2 - 1; c &gt; c1; c--) ans.add(matrix[r2][c]);            for (int r = r2; r &gt; r1; r--) ans.add(matrix[r][c1]);        }        r1++;        r2--;        c1++;        c2--;    }    return ans;}</code></pre><br><br><p><img src="https://img-blog.csdnimg.cn/20191024000511171.png" srcset="/img/loading.gif" alt="devider"></p><h2 id="判断数独是否合法"><a href="#判断数独是否合法" class="headerlink" title="判断数独是否合法"></a>判断数独是否合法</h2><hr><p>请判定一个<code>数独</code>是否有效。该数独可能只填充了部分数字，其中缺少的数字用 . 表示。</p><p>维护一个<code>HashSet</code>用来记同一<code>行</code>、同一<code>列</code>、同一<code>九宫格</code>是否存在相同数字</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQud2lraW1lZGlhLm9yZy93aWtpcGVkaWEvY29tbW9ucy90aHVtYi9mL2ZmL1N1ZG9rdS1ieS1MMkctMjAwNTA3MTQuc3ZnLzI1MHB4LVN1ZG9rdS1ieS1MMkctMjAwNTA3MTQuc3ZnLnBuZw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="判断数独是否合法"></p><p>示例 :</p><pre><code class="css">输入:[  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</code></pre><p>说明:</p><p>一个有效的数独（部分已被填充）<code>不一定</code>是可解的。<br>只需要根据以上规则，验证已经填入的数字是否<code>有效即可</code>。<br>给定数独序列只包含数字 <code>1-9</code> 和字符 <code>&#39;.&#39;</code> 。<br>给定数独永远是 <code>9x9</code> 形式的。`</p><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>一次迭代<br>首先，让我们来讨论下面两个问题：</p><p>如何枚举子数独？<br>可以使用 <code>box_index = (row / 3) * 3 + columns / 3</code>，其中 / 是整数除法。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tLzJiMTQxMzkyZTJhMTgxMWQwZThkZmRmNjI3OWIxMzUyZTU5ZmFkMGIzOTYxOTA4YzZmZjk0MTJiNmE3ZTdjY2YtaW1hZ2UucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="一次迭代"></p><p>如何确保行 / 列 / 子数独中没有重复项？<br>可以利用 <code>value -&gt; count</code> 哈希映射来跟踪所有已经遇到的值。</p><p>现在，我们完成了这个算法的所有准备工作：</p><p>遍历数独。<br>检查看到每个单元格值是否已经在当前的行 / 列 / 子数独中出现过：<br>如果出现重复，返回 <code>false</code>。<br>如果没有，则保留此值以进行进一步跟踪。<br>返回 <code>true</code>。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMzYvMzZfc2xpZGVfMi5wbmc?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="确保行 / 列 / 子数独中没有重复项"></p><pre><code class="java">public boolean isValidSudoku(char[][] board) {    Set seen = new HashSet();    for (int i=0; i&lt;9; ++i) {        for (int j=0; j&lt;9; ++j) {            char number = board[i][j];            if (number != &#39;.&#39;)                if (!seen.add(number + &quot; in row &quot; + i) ||                    !seen.add(number + &quot; in column &quot; + j) ||                    !seen.add(number + &quot; in block &quot; + i / 3 + &quot;-&quot; + j / 3))                    return false;        }    }    return true;}</code></pre><br><br><p><img src="https://img-blog.csdnimg.cn/20191024000511171.png" srcset="/img/loading.gif" alt="devider"></p><h2 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h2><hr><p>给定一个<code>N×N</code>的二维矩阵表示图像，<code>90度</code>顺时针旋转图像。</p><p>示例 :</p><pre><code class="css">输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</code></pre><p>说明:</p><pre><code class="css">1 &lt;= A.length = A[0].length &lt;= 200 &lt;= A[i][j] &lt;= 1</code></pre><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>我们先来看看每个元素在旋转的过程中是如何移动的：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tLzEyNjA1ZWZiNjBkMmVmYzY0ZTZlY2ZjZjY1NjJhOThhNDlhY2IzY2U2OTZiMGMxYWQzZGE0NmFiODk3N2ZhMTYtNDhfYW5nbGVzLnBuZw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="如何移动"></p><p>这提供给我们了一个思路，将给定的矩阵分成四个矩形并且将原问题划归为<code>旋转这些矩形</code>的问题。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tLzdhNjg0YjIwN2E5NTE4OGZmNjQ1MGU0NzI0ZDZlZThiZGY0MjVmYzQ4Mzc3NWE4ZTMwMDgyZWQyNTA2MGRhYzEtNDhfcmVjdGFuZ2xlcy5wbmc?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="旋转这些矩形"></p><p>现在的解法很直接 – 可以在第一个矩形中移动元素并且在 长度为 4 个元素的临时列表中<code>移动</code>它们。</p><p><img src="https://img-blog.csdnimg.cn/20191021173207924.gif" srcset="/img/loading.gif" alt="变化过程"></p><pre><code class="java">public void rotate(int[][] matrix) {    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {        return;    }    int length = matrix.length;    for (int i = 0; i &lt; length / 2; i++) {        for (int j = 0; j &lt; (length + 1) / 2; j++){            int tmp = matrix[i][j];            matrix[i][j] = matrix[length - j - 1][i];            matrix[length -j - 1][i] = matrix[length - i - 1][length - j - 1];            matrix[length - i - 1][length - j - 1] = matrix[j][length - i - 1];            matrix[j][length - i - 1] = tmp;        }    }   }</code></pre><br><br><p><img src="https://img-blog.csdnimg.cn/20191024000511171.png" srcset="/img/loading.gif" alt="devider"></p><h1 id="二进制-位运算"><a href="#二进制-位运算" class="headerlink" title="二进制 / 位运算"></a>二进制 / 位运算</h1><hr><p><img src="https://img-blog.csdnimg.cn/20191021201855750.png" srcset="/img/loading.gif" alt="二进制位运算"></p><pre><code class="css">优点：特定情况下，计算方便，速度快，被支持面广如果用算数方法，速度慢，逻辑复杂位运算不限于一种语言，它是计算机的基本运算方法</code></pre><br><h2 id="知识点预热"><a href="#知识点预热" class="headerlink" title="知识点预热"></a>知识点预热</h2><hr><p><img src="https://img-blog.csdnimg.cn/20191021202057416.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20191024000511171.png" srcset="/img/loading.gif" alt="devider"></p><h2 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h2><hr><p>给出 <code>2 * n + 1</code>个数字，除其中一个数字之外其他每个数字均出现两次，找到这个数字。</p><p>异或运算具有很好的性质，相同数字异或运算后为0，并且具有交换律和结合律，故将所有数字异或运算后即可得到只出现一次的数字。</p><p>示例 :</p><pre><code class="css">输入: [4,1,2,1,2]输出: 4</code></pre><br><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>如果我们对 0 和二进制位做 XOR 运算，得到的仍然是这个二进制位</p><p>$a \oplus 0 = a$ $a⊕0=a$</p><p>如果我们对相同的二进制位做 XOR 运算，返回的结果是 0</p><p>$a \oplus a = 0$ $a⊕a=0$</p><p>XOR 满足交换律和结合律</p><p>$a \oplus b \oplus a = (a \oplus a) \oplus b = 0 \oplus b = ba⊕b⊕a=(a⊕a)⊕b=0⊕b=b$</p><p>所以我们只需要将<code>所有</code>的数进行 XOR 操作，得到那个唯一的数字。</p><br><pre><code class="java">public int singleNumber(int[] A) {    if(A == null || A.length == 0) {        return -1;    }    int rst = 0;    for (int i = 0; i &lt; A.length; i++) {        rst ^= A[i];    }    return rst;}</code></pre><br><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度： <code>O(n)</code> 。我们只需要将 $\text{nums}$ 中的元素遍历一遍，所以时间复杂度就是 $\text{nums}$ 中的元素个数。<br>空间复杂度：<code>O(1)</code> 。</p><p><img src="https://img-blog.csdnimg.cn/20191024000511171.png" srcset="/img/loading.gif" alt="devider"></p><h2 id="格雷编码"><a href="#格雷编码" class="headerlink" title="格雷编码"></a>格雷编码</h2><p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个二进制的差异。给定一个<code>非负整数 n</code> ，表示该代码中所有二进制的总数，请找出其格雷编码顺序。一个格雷编码顺序必须以 <code>0</code> 开始，并覆盖所有的 <code>2n</code> 个整数。例子——输入：<code>2</code>；输出：[0, 1, 3, 2]；解释: <code>0 - 00</code>，<code>1 - 01</code>，<code>3 - 11</code>，<code>2 - 10</code></p><br><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>格雷码生成公式：<code>G(i) = i ^ (i &gt;&gt; 2)</code></p><pre><code class="css">public ArrayList&lt;Integer&gt; grayCode(int n) {    ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();    for (int i = 0; i &lt; (1 &lt;&lt; n); i++) {        result.add(i ^ (i &gt;&gt; 1));    }    return result;}</code></pre><br><br><p><img src="https://img-blog.csdnimg.cn/20191024000511171.png" srcset="/img/loading.gif" alt="devider"></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><hr><p><img src="https://img-blog.csdnimg.cn/20191021201916673.png" srcset="/img/loading.gif" alt="其他"></p><br><br><p><img src="https://img-blog.csdnimg.cn/20191024000511171.png" srcset="/img/loading.gif" alt="devider"></p><h2 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h2><hr><p>将一个整数中的数字进行<code>颠倒</code>，当颠倒后的整数<code>溢出时</code>，返回 0 (标记为 32 位整数)。</p><p> 示例 :</p><pre><code class="css">输入: -123输出: -321</code></pre><br><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>利用<code>除 10 取余</code>的方法，将最低位和最高<code>倒序输出</code>即可</p><pre><code class="java">public int reverseInteger(int n) {    int reversed_n = 0;    while (n != 0) {        int temp = reversed_n * 10 + n % 10;        n = n / 10;        if (temp / 10 != reversed_n) {            reversed_n = 0;            break;        }        reversed_n = temp;    }    return reversed_n;}</code></pre><br><br><p><img src="https://img-blog.csdnimg.cn/20191024000511171.png" srcset="/img/loading.gif" alt="devider"></p><h2 id="LRU缓存策略"><a href="#LRU缓存策略" class="headerlink" title="LRU缓存策略"></a>LRU缓存策略</h2><hr><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>获取数据 <code>get(key)</code> - 如果密钥 <code>(key) 存在</code>于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 <code>put(key, value)</code> - 如果密钥<code>不存在</code>，则<code>写入</code>其数据值。当缓存容量达到上限时，它应该在写入新数据之前<code>删除</code>最近最少使用的数据值，从而为新的数据值留出空间。</p><p>示例:</p><pre><code class="css">LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );cache.put(1, 1);cache.put(2, 2);cache.get(1);       // 返回  1cache.put(3, 3);    // 该操作会使得密钥 2 作废cache.get(2);       // 返回 -1 (未找到)cache.put(4, 4);    // 该操作会使得密钥 1 作废cache.get(1);       // 返回 -1 (未找到)cache.get(3);       // 返回  3cache.get(4);       // 返回  4</code></pre><br><h4 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h4><p><strong>解法一：</strong></p><p>自定义数据结构：</p><ul><li>实现一个链表用于记录缓存，并处理调用使用频率</li><li>定义一个 <code>HashMap</code> 用于记录缓存内容</li></ul><pre><code class="java">public class LRUCache {    private class Node{        Node prev;        Node next;        int key;        int value;        public Node(int key, int value) {            this.key = key;            this.value = value;            this.prev = null;            this.next = null;        }    }    private int capacity;    private HashMap&lt;Integer, Node&gt; hs = new HashMap&lt;Integer, Node&gt;();    private Node head = new Node(-1, -1);// 头    private Node tail = new Node(-1, -1);// 尾    public LRUCache(int capacity) {        this.capacity = capacity;        tail.prev = head;        head.next = tail;    }    public int get(int key) {        if( !hs.containsKey(key)) {            //key找不到            return -1;        }        // remove current        Node current = hs.get(key);        current.prev.next = current.next;        current.next.prev = current.prev;        // move current to tail        move_to_tail(current);            //每次get，使用次数+1，最近使用，放于尾部        return hs.get(key).value;    }    public void set(int key, int value) {            //数据放入缓存        // get 这个方法会把key挪到最末端，因此，不需要再调用 move_to_tail        if (get(key) != -1) {            hs.get(key).value = value;            return;        }        if (hs.size() == capacity) {        //超出缓存上限            hs.remove(head.next.key);        //删除头部数据            head.next = head.next.next;            head.next.prev = head;        }        Node insert = new Node(key, value);        //新建节点        hs.put(key, insert);        move_to_tail(insert);                    //放于尾部    }    private void move_to_tail(Node current) {    //移动数据至尾部        current.prev = tail.prev;        tail.prev = current;        current.prev.next = current;        current.next = tail;    }}</code></pre><br><p><strong>解法二：</strong></p><p>题目要求实现 <code>LRU</code> 缓存机制，需要在 <code>O(1)</code>时间内完成如下操作：</p><ul><li>获取键 / 检查键是否存在</li><li>设置键</li><li>删除最先插入的键</li><li>前两个操作可以用标准的哈希表在 <code>O(1)</code> 时间内完成。</li></ul><p>有一种叫做<code>有序字典</code>的数据结构，综合了<code>哈希表</code>和<code>链表</code>，在 Java 中为 <code>LinkedHashMap</code>。</p><p>下面用这个数据结构来实现。</p><br><pre><code class="java">class LRUCache extends LinkedHashMap&lt;Integer, Integer&gt;{    private int capacity;    public LRUCache(int capacity) {        super(capacity, 0.75F, true);        this.capacity = capacity;    }    public int get(int key) {        return super.getOrDefault(key, -1);    }    public void put(int key, int value) {        super.put(key, value);    }    @Override    protected boolean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt; eldest) {        return size() &gt; capacity;     }}</code></pre><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：对于 put 和 get 操作复杂度是 $O(1)$，因为有序字典中的所有操作：</li><li><code>get/in/set/move_to_end/popitem（get/containsKey/put/remove）</code>都可以在常数时间内完成。<br>空间复杂度：$O(capacity)$，因为空间只用于有序字典存储最多 capacity + 1 个元素。</li></ul><br><br>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二进制</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缩放手势 ScaleGestureDetector  源码解析，这一篇就够了</title>
    <link href="undefined2019/10/11/%E7%BC%A9%E6%94%BE%E6%89%8B%E5%8A%BF%20ScaleGestureDetector%20%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%8C%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <url>2019/10/11/%E7%BC%A9%E6%94%BE%E6%89%8B%E5%8A%BF%20ScaleGestureDetector%20%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%8C%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<p>其实在我们日常的编程中，对于缩放手势的使用并不是很经常，这一手势主要是用在图片浏览方面，比如下方例子。但是（敲重点），作为 Android 入门的基础来说，学习 ScaleGestureDetector 的使用，算是不得不过的一道坎，好在 ScaleGestureDetector 使用起来非常简单，就是源码分析上得花些功夫。</p><blockquote><p>本文首先将简单的介绍下 ScaleGestureDetector 的使用，在重点给大家分析下源码（由于源码方面是我自己的理解，可能有偏差，希望各位大佬能在评论区指出，万分感谢～）</p></blockquote><img src="https://user-gold-cdn.xitu.io/2019/6/27/16b996688722ec94?w=1280&h=904&f=jpeg&s=235091" srcset="/img/loading.gif" width="500" height="300" align="center"><hr><h1 id="ScaleGestureDetector-使用"><a href="#ScaleGestureDetector-使用" class="headerlink" title="ScaleGestureDetector 使用"></a>ScaleGestureDetector 使用</h1><p>ScaleGestureDetector 包括一个监听器，以及它所有方法的空实现：</p><table><thead><tr><th>名称</th><th>用途</th></tr></thead><tbody><tr><td>ScaleGestureDetector</td><td>缩放手势的监听器</td></tr><tr><td>SimpleOnScaleGestureListener</td><td>该监听器的空实现，在其中重写方法</td></tr></tbody></table><h3 id="ScaleGestureDetector-方法"><a href="#ScaleGestureDetector-方法" class="headerlink" title="ScaleGestureDetector 方法"></a>ScaleGestureDetector 方法</h3><table><thead><tr><th>名称</th><th>用途</th></tr></thead><tbody><tr><td>onScaleBegin</td><td>当 &gt;= 2 个手指碰触屏幕时调用，若返回 false 则忽略改事件调用</td></tr><tr><td>onScale</td><td>滑动（缩放）过程中调用，若成功处理，则用户返回 true，监听器继续记录下一个缩放等动作，若为 false 表明数据未处理，则监听器继续积累</td></tr><tr><td>onScaleEnd</td><td>全部手指离开屏幕，结束监听</td></tr></tbody></table><p>通常情况下，手势监听会结合自定义 View 来讲，这里我给出一个最简单的使用，具体的使用实例，以后再结合自定义 View 讲讲。</p><pre><code class="java">    private void iniScaleGestureListener(){        mListener = new ScaleGestureDetector.SimpleOnScaleGestureListener(){            @Override            public boolean onScaleBegin(ScaleGestureDetector detector) {                return super.onScaleBegin(detector);            }            @Override            public boolean onScale(ScaleGestureDetector detector) {                MyLog.d(&quot;X:&quot; + detector.getFocusX());                MyLog.d(&quot;Y:&quot; + detector.getFocusY());                MyLog.d(&quot;scale:&quot; + detector.getScaleFactor());                return super.onScale(detector);            }            @Override            public void onScaleEnd(ScaleGestureDetector detector) {                super.onScaleEnd(detector);            }        };        detector = new ScaleGestureDetector(getContext(), mListener);    }    @Override    public boolean onTouchEvent(MotionEvent event) {        detector.onTouchEvent(event);        return true;    }</code></pre><hr><h1 id="ScaleGestureDetector-的使用"><a href="#ScaleGestureDetector-的使用" class="headerlink" title="ScaleGestureDetector 的使用"></a>ScaleGestureDetector 的使用</h1><p>ScaleGestureDetector 在具体项目的使用有点复杂，我打算过段时间结合自定义 View 写一篇用来总结，所以这篇我们就先了解下 ScaleGestureDetector 的基本使用。</p><hr><h1 id="ScaleGestureDetector-源码分析"><a href="#ScaleGestureDetector-源码分析" class="headerlink" title="ScaleGestureDetector 源码分析"></a>ScaleGestureDetector 源码分析</h1><p>好了，现在我们进入本章重点，ScaleGestureDetector 源码分析，敲黑板敲黑板。首先，我们打开 ScaleGestureDetector 的源码可以看到，几乎所有的代码都集中在了 onTouchEvent 这个方法上，所以在这里，我就主要给大家介绍这个方法的实现。</p><h2 id="第一部分：前期准备"><a href="#第一部分：前期准备" class="headerlink" title="第一部分：前期准备"></a>第一部分：前期准备</h2><pre><code class="java">        if (mInputEventConsistencyVerifier != null) {            mInputEventConsistencyVerifier.onTouchEvent(event, 0);        }        mCurrTime = event.getEventTime();        final int action = event.getActionMasked();        // Forward the event to check for double tap gesture        if (mQuickScaleEnabled) {            mGestureDetector.onTouchEvent(event);        }        final int count = event.getPointerCount();        final boolean isStylusButtonDown =                (event.getButtonState() &amp; MotionEvent.BUTTON_STYLUS_PRIMARY) != 0;</code></pre><h3 id="mInputEventConsistencyVerifier"><a href="#mInputEventConsistencyVerifier" class="headerlink" title="mInputEventConsistencyVerifier"></a>mInputEventConsistencyVerifier</h3><ul><li>输入事件一致性验证器 @有道</li><li>根据名字以及前面的定义</li><li>我们可以猜测这个对象应该是手势监听 Event 是否注册（连接到硬件）</li><li>所以，如果他为空，那么我们在这里调用 onTouchEvent 进行注册</li></ul><pre><code class="java">        if (mInputEventConsistencyVerifier != null) {            mInputEventConsistencyVerifier.onTouchEvent(event, 0);        }</code></pre><h3 id="mCurrTime"><a href="#mCurrTime" class="headerlink" title="mCurrTime"></a>mCurrTime</h3><ul><li>获得事件发生时的时间</li></ul><pre><code class="java">        mCurrTime = event.getEventTime();</code></pre><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><ul><li>获得事件类型</li></ul><pre><code class="java">        final int action = event.getActionMasked();</code></pre><h3 id="mQuickScaleEnabled"><a href="#mQuickScaleEnabled" class="headerlink" title="mQuickScaleEnabled"></a>mQuickScaleEnabled</h3><ul><li>Forward the event to check for double tap gesture</li><li>@有道 转发事件以检查双击手势</li><li>首先是 mQuickScaleEnabled 这个对象</li><li>翻译过来是： @有道 启用快速扩展</li><li>作用大概就是调用双击监听事件，比如双击最大化</li></ul><pre><code class="java">        if (mQuickScaleEnabled) {            mGestureDetector.onTouchEvent(event);        }</code></pre><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><ul><li>获得屏幕上手指的数目</li></ul><pre><code class="java">        final int count = event.getPointerCount();</code></pre><h3 id="isStylusButtonDown"><a href="#isStylusButtonDown" class="headerlink" title="isStylusButtonDown"></a>isStylusButtonDown</h3><p> 这个主要是由于判断手写笔是否按下<br> 由于我们很少处理手写笔，所以这里不做过多说明</p><pre><code class="java">         final boolean isStylusButtonDown =                (event.getButtonState() &amp; MotionEvent.BUTTON_STYLUS_PRIMARY) != 0;</code></pre><hr><h2 id="第二部分：处理与手势变化"><a href="#第二部分：处理与手势变化" class="headerlink" title="第二部分：处理与手势变化"></a>第二部分：处理与手势变化</h2><p> 用户的缩放手势不总是一定的，就是说对于用户而言，随时可能有手指碰触或离开屏幕，这就使得缩放中心的（焦点）随时可能发生变化，这部分主要是用来处理这一变化，并做出响应。</p><pre><code class="java">         final boolean anchoredScaleCancelled =                mAnchoredScaleMode == ANCHORED_SCALE_MODE_STYLUS &amp;&amp; !isStylusButtonDown;        final boolean streamComplete = action == MotionEvent.ACTION_UP ||                action == MotionEvent.ACTION_CANCEL || anchoredScaleCancelled;        // 如果发生了上面这种小动作，或者说有一手指离开了屏幕，进行调用        if (action == MotionEvent.ACTION_DOWN || streamComplete) {            // Reset any scale in progress with the listener.            // If it&#39;s an ACTION_DOWN we&#39;re beginning a new event stream.            // This means the app probably didn&#39;t give us all the events. Shame on it.            if (mInProgress) {                mListener.onScaleEnd(this);                mInProgress = false;                mInitialSpan = 0;                mAnchoredScaleMode = ANCHORED_SCALE_MODE_NONE;            } else if (inAnchoredScaleMode() &amp;&amp; streamComplete) {                mInProgress = false;                mInitialSpan = 0;                mAnchoredScaleMode = ANCHORED_SCALE_MODE_NONE;            }            if (streamComplete) {                return true;            }        }</code></pre><h3 id="anchoredScaleCancelled"><a href="#anchoredScaleCancelled" class="headerlink" title="anchoredScaleCancelled"></a>anchoredScaleCancelled</h3><ul><li>@Google 锚定规模取消</li><li>我的理解是：用于判断滑动事件是否被取消</li></ul><pre><code class="java">        final boolean anchoredScaleCancelled =                mAnchoredScaleMode == ANCHORED_SCALE_MODE_STYLUS &amp;&amp; !isStylusButtonDown;</code></pre><h3 id="streamComplete"><a href="#streamComplete" class="headerlink" title="streamComplete"></a>streamComplete</h3><ul><li>@Google Translate: 流完成</li><li>我的理解是，这个布尔变量用于标记</li><li>当前动作是否完成</li><li>我这里说的动作有两种</li><li>这里指的是：在大动作如三指触屏放大过程中，又一个手指离开了屏幕这种</li><li>在大动作三指触屏中发生的一个小动作，离开一指</li></ul><pre><code class="java">        final boolean streamComplete = action == MotionEvent.ACTION_UP ||                action == MotionEvent.ACTION_CANCEL || anchoredScaleCancelled;</code></pre><h3 id="action-MotionEvent-ACTION-DOWN-streamComplete"><a href="#action-MotionEvent-ACTION-DOWN-streamComplete" class="headerlink" title="action == MotionEvent.ACTION_DOWN || streamComplete"></a>action == MotionEvent.ACTION_DOWN || streamComplete</h3><ul><li>如果发生了上面这种小动作，或者说有一手指离开了屏幕，就进行调用</li></ul><pre><code class="java">if (action == MotionEvent.ACTION_DOWN || streamComplete) {...}</code></pre><h3 id="if-mInProgress"><a href="#if-mInProgress" class="headerlink" title="if (mInProgress)"></a>if (mInProgress)</h3><ul><li>@google Translate：重置侦听器正在进行的任何缩放。</li><li>如果是ACTION_DOWN，我们开始一个新的事件流。</li><li>这意味着应用程序可能没有给我们所有的事件。很遗憾。</li><li>首先判断该进程（从第一个手指碰上屏幕，到最后一个手指离开屏幕为止）是否结束</li><li>如果仍在运行中，这调用回调方法：onScaleEnd 使其结束</li></ul><pre><code class="java">            if (mInProgress) {                mListener.onScaleEnd(this);                mInProgress = false;                mInitialSpan = 0;                mAnchoredScaleMode = ANCHORED_SCALE_MODE_NONE;            }</code></pre><h3 id="else-if-inAnchoredScaleMode-amp-amp-streamComplete"><a href="#else-if-inAnchoredScaleMode-amp-amp-streamComplete" class="headerlink" title="else if (inAnchoredScaleMode() &amp;&amp; streamComplete)"></a>else if (inAnchoredScaleMode() &amp;&amp; streamComplete)</h3><ul><li>如果当前进程已经结束</li><li>判断 mAnchoredScaleMode 是否为 ANCHORED_SCALE_MODE_STYLUS 状态</li><li>同时判断操作流 streamComplete 是否完成</li><li>都符合的情况下结束这一手势变化</li></ul><pre><code class="java">            else if (inAnchoredScaleMode() &amp;&amp; streamComplete) {                mInProgress = false;                mInitialSpan = 0;                mAnchoredScaleMode = ANCHORED_SCALE_MODE_NONE;            }</code></pre><h3 id="if-streamComplete"><a href="#if-streamComplete" class="headerlink" title="if (streamComplete)"></a>if (streamComplete)</h3><ul><li>结束本次 onTouchEvent 方法的调用，等待下一次调用发生</li></ul><pre><code class="java">            if (streamComplete) {                return true;            }</code></pre><p>总结： 可以看到，当触发 down 或者触发 up，cancel 时，如果之前处于缩放计算的状态，会将其状态重置， 并调用 onScaleEnd 方法。</p><hr><h2 id="进入锚定比例模式"><a href="#进入锚定比例模式" class="headerlink" title="进入锚定比例模式"></a>进入锚定比例模式</h2><ul><li>当判断用户动作，如果为双击这类点击事件，进入该模式</li><li>与正常缩放区分。这个模式功能一般是：双击最大化和最小化</li></ul><pre><code class="java">        if (!mInProgress &amp;&amp; mStylusScaleEnabled &amp;&amp; !inAnchoredScaleMode()                &amp;&amp; !streamComplete &amp;&amp; isStylusButtonDown) {            // Start of a button scale gesture            mAnchoredScaleStartX = event.getX();            mAnchoredScaleStartY = event.getY();            mAnchoredScaleMode = ANCHORED_SCALE_MODE_STYLUS;            mInitialSpan = 0;        }</code></pre><h3 id="mAnchoredScaleStartX-amp-mAnchoredScaleStartY"><a href="#mAnchoredScaleStartX-amp-mAnchoredScaleStartY" class="headerlink" title="mAnchoredScaleStartX &amp; mAnchoredScaleStartY"></a>mAnchoredScaleStartX &amp; mAnchoredScaleStartY</h3><ul><li>后文中将用于重新计算焦点</li></ul><pre><code class="java">            mAnchoredScaleStartX = event.getX();            mAnchoredScaleStartY = event.getY();</code></pre><h3 id="mAnchoredScaleMode"><a href="#mAnchoredScaleMode" class="headerlink" title="mAnchoredScaleMode"></a>mAnchoredScaleMode</h3><ul><li>赋值之后，再次调用 inAnchoredScaleMode() 方法，返回值变为 true</li></ul><pre><code class="java">            mAnchoredScaleMode = ANCHORED_SCALE_MODE_STYLUS;</code></pre><h2 id="计算缩放中心"><a href="#计算缩放中心" class="headerlink" title="计算缩放中心"></a>计算缩放中心</h2><pre><code class="java">        final boolean configChanged = action == MotionEvent.ACTION_DOWN ||                action == MotionEvent.ACTION_POINTER_UP ||                action == MotionEvent.ACTION_POINTER_DOWN || anchoredScaleCancelled;        final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;        final int skipIndex = pointerUp ? event.getActionIndex() : -1;        // Determine focal point        float sumX = 0, sumY = 0;        final int div = pointerUp ? count - 1 : count;        final float focusX;        final float focusY;        if (inAnchoredScaleMode()) {            // In anchored scale mode, the focal pt is always where the double tap            // or button down gesture started            focusX = mAnchoredScaleStartX;            focusY = mAnchoredScaleStartY;            if (event.getY() &lt; focusY) {                mEventBeforeOrAboveStartingGestureEvent = true;            } else {                mEventBeforeOrAboveStartingGestureEvent = false;            }        } else {            for (int i = 0; i &lt; count; i++) {                if (skipIndex == i) continue;                sumX += event.getX(i);                sumY += event.getY(i);            }            focusX = sumX / div;            focusY = sumY / div;        }</code></pre><h3 id="configChanged"><a href="#configChanged" class="headerlink" title="configChanged"></a>configChanged</h3><ul><li>布尔类型量，标志着一个操作的完成或者结束（手指离开，手指按下）</li></ul><pre><code class="java">        final boolean configChanged = action == MotionEvent.ACTION_DOWN ||                action == MotionEvent.ACTION_POINTER_UP ||                action == MotionEvent.ACTION_POINTER_DOWN || anchoredScaleCancelled;</code></pre><h3 id="pointerUp"><a href="#pointerUp" class="headerlink" title="pointerUp"></a>pointerUp</h3><ul><li>布尔类型量，用于判断当前动作，是否为手指离开（抬起动作）</li></ul><pre><code class="java">        final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;</code></pre><h3 id="skipIndex"><a href="#skipIndex" class="headerlink" title="skipIndex"></a>skipIndex</h3><ul><li>标记量，在是手指离开的情况下，标记离开手指</li><li>在后面计算新的焦点代码中，跳过该手指的标记点坐标，进行计算</li></ul><pre><code class="java">        final int skipIndex = pointerUp ? event.getActionIndex() : -1;</code></pre><h3 id="初始化计算所需临时变量"><a href="#初始化计算所需临时变量" class="headerlink" title="初始化计算所需临时变量"></a>初始化计算所需临时变量</h3><pre><code class="java">        // Determine focal point        float sumX = 0, sumY = 0;        // 如果是抬起手指，则当前手指数减1，否则不变        final int div = pointerUp ? count - 1 : count;        final float focusX;        final float focusY;</code></pre><h3 id="判断是否为锚定比例模式"><a href="#判断是否为锚定比例模式" class="headerlink" title="判断是否为锚定比例模式"></a>判断是否为锚定比例模式</h3><ul><li>是的话直接将点击时记下的点，作为焦点</li><li>不是的话，把所有点累加求和，除以总个数，计算平均值</li></ul><pre><code class="java">        if (inAnchoredScaleMode()) {            // In anchored scale mode, the focal pt is always where the double tap            // or button down gesture started            // 在锚定比例模式中，焦点pt始终是双击的位置，或按下手势开始            focusX = mAnchoredScaleStartX;            focusY = mAnchoredScaleStartY;            if (event.getY() &lt; focusY) {                mEventBeforeOrAboveStartingGestureEvent = true;            } else {                mEventBeforeOrAboveStartingGestureEvent = false;            }        } else {            for (int i = 0; i &lt; count; i++) {                if (skipIndex == i) continue;                sumX += event.getX(i);                sumY += event.getY(i);            }            focusX = sumX / div;            focusY = sumY / div;        }</code></pre><hr><h2 id="算缩放比例"><a href="#算缩放比例" class="headerlink" title="算缩放比例"></a>算缩放比例</h2><ul><li>计算缩放比例也很简单，就是计算各个手指到焦点的平均距离，在用户手指移动后用新的平均距离除以旧的平均距离，并以此计算得出缩放比例。</li></ul><pre><code class="java">        // Determine average deviation from focal point @Google translate         float devSumX = 0, devSumY = 0;        for (int i = 0; i &lt; count; i++) {            if (skipIndex == i) continue;            // Convert the resulting diameter into a radius.            devSumX += Math.abs(event.getX(i) - focusX);            devSumY += Math.abs(event.getY(i) - focusY);        }        final float devX = devSumX / div;        final float devY = devSumY / div;        // Span is the average distance between touch points through the focal point;        // i.e. the diameter of the circle with a radius of the average deviation from        // the focal point.        final float spanX = devX * 2;        final float spanY = devY * 2;        final float span;        if (inAnchoredScaleMode()) {            span = spanY;        } else {            span = (float) Math.hypot(spanX, spanY);        }</code></pre><h3 id="计算平均偏差"><a href="#计算平均偏差" class="headerlink" title="计算平均偏差"></a>计算平均偏差</h3><ul><li>确定焦点的平均偏差</li></ul><pre><code class="java">        float devSumX = 0, devSumY = 0;        for (int i = 0; i &lt; count; i++) {            if (skipIndex == i) continue;            // Convert the resulting diameter into a radius.            devSumX += Math.abs(event.getX(i) - focusX);            devSumY += Math.abs(event.getY(i) - focusY);        }        final float devX = devSumX / div;        final float devY = devSumY / div;</code></pre><h3 id="计算缩放比例"><a href="#计算缩放比例" class="headerlink" title="计算缩放比例"></a>计算缩放比例</h3><ul><li>跨度是通过焦点的触摸点之间的平均距离;</li><li>即圆的直径，其半径为平均偏差</li><li>这里的 Math.hypot(spanX, spanY) 方法，相当于 sqrt(x<em>x + y</em>y)</li></ul><pre><code class="java">        final float spanX = devX * 2;        final float spanY = devY * 2;        final float span;        if (inAnchoredScaleMode()) {            span = spanY;        } else {            span = (float) Math.hypot(spanX, spanY);        }</code></pre><hr><h2 id="结束缩放事件"><a href="#结束缩放事件" class="headerlink" title="结束缩放事件"></a>结束缩放事件</h2><ul><li>@Google Translate：根据需要调度开始/结束事件。</li><li>如果配置发生更改，请通过开始通知应用重置其当前状态</li><li>一个新的比例事件流。</li><li>这里就不做太多描述，主要就是：</li><li>判断是不是所有手指都离开了屏幕</li><li>如果是，那么索命这个缩放进程结束了</li><li>则保存当前缩放的数据</li><li>调用 onScaleEnd 方法，结束当前操作</li></ul><pre><code class="java">        final boolean wasInProgress = mInProgress;        mFocusX = focusX;        mFocusY = focusY;        if (!inAnchoredScaleMode() &amp;&amp; mInProgress &amp;&amp; (span &lt; mMinSpan || configChanged)) {            mListener.onScaleEnd(this);            mInProgress = false;            mInitialSpan = span;        }        if (configChanged) {            mPrevSpanX = mCurrSpanX = spanX;            mPrevSpanY = mCurrSpanY = spanY;            mInitialSpan = mPrevSpan = mCurrSpan = span;        }</code></pre><h2 id="触发-onScaleBegin-开始缩放"><a href="#触发-onScaleBegin-开始缩放" class="headerlink" title="触发 onScaleBegin 开始缩放"></a>触发 onScaleBegin 开始缩放</h2><ul><li>当手指移动的距离超过一定数值(数值大小由系统定义)后，会触发 onScaleBegin 方法</li><li>如果用户在 onScaleBegin 方法里面返回了 true，则接受事件后，就会重置缩放相关数值，并且开始积累缩放因子。</li></ul><pre><code class="java">        final int minSpan = inAnchoredScaleMode() ? mSpanSlop : mMinSpan;        if (!mInProgress &amp;&amp; span &gt;= minSpan &amp;&amp;                (wasInProgress || Math.abs(span - mInitialSpan) &gt; mSpanSlop)) {            mPrevSpanX = mCurrSpanX = spanX;            mPrevSpanY = mCurrSpanY = spanY;            mPrevSpan = mCurrSpan = span;            mPrevTime = mCurrTime;            mInProgress = mListener.onScaleBegin(this);        }</code></pre><h2 id="通知用户进行缩放处理"><a href="#通知用户进行缩放处理" class="headerlink" title="通知用户进行缩放处理"></a>通知用户进行缩放处理</h2><ul><li>@ Google Translate: 处理动作;焦点和跨度/比例因子正在发生变化。</li><li>这块代码的功能主要就是通知用户（编程者）</li><li>根据这些数据进行缩放</li></ul><pre><code class="java">        if (action == MotionEvent.ACTION_MOVE) {            mCurrSpanX = spanX;            mCurrSpanY = spanY;            mCurrSpan = span;            boolean updatePrev = true;            if (mInProgress) {                updatePrev = mListener.onScale(this);            }            if (updatePrev) {                mPrevSpanX = mCurrSpanX;                mPrevSpanY = mCurrSpanY;                mPrevSpan = mCurrSpan;                mPrevTime = mCurrTime;            }        }</code></pre><h3 id="updatePrev"><a href="#updatePrev" class="headerlink" title="updatePrev"></a>updatePrev</h3><ul><li>这个用于接收用户的返回值</li><li>只要我们放回 true ，系统就会保存当前数据</li><li>重新获取并计算新的数据和比例</li><li>系统默认返回 false 然后进行下一次事件的计算</li></ul><pre><code class="java">            if (mInProgress) {                updatePrev = mListener.onScale(this);            }            if (updatePrev) {                mPrevSpanX = mCurrSpanX;                mPrevSpanY = mCurrSpanY;                mPrevSpan = mCurrSpan;                mPrevTime = mCurrTime;            }</code></pre><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>我要讲的所有内容，到这里就完全结束了</p><p>由于源码是按照我自己的理解来讲的，所以难免会有一些出入</p><p>希望大家能在评论区中帮我指出，谢谢～ 🙏</p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>ScaleGestureDetector</tag>
      
      <tag>缩放手势</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式-全局可用的 context 对象，这一篇就够了</title>
    <link href="undefined2019/10/09/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E5%85%A8%E5%B1%80%E5%8F%AF%E7%94%A8%E7%9A%84%20context%20%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <url>2019/10/09/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E5%85%A8%E5%B1%80%E5%8F%AF%E7%94%A8%E7%9A%84%20context%20%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>单例模式在各个方面都有着极为广泛的使用，所谓单例，顾名思义就是整个程序中只有一个该类的实例，所以它成功保证了整个程序的生命周期内该类的对象只能创建一次，并且提供全局唯一访问该类的方法：getInstance()</p></blockquote><hr><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>关于单例模式主要分为两类：</p><ul><li>懒汉模式</li><li>饿汉模式</li></ul><p>由于饿汉模式是线程安全的，所以通常情况下，我们都尽量采用饿汉模式，具体原因常见这位大佬的博文：<a href="https://www.jianshu.com/p/8b59089a12f6" target="_blank" rel="noopener">点击前往</a></p><p>本文主要结合 Android 分析下当例模式在 Android 中获得全局可用的 Context 对象</p><hr><h3 id="搭建饿汉模式基本框架"><a href="#搭建饿汉模式基本框架" class="headerlink" title="搭建饿汉模式基本框架"></a>搭建饿汉模式基本框架</h3><p>单例模式基本方法包括</p><ul><li>一个该类对象</li><li>该类构造方法</li><li>获得单例的方法</li></ul><pre><code class="java">/**单例模式 * * 向整个应用提供 App (application) 单例 */public class AppContext {    private static AppContext instance;    public AppContext(Context application){    }    public static AppContext getInstance() {        if (instance == null){            throw new RuntimeException();        }        return instance;    }}</code></pre><hr><h3 id="对外暴露实例化单例的方法"><a href="#对外暴露实例化单例的方法" class="headerlink" title="对外暴露实例化单例的方法"></a>对外暴露实例化单例的方法</h3><p>外界调用时，将全局的 context 对象传入</p><pre><code class="java">    public static void init(Context context){        if (instance != null){            throw new RuntimeException();        }        instance = new AppContext(context);    }</code></pre><p>修改构造方法：</p><ul><li>将全局的 Context 对象保存到该单例中</li></ul><pre><code class="java">    private Context applicationContext;    public AppContext(Context application){        this.applicationContext = application;    }</code></pre><hr><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>在之前的基础上，暴露获得 Context 对象的方法</p><pre><code class="java">/**单例模式 * * 向整个应用提供 App (application) 单例 */public class AppContext {    private static AppContext instance;    private Context applicationContext;    public AppContext(Context application){        this.applicationContext = application;    }    public Context getApplicationContext() {        return applicationContext;    }    public static AppContext getInstance() {        if (instance == null){            throw new RuntimeException();        }        return instance;    }    public static void init(Context context){        if (instance != null){            throw new RuntimeException();        }        instance = new AppContext(context);    }    public static boolean isInitialized(){        return (instance != null);    }}</code></pre><hr><h1 id="单例的实例化"><a href="#单例的实例化" class="headerlink" title="单例的实例化"></a>单例的实例化</h1><p>那么我们如何生成该单例能，由于单例是全剧唯一的，根据这个特性我们一般在 Application 中实例化它</p><pre><code class="java">public class App extends Application {    @Override    public void onCreate() {        super.onCreate();        if (!AppContext.isInitialized()){            AppContext.init(getApplicationContext());        }    }}</code></pre><hr><h1 id="单例-context-的使用"><a href="#单例-context-的使用" class="headerlink" title="单例 context 的使用"></a>单例 context 的使用</h1><p>context 的使用可以说非常广泛，例如获得程序网络功能，获得制定控件属性等等，用途可以说是非常广泛</p><ul><li>获得网络状态</li></ul><pre><code class="java">NetworkUtil.isNetworkAvailable(AppContext.getInstance().getApplicationContext()public class NetworkUtil {    /**     * 检查网络是否可用     *     * @param context     * @return     */    public static boolean isNetworkAvailable(Context context) {        ConnectivityManager manager = (ConnectivityManager) context                .getApplicationContext().getSystemService(                        Context.CONNECTIVITY_SERVICE);        if (manager == null) {            return false;        }        NetworkInfo networkinfo = manager.getActiveNetworkInfo();        if (networkinfo == null || !networkinfo.isAvailable()) {            return false;        }        return true;    }}</code></pre><ul><li>在工具类中获得控件属性值</li></ul><pre><code class="java">    /**     * color.xml里面的id     */    public static int getColor(int colorResId){        Context context = OrderContext.getInstance().getApplicationContext();        return context.getResources().getColor(colorResId);    }</code></pre><hr><p>单例模式的使用非常广泛，但具体的内容基本就这些，本文主要是我学习过程中的一点总结。</p><p>大家可以在此基础上加以改造使用，如果有其他的应用场景，欢迎在评论区中分享，一起进步～！</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高效解决「SQLite」数据库并发访问安全问题，只这一篇就够了</title>
    <link href="undefined2019/10/07/%E9%AB%98%E6%95%88%E8%A7%A3%E5%86%B3%E3%80%8CSQLite%E3%80%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%8C%E5%8F%AA%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <url>2019/10/07/%E9%AB%98%E6%95%88%E8%A7%A3%E5%86%B3%E3%80%8CSQLite%E3%80%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%8C%E5%8F%AA%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2019/9/29/16d7d4bb55a49eb6?w=2000&h=1215&f=jpeg&s=125618" srcset="/img/loading.gif" alt="学Android"></p><h1 id="Concurrent-database-access"><a href="#Concurrent-database-access" class="headerlink" title="Concurrent database access"></a>Concurrent database access</h1><hr><p>对于 Android Dev 而言，有关 SQLite 的操作再经常不过了，相比你一定经历过控制台一片爆红的情况，这不禁让我们疑问：SQLite 到底是线程安全的吗？</p><p><strong>OK  废话不多说，我们 ⬇️</strong></p><h1 id="直接开始"><a href="#直接开始" class="headerlink" title="直接开始"></a>直接开始</h1><hr><h4 id="首先，假设你已经实现了一个-SQLiteHelper-类，如下所示："><a href="#首先，假设你已经实现了一个-SQLiteHelper-类，如下所示：" class="headerlink" title="首先，假设你已经实现了一个 SQLiteHelper 类，如下所示："></a>首先，假设你已经实现了一个 SQLiteHelper 类，如下所示：</h4><pre><code class="java">public class DatabaseHelper extends SQLiteOpenHelper { ... }</code></pre><p>现在你想要在两个子线程中，分别地向 SQLite 里写入一些数据：</p><pre><code class="java"> // Thread 1 Context context = getApplicationContext(); DatabaseHelper helper = new DatabaseHelper(context); SQLiteDatabase database = helper.getWritableDatabase(); database.insert(…); database.close(); // Thread 2 Context context = getApplicationContext(); DatabaseHelper helper = new DatabaseHelper(context); SQLiteDatabase database = helper.getWritableDatabase(); database.insert(…); database.close();</code></pre><blockquote><p>对吧？看上去很 OK 没啥毛病。</p></blockquote><p>那么这时，我们点一下 <code>run</code> ，gio～ 你将会在你的 logcat 里收到如下礼物「报错」：</p><pre><code class="java">android.database.sqlite.SQLiteDatabaseLockedException: database is locked (code 5)</code></pre><h4 id="到底是怎么回事呢？"><a href="#到底是怎么回事呢？" class="headerlink" title="到底是怎么回事呢？"></a>到底是怎么回事呢？</h4><p>我们分析一下报错终于发现：这是由于你每次创建 SQLiteHelper 时，都对数据库进行了一个链接操作。这时，如果你尝试着，同时从实际不同的链接中，对数据库进行写入操作，失败就是必然的了。</p><blockquote><p><strong>总结一下</strong><br>如果我们想再不同的线程中，对数据库进行包括读写操作在内的任何使用，我们就必须得确保，我们使用的是同一个的连接</p></blockquote><p>好，那现在问题就明了了。现在让我们创建一个单例模式类：<code>DatabaseManager</code> 用来创建和返回唯一的，单例 <code>DatabaseManager</code> 对象。</p><blockquote><p>ps 有些同学问我什么是单例模式，我专门跑去写了这篇博客来解释下，<a href="https://blog.csdn.net/qq_43377749/article/details/96324909" target="_blank" rel="noopener">单例模式-全局可用的 context 对象，这一篇就够了</a>码字不易帮我点个赞谢谢 🙏</p></blockquote><pre><code class="java">public class DatabaseManager {    private static DatabaseManager instance;    private static SQLiteOpenHelper mDatabaseHelper;    public static synchronized void initializeInstance(SQLiteOpenHelper helper) {        if (instance == null) {            instance = new DatabaseManager();            mDatabaseHelper = helper;        }    }    public static synchronized DatabaseManager getInstance() {        if (instance == null) {            throw new IllegalStateException(DatabaseManager.class.getSimpleName() +                    &quot; is not initialized, call initialize(..) method first.&quot;);        }        return instance;    }    public synchronized SQLiteDatabase getDatabase() {        return mDatabaseHelper.getWritableDatabase();    }}</code></pre><p>现在，我们在回来修改下之前的代码，结果如下所示：</p><pre><code class="java">// In your application classDatabaseManager.initializeInstance(new DatabaseHelper());// Thread 1DatabaseManager manager = DatabaseManager.getInstance();SQLiteDatabase database = manager.getDatabase()database.insert(…);database.close();// Thread 2DatabaseManager manager = DatabaseManager.getInstance();SQLiteDatabase database = manager.getDatabase()database.insert(…);database.close();</code></pre><p>逻辑比之前更清晰，代码冗余也少了。现在我们在跑下代码，这时我们会收到，另一个 <code>cache</code> ：</p><pre><code class="java">java.lang.IllegalStateException: attempt to re-open an already-closed object: SQLiteDatabase</code></pre><p>不要慌，我们仔细分析下报错，我们发现：单例模式的使用保证了我们，在线程一、二「Thread 1、Thread 2 中」只会获得到唯一的 SQLiteHelper 对象，但这时问题就来了，当我们运行完线程一「Thread 1」时，我们的 <code>database.close();</code> 已经替我们关闭了对数据库的连接，但与此同时我们的线程二「Thread 2」依然保持这对 SQLiteHelper 的引用。正是这个原因，我们收到了<code>IllegalStateException</code>的报错。</p><p>所以，这时我们就需要保证，当没有人使用 SQLiteHelper 时，再将其断开连接。</p><h4 id="保证-SQLIiteHelper-在无人使用时才断开连接"><a href="#保证-SQLIiteHelper-在无人使用时才断开连接" class="headerlink" title="保证 SQLIiteHelper 在无人使用时才断开连接"></a>保证 SQLIiteHelper 在无人使用时才断开连接</h4><p>关于这个问题的解决 stackoveflow 上很多人建议我们：永远不要断开 SQLiteHelper 的连接，但是这样以来你会在 logcat 上得到如下输出：</p><pre><code class="java">Leak foundCaused by: java.lang.IllegalStateException: SQLiteDatabase created and never closed</code></pre><p>所以，我非常不建议你用这个方法。为了解决这个问题，我们引入计数器的概念</p><h4 id="标准样例"><a href="#标准样例" class="headerlink" title="标准样例"></a>标准样例</h4><p>通过如下方法，你将通过一个计数器来完美解决 打开/关闭 数据库连接的问题：</p><pre><code class="java">public class DatabaseManager {    private AtomicInteger mOpenCounter = new AtomicInteger();    private static DatabaseManager instance;    private static SQLiteOpenHelper mDatabaseHelper;    private SQLiteDatabase mDatabase;    public static synchronized void initializeInstance(SQLiteOpenHelper helper) {        if (instance == null) {            instance = new DatabaseManager();            mDatabaseHelper = helper;        }    }    public static synchronized DatabaseManager getInstance() {        if (instance == null) {            throw new IllegalStateException(DatabaseManager.class.getSimpleName() +                    &quot; is not initialized, call initializeInstance(..) method first.&quot;);        }        return instance;    }    public synchronized SQLiteDatabase openDatabase() {        if(mOpenCounter.incrementAndGet() == 1) {            // Opening new database            mDatabase = mDatabaseHelper.getWritableDatabase();        }        return mDatabase;    }    public synchronized void closeDatabase() {        if(mOpenCounter.decrementAndGet() == 0) {            // Closing database            mDatabase.close();        }    }}</code></pre><p>我们在线程中可以这样使用它：</p><pre><code class="java">SQLiteDatabase database = DatabaseManager.getInstance().openDatabase();database.insert(...);// database.close(); Don&#39;t close it directly!DatabaseManager.getInstance().closeDatabase(); // correct way</code></pre><p>每当你需要使用数据库时，你只要调用 DatabaseManager 中的 openDatabase() 方法。在这个方法中，我们有一个，用来记录数据库被“打开”了几次的 mOpenCounter 对象。当它等于 1 时，这意味着你需要去创建新的数据库连接来使用数据库，否则的话，就说明数据库已经在使用中了。</p><p>同样的情况也发生在 closeDatabase() 方法中，当你每次调用该方法时，我们的 mOpenCounter 对象就会减一。当它减到 0 时，我们就去关闭这个数据库的连接。</p><p>完美，最后：</p><ol><li>现在你就能随心所欲的使用你的数据库，而且你可以相信 – 它是线程安全的了！</li><li>当然很多同学对数据库的使用，还有着很多的疑惑，我后期将会针对数据库的使用，作出一系列总结，有兴趣可以继续关注 <strong><a href="https://juejin.im/user/5d00b2ee6fb9a07ef5622eed/posts" target="_blank" rel="noopener">_yuanhao 的编程世界</a></strong></li></ol><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><hr><blockquote><h4 id="每个人都要学的图片压缩，有效解决-Android-程序-OOM"><a href="#每个人都要学的图片压缩，有效解决-Android-程序-OOM" class="headerlink" title="每个人都要学的图片压缩，有效解决 Android 程序 OOM"></a><a href="https://juejin.im/post/5d932934e51d45784f2503a7" target="_blank" rel="noopener">每个人都要学的图片压缩，有效解决 Android 程序 OOM</a></h4><h4 id="Android-让你的-Room-搭上-RxJava-的顺风车-从重复的代码中解脱出来"><a href="#Android-让你的-Room-搭上-RxJava-的顺风车-从重复的代码中解脱出来" class="headerlink" title="Android 让你的 Room 搭上 RxJava 的顺风车 从重复的代码中解脱出来"></a><a href="https://juejin.im/post/5d8ab439e51d45784021e446" target="_blank" rel="noopener">Android 让你的 Room 搭上 RxJava 的顺风车 从重复的代码中解脱出来</a></h4><h4 id="ViewModel-和-ViewModelProvider-Factory：ViewModel-的创建者"><a href="#ViewModel-和-ViewModelProvider-Factory：ViewModel-的创建者" class="headerlink" title="ViewModel 和 ViewModelProvider.Factory：ViewModel 的创建者"></a><a href="https://juejin.im/post/5d80920bf265da03b638e0bd" target="_blank" rel="noopener">ViewModel 和 ViewModelProvider.Factory：ViewModel 的创建者</a></h4><h4 id="单例模式-全局可用的-context-对象，这一篇就够了"><a href="#单例模式-全局可用的-context-对象，这一篇就够了" class="headerlink" title="单例模式-全局可用的 context 对象，这一篇就够了"></a><a href="https://juejin.im/post/5d2ef3c96fb9a07ef90ccf90" target="_blank" rel="noopener">单例模式-全局可用的 context 对象，这一篇就够了</a></h4><h4 id="缩放手势-ScaleGestureDetector-源码解析，这一篇就够了"><a href="#缩放手势-ScaleGestureDetector-源码解析，这一篇就够了" class="headerlink" title="缩放手势 ScaleGestureDetector 源码解析，这一篇就够了"></a><a href="https://juejin.im/post/5d14cc0ff265da1b6d403750" target="_blank" rel="noopener">缩放手势 ScaleGestureDetector 源码解析，这一篇就够了</a></h4><h4 id="Android-属性动画框架-ObjectAnimator、ValueAnimator-，这一篇就够了"><a href="#Android-属性动画框架-ObjectAnimator、ValueAnimator-，这一篇就够了" class="headerlink" title="Android 属性动画框架 ObjectAnimator、ValueAnimator ，这一篇就够了"></a><a href="https://juejin.im/post/5d09990bf265da1bd260ef52" target="_blank" rel="noopener">Android 属性动画框架 ObjectAnimator、ValueAnimator ，这一篇就够了</a></h4><h4 id="看完这篇再不会-View-的动画框架，我跪搓衣板"><a href="#看完这篇再不会-View-的动画框架，我跪搓衣板" class="headerlink" title="看完这篇再不会 View 的动画框架，我跪搓衣板"></a><a href="https://juejin.im/post/5d04610be51d45775a700309" target="_blank" rel="noopener">看完这篇再不会 View 的动画框架，我跪搓衣板</a></h4><h4 id="Android-自定义时钟控件-时针、分针、秒针的绘制这一篇就够了"><a href="#Android-自定义时钟控件-时针、分针、秒针的绘制这一篇就够了" class="headerlink" title="Android 自定义时钟控件 时针、分针、秒针的绘制这一篇就够了"></a><a href="https://juejin.im/post/5d00f09c6fb9a07ef06f8d03" target="_blank" rel="noopener">Android 自定义时钟控件 时针、分针、秒针的绘制这一篇就够了</a></h4><h4 id="android-自定义控件之-绘制钟表盘"><a href="#android-自定义控件之-绘制钟表盘" class="headerlink" title="android 自定义控件之-绘制钟表盘"></a><a href="https://juejin.im/post/5d0c8faa5188253274727dc0" target="_blank" rel="noopener">android 自定义控件之-绘制钟表盘</a></h4><h4 id="Android-进阶自定义-ViewGroup-自定义布局"><a href="#Android-进阶自定义-ViewGroup-自定义布局" class="headerlink" title="Android 进阶自定义 ViewGroup 自定义布局"></a><a href="https://juejin.im/post/5d0db01af265da1bcc194aba" target="_blank" rel="noopener">Android 进阶自定义 ViewGroup 自定义布局</a></h4></blockquote><h1 id="欢迎关注-yuanhao的掘金！"><a href="#欢迎关注-yuanhao的掘金！" class="headerlink" title="欢迎关注_yuanhao的掘金！"></a>欢迎关注<a href="https://juejin.im/user/5d00b2ee6fb9a07ef5622eed/posts" target="_blank" rel="noopener">_yuanhao</a>的掘金！</h1><hr><p>定期分享<code>Android开发</code>湿货，追求文章<code>幽默与深度</code>的完美统一。</p><p>关于源码 Demo 链接：<strong><a href="https://github.com/FishInWater-1999/SQLiteSample" target="_blank" rel="noopener">为了写 Demo 花了好几天时间，希望大家点歌 star~ 谢谢！</a></strong></p><h3 id="请点赞！因为你的鼓励是我写作的最大动力！"><a href="#请点赞！因为你的鼓励是我写作的最大动力！" class="headerlink" title="请点赞！因为你的鼓励是我写作的最大动力！"></a>请点赞！因为你的鼓励是我写作的最大动力！</h3><p><img src="https://user-gold-cdn.xitu.io/2019/9/29/16d7d4cac8f48e62?w=2000&h=1215&f=jpeg&s=190057" srcset="/img/loading.gif" alt="学Android"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQLite</tag>
      
      <tag>线程安全</tag>
      
      <tag>并发访问</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ViewModel 和 ViewModelProvider.Factory：ViewModel 的创建者</title>
    <link href="undefined2019/10/06/ViewModel%20%E5%92%8C%20ViewModelProvider.Factory%EF%BC%9AViewModel%20%E7%9A%84%E5%88%9B%E5%BB%BA%E8%80%85/"/>
    <url>2019/10/06/ViewModel%20%E5%92%8C%20ViewModelProvider.Factory%EF%BC%9AViewModel%20%E7%9A%84%E5%88%9B%E5%BB%BA%E8%80%85/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20190915160822831.jpg" srcset="/img/loading.gif" alt></p><blockquote><p>朋友们好，今天我向大家介绍下 ViewModel 中如何使用 ViewModelProvider.Factory.</p></blockquote><hr><h1 id="现在开始"><a href="#现在开始" class="headerlink" title="现在开始"></a>现在开始</h1><p>所以，我们首要问题是：什么是 ViewModelProvider.Factory ?让我们在不使用 ViewModelProvider.Factory 的情况下，试着创建一个 ViewModel 看看：</p><p><img src="https://img-blog.csdnimg.cn/20190915160918134.png" srcset="/img/loading.gif" alt="MyViewModel.kt"></p><p>在活动中实例化：</p><p><img src="https://img-blog.csdnimg.cn/20190915161022293.png" srcset="/img/loading.gif" alt="MyActivity.kt"></p><p>有没有人注意到：当我们使用 ViewModelProviders 在活动中实例化 MyViewModel 时，从未没用过 MyViewModel 的构造方法，而都是使用 ViewModelProviders 这个类中的方法。ViewModelProviders 在内部为我们管理并调用 ViewModel 的主构造函数，创建viewmodel的实例并将该实例并返回。</p><p>那么，现在让我们看看，如果我们直接把参数传递给 MyViewModel 类的构造方法时会发生了什么：</p><p><img src="https://img-blog.csdnimg.cn/20190915184848112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzc3NzQ5,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="MyViewModel.kt"></p><p>现在，我们在活动中创建 MyViewModel 实例：</p><p><img src="https://img-blog.csdnimg.cn/20190915184940962.png" srcset="/img/loading.gif" alt="MyActivity.kt"></p><p>太棒了！没有发生任何错误</p><p>但是，等等。</p><p>当你运行上面这段代码的时候，你收到了 RunTimeError。程序崩溃了！！！ RuntimeException 不能创建出 MyViewModel 实例。</p><p>现在我们为什么会发生这些。ViewModelProviders 的 of() 方法，在内部创建了默认的 ViewModelProvider.Factory ，从而实现了 ViewModel 的无参创建。所以，当我们在构造方法添加参数时， ViewModelProvider.Factory 的内部无法实例化 ViewModel 对象，因为 ViewModelProvider.Factory 调用主构造方法创建 ViewModel’s 实例而失败。下图是 ViewModelFactory ViewModelFactory 的默认实现。</p><p><img src="https://img-blog.csdnimg.cn/20190915190507130.png" srcset="/img/loading.gif" alt="ViewModel Factory inner implementation"><br>如果你想在构造方法中添加参数，你需要编写自己的 ViewModelProvider 来创建 ViewModel 实例。</p><h1 id="什么是-ViewModelProvider-Factory"><a href="#什么是-ViewModelProvider-Factory" class="headerlink" title="什么是 ViewModelProvider.Factory?"></a>什么是 ViewModelProvider.Factory?</h1><p>ViewModelProviders.Factory 接口是负责实例化 ViewModels 对象的启动装置。这意味着你需要自己写实例化 ViewModel 对象的方法。</p><p>让我们像下面这样创建自己的 ViewModelProvider.Factory ：</p><p><img src="https://img-blog.csdnimg.cn/20190915192036556.png" srcset="/img/loading.gif" alt="MyViewModelFactory.kt"></p><p>这里有几点需要记下：</p><ol><li>你需要通过构造方法或者其他你喜欢的途径（比如 Singleton, FactoryPattern 等等）。这是由于你在实例化 ViewModel 对象时，不能直接在活动或者碎片中调用 ViewModel 的构造方法，而且你又想去设置 ViewModel 构造方法的参数，因此你需要将参数传入 ViewModelProvider.Factory 它将会帮你创建你的 ViewModel。</li><li>ViewModelProvider.Factory 是一个包含 create 方法的接口。这个 create 方法负责创建你的 VeiwModel’s 实例。</li><li>modelClass.getConstructor(Int::class.java) 方法是一个整型的能够通过调用 newInstance 方法来想构造方法传值的方法。</li></ol><p>现在就让我们通过 ViewModelProvider.Factory 在活动中创建 ViewModel 实例。</p><p><img src="https://img-blog.csdnimg.cn/20190915194318145.png" srcset="/img/loading.gif" alt="MyActivity.kt"></p><p>我们将参数或者依赖关系转入我们的 ViewModelProvider.Factory 以便于它能够为我们创建 ViewModel，ViewModelProviders.of( context, instanceOfViewModelFactory) 方法获得我们 ViewModelProvider.Factory 实例，现在就像之前的例子中一样，我们已经学会了创建 ViewModel 实例的过程。</p><h2 id="所以，为什么我们需要-ViewModelProvider-Factory"><a href="#所以，为什么我们需要-ViewModelProvider-Factory" class="headerlink" title="所以，为什么我们需要 ViewModelProvider.Factory ?"></a>所以，为什么我们需要 ViewModelProvider.Factory ?</h2><p>我们心中有这样一些疑问，我们不能直接在活动或碎片中将值传入 ViewModel 构造方法中去，我需要写法来设置我们的参数值使其正常工作，这就是为什么我们需要 ViewModelProver.Factory，在一些情况下你可以不使用，但在某些特定情形下，你需要使用 ViewModelProver.Factory。</p><h2 id="什么时候使用-ViewModelProvider-Factory"><a href="#什么时候使用-ViewModelProvider-Factory" class="headerlink" title="什么时候使用 ViewModelProvider.Factory"></a>什么时候使用 ViewModelProvider.Factory</h2><p>当你的 ViewModel 有依赖项，并且你需要将这些依赖项通过构造方法传入，因此，您可以模拟该依赖项并测试 ViewModel。</p><h2 id="什么时候不应该使用-ViewModelProvider-Factory"><a href="#什么时候不应该使用-ViewModelProvider-Factory" class="headerlink" title="什么时候不应该使用 ViewModelProvider.Factory"></a>什么时候不应该使用 ViewModelProvider.Factory</h2><p>如果你的 ViewModel 没有依赖项，这时你就不需要去自己创建 ViewModelProvider.Factory。系统自带的方法，注意帮助你创建 ViewModel。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ViewModelProvider.Factory 负责帮你创建 ViewModel 实例。当你的 ViewModel 存在依赖项，且你希望测试你的 ViewModel 时，你需要创建自己的 ViewModelProvider.Factory 来通过 ViewModel 的构造方法传递依赖项，将你的数值传入 ViewModelProvider.Factory 实例中去</p><blockquote><p>你的关注是我最大的动力！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ViewModelProvider</tag>
      
      <tag>ViewModel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 Mac 上安装 Git ，生成 SSH 密钥用于 GitHub 授权</title>
    <link href="undefined2019/10/04/%E5%9C%A8-Mac-%E4%B8%8A%E5%AE%89%E8%A3%85-Git-%EF%BC%8C%E7%94%9F%E6%88%90-SSH-%E5%AF%86%E9%92%A5%E7%94%A8%E4%BA%8E-GitHub-%E6%8E%88%E6%9D%83/"/>
    <url>2019/10/04/%E5%9C%A8-Mac-%E4%B8%8A%E5%AE%89%E8%A3%85-Git-%EF%BC%8C%E7%94%9F%E6%88%90-SSH-%E5%AF%86%E9%92%A5%E7%94%A8%E4%BA%8E-GitHub-%E6%8E%88%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在本教程中，将介绍如何在 Mac 上安装 Git，如何生成SSH密钥，以及如何将您的公共 SSH 密钥上传到 GitHub 帐户进行授权。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190920090245710.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="如何在你的-Mac-上安装-Git-？"><a href="#如何在你的-Mac-上安装-Git-？" class="headerlink" title="如何在你的 Mac 上安装 Git ？"></a>如何在你的 Mac 上安装 Git ？</h1><p>打开‘终端’输入如下命令：</p><pre><code class="xml">$ brew install git</code></pre><blockquote><p> 具体方法查看其官方文档 ：<a href="https://brew.sh/" target="_blank" rel="noopener">https://brew.sh/</a></p></blockquote><p>这将在您的系统上安装 Git。<br>若要确认是否安装成功，请输入：</p><pre><code class="xml">$ git --version</code></pre><p>这样你就能看到目前的 Git 版本。</p><h1 id="如何为-GitHub-授权生成-SSH-密钥"><a href="#如何为-GitHub-授权生成-SSH-密钥" class="headerlink" title="如何为 GitHub 授权生成 SSH 密钥"></a>如何为 GitHub 授权生成 SSH 密钥</h1><h4 id="打开你的终端"><a href="#打开你的终端" class="headerlink" title="打开你的终端"></a>打开你的终端</h4><h4 id="输入-cd-来到你的根目录下"><a href="#输入-cd-来到你的根目录下" class="headerlink" title="输入  cd ~/  来到你的根目录下"></a>输入  <strong>cd ~/</strong>  来到你的根目录下</h4><h4 id="输入以下指令："><a href="#输入以下指令：" class="headerlink" title="输入以下指令："></a>输入以下指令：</h4><pre><code class="xml">ssh-keygen -t rsa</code></pre><ul><li>这时系统将提示您输入一个文件名来存储密钥 </li><li>只需按 ‘回车’ 接受默认文件 (/Users/you/.ssh/id_rsa) 即可</li><li>然后它会要求您创建一个密码。你可以进行设定，但我一般选择直接回车（这样密码就为空，不用专门去记）</li></ul><h4 id="当你再次按下‘回车’时，以下两个文件就会被建立了"><a href="#当你再次按下‘回车’时，以下两个文件就会被建立了" class="headerlink" title="当你再次按下‘回车’时，以下两个文件就会被建立了"></a>当你再次按下‘回车’时，以下两个文件就会被建立了</h4><pre><code class="xml">~/.ssh/id_rsa~/.ssh/id_rsa.pub</code></pre><h4 id="最后一步："><a href="#最后一步：" class="headerlink" title="最后一步："></a>最后一步：</h4><p>我们需要的 SSH 公钥存储在以.pub结尾的文件中，即：<br><code>~/.ssh/id_rsa.pub</code></p><h1 id="如何复制公共-SSH-密钥"><a href="#如何复制公共-SSH-密钥" class="headerlink" title="如何复制公共 SSH 密钥"></a>如何复制公共 SSH 密钥</h1><p>为了使用 GitHub 验证您自己和您的设备，您需要将上面生成的公共 SSH密钥 上传到你的 GitHub 帐户。</p><p><strong>复制公共SSH密钥</strong></p><p>你不需要去寻找这个 .pub 文件，你只需要打开终端并输入：</p><pre><code class="xml">$ pbcopy &lt; ~/.ssh/id_rsa.pub</code></pre><p>这将直接复制 <code>id_rsa</code> 文件内的内容。</p><h1 id="如何上传您的公共-SSH-密钥到-GitHub"><a href="#如何上传您的公共-SSH-密钥到-GitHub" class="headerlink" title="如何上传您的公共 SSH 密钥到 GitHub"></a>如何上传您的公共 SSH 密钥到 GitHub</h1><ol><li>复制了公共SSH密钥后，登录到GitHub帐户并转到 <a href="https://github.com/settings/profile" target="_blank" rel="noopener">https://github.com/settings/profile</a></li><li>在左侧菜单中，您将看到一个链接“SSH和GPG密钥”</li><li>单击该链接，它将带您进入一个页面，您可以在这里输入您之前复制的公共SSH密钥。</li><li>点击“新建SSH密钥”按钮</li><li>然后输入一个标题名称——可以是任何东西，例如 newMac</li><li>将公共SSH密钥粘贴到密钥文本框中</li><li>点击“添加SSH密钥”</li></ol><h1 id="大功告成！测试你的GitHub授权"><a href="#大功告成！测试你的GitHub授权" class="headerlink" title="大功告成！测试你的GitHub授权:"></a>大功告成！测试你的GitHub授权:</h1><p>打开你的终端输入</p><pre><code class="xml">$ git clone git@github.com:你的用户名/你的某个仓库名.git</code></pre><ol><li>它会问你是否想继续连接，输入 <code>yes</code></li><li>如果您在生成公钥时创建了一个密码，那么它将要求您输入它。</li><li>输入密码并按<code>Enter</code>键。</li><li>然后，它将开始将项目克隆到您当前的目录中。</li></ol><p><strong>现在，您已经准备好使用Git和GitHub了。有问题欢迎在评论区留言</strong></p><blockquote><p>欢迎关注我的博客获得更多知识</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mac</tag>
      
      <tag>SSH</tag>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每个人都要学的图片压缩终极奥义，有效解决 Android 程序 OOM</title>
    <link href="undefined2019/10/03/%E6%AF%8F%E4%B8%AA%E4%BA%BA%E9%83%BD%E8%A6%81%E5%AD%A6%E7%9A%84%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%BB%88%E6%9E%81%E5%A5%A5%E4%B9%89%EF%BC%8C%E6%9C%89%E6%95%88%E8%A7%A3%E5%86%B3%20Android%20%E7%A8%8B%E5%BA%8F%20OOM/"/>
    <url>2019/10/03/%E6%AF%8F%E4%B8%AA%E4%BA%BA%E9%83%BD%E8%A6%81%E5%AD%A6%E7%9A%84%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%BB%88%E6%9E%81%E5%A5%A5%E4%B9%89%EF%BC%8C%E6%9C%89%E6%95%88%E8%A7%A3%E5%86%B3%20Android%20%E7%A8%8B%E5%BA%8F%20OOM/</url>
    
    <content type="html"><![CDATA[<h1 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h1><hr><blockquote><p>在我们编写 <code>Android</code> 程序的时候，几乎永远逃避不了图片压缩的难题。除了应用图标之外，我们所要显示的图片基本上只有两个来源：</p><ul><li>来自网络下载</li><li>本地相册中加载</li></ul></blockquote><p>不管是网上下载下来的也好，还是从系统图片库中读取的图片，都有一个相同的特点：像素一帮较高。同时我们都知道，<code>Android</code> 系统分配给我们每个应用的内存是有限的，由于解析、加载一张图片，需要占用的内存大小，是远大于图片自身大小的。所以，这时程序就可能因为占用了过多的内存，从而出现<code>OOM</code> 现象。那么什么是 <code>OOM</code> 呢？</p><p><code>OOM</code> 即 <code>OutOfMemory</code> 异常，也就是我们所说的 内存溢出 ，其一般表现为应用闪退等现象。那么我们该如何下手去解决呢？</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><hr><p>首先我们发现，我们所加载的这些图片的分辨率，要比我们手机屏幕高得多，更有甚者，我们在一个拇指大的控件上，去加载一个 4k 大图是完全没有必要的，也就是说，如果我们能让每个控件上都去显示相应大小的图片，那么这个问题也就迎刃而解了</p><p>那么，要怎样才能达到图片与控件的对号入座？这时我们就引进了图片压缩的方案：</p><ul><li>首先，获得原图片大小</li><li>其次，获取控件大小</li><li>接着，获取我们图片和控件的比例</li><li>最后，根据这一比例，将图片压缩为适合显示的大小</li></ul><p>那么就让我们开始吧：</p><h1 id="获取原图大小"><a href="#获取原图大小" class="headerlink" title="获取原图大小"></a>获取原图大小</h1><hr><p>我们都知道，<code>Android 向我们提供了 BitmapFactory</code> 这个类，在这个类中有着诸如：<code>decodeResource()</code>  <code>decodeFile()</code>   <code>decodeStream()</code> 等。其中：</p><ul><li>decodeResource()  ：    用于解析资源文件，即 res 文件夹下的图片</li><li>decodeFile() ：               用于解析系统相册中的图片  </li><li>decodeStream() ：        用于解析输入输出流中图片通常，是采用 HttpClient 从下载的图片</li></ul><p>其他的方法这里就不多说了，因为在源码中我们可有i看到，几乎所有的方法，最后都会将图片解析为流的形式，最后调用 <code>decodeStream()</code> 方法，实例化出我们的 <code>Bitmap</code> 对象。</p><p>虽然这些方法对我们是再熟悉不过的了，但对于某些初学者而言，却经常忽略了一个重要的内部类 ：<code>BitmapFactory.Options</code> ，然而他确实我们图片压缩必不可少的，为什么需要这个参数呢？<code>Options</code> 的对象用于确定需要生成的 Bitmap 即目标图片的参数。<br>他的用法很简单，我们先 new 一个 <code>BitmapFactory.Options</code> 对象。再去调用含有 <code>Options</code> 参数的方法，如</p><ul><li><code>public static Bitmap decodeResource(Resources res, int id, Options opts)</code></li><li><code>public static Bitmap decodeResourceStream(@Nullable Resources res,@Nullable TypedValue value,@Nullable InputStream is, @Nullable Rect pad, @Nullable Options opts)</code></li></ul><p>调用完之后我们发现，除了方法放回给我们一个实例化出来的 <code>Bitmap</code> 图片之外，这个 <code>Options</code> 对象中长度、宽度、类型等等属性，也都被设置成了了我们图片的相应属性。所以，我们很容易想到：通过将 <code>Options</code> 对象传入，来获得图片的原始尺寸，为后期的压缩做准备，说干就干，我们将 <code>Options</code> 对象，和 <code>Resources</code>中一张 4k 图片的<code>id</code> 一块传入上诉方法中，来尝试获得它的尺寸，结果我们发现：程序 <code>OOM</code> 崩溃了！</p><p>为什么会发生这种情况？首先我们想想我们为什么要获得这个<code>Options</code> 对象？时为了获得图片的尺寸大小；那我们为什么要获得原图尺寸大小？是为了按照原图尺寸和控件尺寸的比例，将其压缩为适合显示的大小？那我们又为什么要去压缩它为合适的大小呢？是因为如果按照原大小去调用相应的 <code>decode...()</code>方法解析图片，会导致内存占有率过高触发<code>OOM</code> 异常，进而导致程序崩溃啊！没想到的是：结果我们为了获得 <code>Options</code> 而调用了相应的 <code>decode...()</code> 方法，的确 <code>Options</code> 是复制了，但由于该方法适用于生成图片，也就是 <code>Bitmap</code> 对象的。所以程序也在解析这张超大图的过程中<code>OOM</code> 崩溃了</p><p>那么难道就没方法了吗？</p><p>有的，我之前说过：<code>Option</code> 内部有着众多参数，其中有一个叫做：  <code>inJustDecodeBounds</code> 。这个参数默认值为<code>false</code> 。但如果我们先把这个参数设置为 true  时，该方法便不在会去生成相应的 <code>Bitmap</code> ，而仅仅是去测量图片的各种属性，如长度、宽度、类型等等，然后放回一个 <code>null</code> 。所以，我们很容易想到：可以先通过将 <code>inJustDecodeBounds</code> 的值设为 <code>true</code> ，再去调用相应的相应的 <code>decode...()</code>方法，最后再将<code>inJustDecodeBounds</code> 的值改回 <code>false</code> 。这种做法有两个好处：</p><ol><li>既能获得图片大小，由于后续操作</li><li>又成功避免了去解析图片，导致程序 <code>OOM</code> 而崩溃。</li></ol><p>但这恰恰是被很多人所忽略的一点。</p><h4 id="好了，现在给出具体的实现："><a href="#好了，现在给出具体的实现：" class="headerlink" title="好了，现在给出具体的实现："></a>好了，现在给出具体的实现：</h4><pre><code class="java">    public static void calculateOptionsById(@NonNull Resources res,@NonNull BitmapFactory.Options options, int imgId) {        BitmapFactory.decodeResource(res, imgId, options);    }</code></pre><blockquote><p>大家可能发现，这里只将 <code>inJustDecodeBounds</code> 设为<code>true</code>却没有改回<code>false</code> ，这是因为获得 <code>Options</code> 只是图片压缩的第一步，我们在后续方法中将会进行修改</p></blockquote><h1 id="如何进行压缩"><a href="#如何进行压缩" class="headerlink" title="如何进行压缩"></a>如何进行压缩</h1><hr><p>我们继续看 <code>Options</code> 的构成。我们发现，其中有个名为 <code>inSampleSize</code> 的数据成员，他就是关键所在，那么他有着什么意义呢？</p><p>这里我给大家举个例子，比如我这有张 4000*1000 像素的图片：</p><ul><li>当我们把 <code>inSampleSize</code>  的值设为 <code>4</code>时，最后生成出来的图片大小将会是：1000 x 250 像素 </li><li>当我们把<code>inSampleSize</code> 的值设为<code>5</code>时，最后生成出来的图片大小将会是：800 x 200 像素。这是个什么概念？</li></ul><p>这不仅仅是长宽都变为原来四分之一或者五分之一这么简单，而是其图片大小，直接变为原图的 <code>1/(n^2)</code>！也就是说：</p><ul><li>如果原图 <code>2MB</code>，那么当 <code>inSampleSize</code>  赋值为<code>4</code>加载时就只需要 <code>0.125MB</code></li><li>那 如果 <code>inSampleSize</code>  赋值为 <code>5</code> 呢？只需要 <code>0.08 MB</code>！连<code>100k</code> 都不到的小图啊！</li></ul><h4 id="那么下面我就给出这个方法的具体实现："><a href="#那么下面我就给出这个方法的具体实现：" class="headerlink" title="那么下面我就给出这个方法的具体实现："></a>那么下面我就给出这个方法的具体实现：</h4><pre><code class="java">    public static int calculateInSamplesizeByOptions(@NonNull BitmapFactory.Options options, int reqWidth, int reqHeight) {        int inSamplesize   = 1;        int originalWidth  = options.outWidth;        int originalHeight = options.outHeight;        if (originalHeight &gt; reqHeight || originalWidth &gt; reqWidth) {            int heightRatio = originalHeight / reqHeight;            int widthRatio  = originalWidth  / reqWidth;            inSamplesize = heightRatio &gt; widthRatio ? heightRatio : widthRatio;        }        return inSamplesize;    }</code></pre><p>我们发现，这里我先计算出了，原图尺寸与目标大小大比例，在三目运算符中，将<code>inSamplesize</code> 赋值为较大的一个。为什么不用小的那一个呢？这里我就卖个关子，大家可以在评论区中发表自己的想法</p><h1 id="生成目标图片"><a href="#生成目标图片" class="headerlink" title="生成目标图片"></a>生成目标图片</h1><hr><p>经过前面的两个步骤，想必大家已经能勾勒处这最后一步的做法了，思路非常简单：</p><ol><li>先生成一个 <code>Options</code>对象</li><li>将 <code>Options 的 inJustDecodeBounds</code>设置为<code>true</code></li><li>接着调用方法一<code>calculateOptionsById</code>获得原图尺寸到<code>Options</code>中</li><li>调用方法三<code>calculateInSamplesizeByOptions</code> 获得相应的<code>inSampleSize</code> 对象</li><li>将 <code>Options</code>的<code>inJustDecodeBounds</code>改回 <code>false</code></li><li>再次调用 <code>decode...()</code>方法（这里是 <code>decodeResource</code> ）获得压缩后的 <code>Bitmap</code>对象</li></ol><h4 id="具体实现如下"><a href="#具体实现如下" class="headerlink" title="具体实现如下"></a>具体实现如下</h4><pre><code class="java">    public static Bitmap decodeBitmapById (@NonNull Resources res, int resId, int reqWidth, int reqHeight) {        BitmapFactory.Options options = new BitmapFactory.Options();        options.inJustDecodeBounds = true;        calculateOptionsById(res, options, resId);        options.inSampleSize = calculateInSamplesizeByOptions(options, reqWidth, reqHeight);        options.inJustDecodeBounds = false;        Bitmap bitmap = BitmapFactory.decodeResource(res, resId, options);        return bitmap;    }</code></pre><p>非常棒，我们赶紧看看效果：</p><p><img src="https://img-blog.csdnimg.cn/2019100116455266.png" srcset="/img/loading.gif" alt></p><p>太棒了，几乎和原图效果一摸一样，但软件运行的流畅性确大大提高了！但是，这真的就完美了吗？</p><p>最求完美的我们可能会有个想法：如果调用我们方法的人，或者说特殊时候的我们。不想用这个已经写好的 <code>decodeBitmapById</code>方法，而是像自己通过前两个方法：<code>calculateOptionsById</code>  <code>calculateInSamplesizeByOptions</code> 来实现图片压缩功能，这是问题就出现了：</p><ul><li>调用 <code>calculateOptionsById</code>  前可能忘记，设置 <code>inJustDecodeBound</code> 为 <code>true</code> ，进而导致计算超大图时，直接发生 <code>OOM</code></li><li>调用完 <code>calculateInSamplesizeByOptions</code> 后可能忘记，设置<code>inJustDecodeBounds</code> 为 <code>false</code>，进而导致无法获得<code>Bitmap</code> 对象，一脸懵逼</li><li>啥都做了结果调用完 <code>calculateInSamplesizeByOptions</code> 没把没回的值赋给 <code>options.inSampleSize</code> ，白忙活一场</li></ul><p>所以，我们需要在优化一下：</p><p>首先，在<code>calculateOptionsById</code>中，默认将 <code>options.inJustDecodeBounds</code> 设置为<code>true</code>：</p><pre><code class="java">    public static void calculateOptionsById(@NonNull Resources res,@NonNull BitmapFactory.Options options, int imgId) {        options.inJustDecodeBounds = true;        BitmapFactory.decodeResource(res, imgId, options);    }</code></pre><p>其次，在 <code>calculateInSamplesizeByOptions</code>最后，默认将 <code>options.inJustDecodeBounds</code>设置为<code>false</code>：</p><pre><code class="java">    public static int calculateInSamplesizeByOptions(@NonNull BitmapFactory.Options options, int reqWidth, int reqHeight) {        int inSamplesize   = 1;        int originalWidth  = options.outWidth;        int originalHeight = options.outHeight;        if (originalHeight &gt; reqHeight || originalWidth &gt; reqWidth) {            int heightRatio = originalHeight / reqHeight;            int widthRatio  = originalWidth  / reqWidth;            inSamplesize = heightRatio &gt; widthRatio ? heightRatio : widthRatio;        }        options.inJustDecodeBounds = false;        return inSamplesize;    }</code></pre><p>为什么不在该方法后面，对 <code>options.inSampleSize</code>进行赋值呢？这主要是防止，有时我们可能只想得到计算相应比例来做其他操作，而不想改变原有属性，所以是否赋值，就交给用户去选择吧</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>好了，到这里为止，历时有关图片压缩的所有坑坑洼洼都已经总结好了，我们从头理以边思路：</p><ol><li>借助<code>options.inJustDecodeBounds</code> 参数赋值<code>true</code>时，不生成图片的特性，将原图尺寸保存在 <code>Options</code> 中</li><li>通过 <code>options</code> 中原图尺寸与目标（控件）尺寸的比例，对 <code>options.inSampleSize</code> 进行设置</li><li>生成目标图片</li><li>压缩的问题解决了，但是每次打开图片都压缩也太麻烦了！下面我将针对这个问题进行更有效地解决 ，有兴趣可以继续关注 <strong><a href="https://blog.csdn.net/qq_43377749" target="_blank" rel="noopener">_yuanhao 的编程世界</a></strong></li></ol><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><hr><p><a href="https://blog.csdn.net/qq_43377749/article/details/101197865" target="_blank" rel="noopener">Android 让你的 Room 搭上 RxJava 的顺风车 从重复的代码中解脱出来</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/100856599" target="_blank" rel="noopener">ViewModel 和 ViewModelProvider.Factory：ViewModel 的创建者</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/96324909" target="_blank" rel="noopener">单例模式-全局可用的 context 对象，这一篇就够了</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/94156207" target="_blank" rel="noopener">缩放手势 ScaleGestureDetector 源码解析，这一篇就够了</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/94155960" target="_blank" rel="noopener">看完这篇还不会 GestureDetector 手势检测，我跪搓衣板！</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/92629161" target="_blank" rel="noopener">Android 属性动画框架 ObjectAnimator、ValueAnimator ，这一篇就够了</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/92425865" target="_blank" rel="noopener">Android 逐帧动画（ Drawable 动画），这一篇就够了</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/91890323" target="_blank" rel="noopener">看完这篇再不会 View 的动画框架，我跪搓衣板</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/91474208" target="_blank" rel="noopener">Android 自定义时钟控件 时针、分针、秒针的绘制这一篇就够了</a></p><p><a href="https://blog.csdn.net/qq_43377749/article/details/91379915" target="_blank" rel="noopener">android 自定义控件之-绘制钟表盘</a></p><h3 id="请点赞！因为你的鼓励是我写作的最大动力！"><a href="#请点赞！因为你的鼓励是我写作的最大动力！" class="headerlink" title="请点赞！因为你的鼓励是我写作的最大动力！"></a>请点赞！因为你的鼓励是我写作的最大动力！</h3><hr><p>源码 Demo 链接：<strong><a href="https://github.com/FishInWater-1999/Drop/blob/master/app/src/main/java/com/example/drop/utils/BitmapBuilder.java" target="_blank" rel="noopener">Drop 我第一次写的 Android 项目，希望大家点歌 star~ 谢谢！</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OOM</tag>
      
      <tag>图片压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 让你的 Room 搭上 RxJava 的顺风车 从重复的代码中解脱出来</title>
    <link href="undefined2019/10/03/Android%20%E8%AE%A9%E4%BD%A0%E7%9A%84%20Room%20%E6%90%AD%E4%B8%8A%20RxJava%20%E7%9A%84%E9%A1%BA%E9%A3%8E%E8%BD%A6%20%E4%BB%8E%E9%87%8D%E5%A4%8D%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%A7%A3%E8%84%B1%E5%87%BA%E6%9D%A5/"/>
    <url>2019/10/03/Android%20%E8%AE%A9%E4%BD%A0%E7%9A%84%20Room%20%E6%90%AD%E4%B8%8A%20RxJava%20%E7%9A%84%E9%A1%BA%E9%A3%8E%E8%BD%A6%20%E4%BB%8E%E9%87%8D%E5%A4%8D%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%A7%A3%E8%84%B1%E5%87%BA%E6%9D%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-Room-？"><a href="#什么是-Room-？" class="headerlink" title="什么是 Room ？"></a>什么是 Room ？</h1><hr><p>谷歌为了帮助开发者解决 Android 架构设计问题，在 Google I/O 2017 发布一套帮助开发者解决 Android 架构设计的方案：Android Architecture Components，而我们的 Room 正是这套方案的两大模块之一。</p><ul><li>定义：数据库解决方案</li><li>组成：Database、Entity、DAO</li></ul><h1 id="为什么本文叫谷歌范例？"><a href="#为什么本文叫谷歌范例？" class="headerlink" title="为什么本文叫谷歌范例？"></a>为什么本文叫谷歌范例？</h1><hr><p>为了方便开发者进行学习和理解，Google 在 GitHub 上上传了一系列的 Android Architecture Components 开源代码：<a href="https://github.com/googlesamples/android-architecture-components" target="_blank" rel="noopener">googlesamples/android-architecture-components</a> 本文就是通过解析这套范例的第一部分：<a href="https://github.com/googlesamples/android-architecture-components/tree/master/BasicRxJavaSample" target="_blank" rel="noopener">BasicRxJavaSample</a> 来对 Room 的使用进行分析。</p><p>关于本文中的代码以及后续文章中的代码，我已经上传至我的 GitHub 欢迎大家围观、star<br>详见-&gt; <a href="https://github.com/FishInWater-1999/ArchitectureComponentsStudy" target="_blank" rel="noopener">FishInWater-1999/ArchitectureComponentsStudy</a></p><h1 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h1><hr><h4 id="为什么我们要学-Room"><a href="#为什么我们要学-Room" class="headerlink" title="为什么我们要学 Room"></a>为什么我们要学 Room</h4><p>相比于我们直接使用传统方式，如果直接使用 <code>Java</code> 代码进行 <code>SQLite</code> 操作，每次都需要手写大量重复的代码，对于我们最求梦想的程序员来说，这种无聊的过程简直是一种折磨。于是，<code>Room</code> 也就应运而生了</p><ul><li>它通过注解处理器的形式，将繁琐无趣的代码封装起来，我们只需要添加一个简单的注解，就可以完成一系列复杂的功能！</li></ul><blockquote><p>首先我们需要了解下 <code>Room</code> 的基本组成</p></blockquote><p>前面我们已经说过 Room 的使用，主要由 Database、Entity、DAO 三大部分组成，那么这三大组成部分又分别是什么呢？</p><ul><li>Database：创建一个由 Room 管理的数据库，并在其中自定义所需要操作的数据库表</li></ul><h6 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h6><pre><code>   1. 必须是abstract类而且的extends RoomDatabase。   2. 必须在类头的注释中包含与数据库关联的实体列表(Entity对应的类)。   3. 包含一个具有0个参数的抽象方法，并返回用@Dao注解的类。</code></pre><h6 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h6><p>通过单例模式实现，你可以通过静态 getInstance(…) 方法，获取数据库实例：</p><p><code>public static UsersDatabase getInstance(Context context)</code></p><ul><li><p>Entity：数据库中，某个表的实体类，如：<br><code>@Entity(tableName = &quot;users&quot;)</code><br><code>public class User {...}</code></p></li><li><p>DAO：具体访问数据库的方法的接口<br><code>@Dao</code><br><code>public interface UserDao {...}</code></p></li></ul><h1 id="BasicRxJavaSample-源码解析"><a href="#BasicRxJavaSample-源码解析" class="headerlink" title="BasicRxJavaSample 源码解析"></a>BasicRxJavaSample 源码解析</h1><hr><p>由于是源码解析，那我就以：从基础的类开始，一层层向上，抽丝剥茧，最后融为一体的方式，给大家进行解析。那么现在就让我们开始吧。</p><h4 id="表的搭建"><a href="#表的搭建" class="headerlink" title="表的搭建"></a>表的搭建</h4><p>Room 作为一个 Android 数据库操作的注解集合，最基本操作就是对我们数据库进行的。所以，先让我们试着建立一张名为 “users” 的数据表</p><pre><code class="java">/** * 应用测试的表结构模型 */@Entity(tableName = &quot;users&quot;)// 表名注解public class User {    /**     * 主键     * 由于主键不能为空，所以需要 @NonNull 注解     */    @NonNull    @PrimaryKey    @ColumnInfo(name = &quot;userid&quot;)// Room 列注解    private String mId;    /**     * 用户名     * 普通列     */    @ColumnInfo(name = &quot;username&quot;)    private String mUserName;    /**     * 构造方法     * 设置为 @Ignore 将其忽视     * 这样以来，这个注解方法就不会被传入 Room 中，做相应处理     * @param mUserName     */    @Ignore    public User(String mUserName){        this.mId    = UUID.randomUUID().toString();        this.mUserName = mUserName;    }    /**     * 我们发现与上个方法不同，该方法没有标记 @Ignore 标签     *      * 所以编译时该方法会被传入 Room 中相应的注解处理器，做相应处理     * 这里的处理应该是 add 新数据     * @param id     * @param userName     */    public User(String id, String userName) {        this.mId = id;        this.mUserName = userName;    }    public String getId() {        return mId;    }    public String getUserName() {        return mUserName;    }}</code></pre><p>首先在表头部分，我们就见到了之前说过的 <code>@Entity(...)</code> 标签，之前说过该标签表示数据库中某个表的实体类，我们查看它的源码：</p><pre><code class="java">@Target(ElementType.TYPE)@Retention(RetentionPolicy.CLASS)public @interface Entity {...}</code></pre><p>从中我们可以知道该注解实在编译注解所在的类时触发的，这是我们注意到 Google 对该类的介绍是：</p><pre><code class="xml">Marks a class as an entity. This class will have a mapping SQLite table in the database.</code></pre><p>由此可知当注解所在的类，比如我们的这个 <code>User</code> 类编译时，相应的注解处理器就会调用其内部相应的代码，建立一个名为 <code>users</code> （在 <code>@Entity(tableName = &quot;users&quot;)</code> 中传入的数据表 ）</p><p><strong>我们再往下看：</strong></p><ul><li>@ColumnInfo(name = “userid”) ：该注解注解的数据成员，将会在表中生成相应的名为：<code>userid</code> 的列</li><li>@PrimaryKey ：顾名思义该注解与<code>@ColumnInfo(name = &quot;...&quot;)</code> 注解一起使用，表示表中的主键，这里要注意一点，在 <code>@Entity</code> 的源码中强调：Each entity must have at least 1 field annotated with {@link PrimaryKey}. 也就是说一个被 <code>@Entity(...)</code>  标注的数据表类中至少要有一个主键</li><li>@Ignore ：被该注解注释的数据成员、方法，将会被注解处理器忽略，不进行处理</li></ul><p>这里我们发现，代码中有存在两个构造方法，为什么 GoogleSample 中会存在这种看似多此一举的情况呢？我们再仔细观察就会发想，上方的构造方法标记了 <code>@Ignore</code> 标签，而下方的构造方法却没有。由于在 <code>@Entity</code> 标注的类中，构造方法和列属性的 <code>get()</code> 方法都会被注解处理器自动识别处理。我们就不难想到，Google 之所以这样设计，是因为我们于是需要创建临时的 <code>User</code> 对象，但我们又不希望 <code>@Entity</code> 在我们调用构造方法时，就将其存入数据库。所以我们就有了这个被 <code>@Ignore</code> 的构造方法，用于创建不被自动存入数据库的临时对象，等到我们想将这个对象存入数据库时，调用<code>User(String id, String userName)</code> 即可。</p><h4 id="UserDao"><a href="#UserDao" class="headerlink" title="UserDao"></a>UserDao</h4><p>上面我们通过 <code>@Entity</code> 建立了一张 <code>users</code> 表，下面就让我们用 <code>@Dao</code> 注解来变写 <code>UserDao</code> 接口。</p><pre><code class="java">@Daopublic interface UserDao {    /**     * 为了简便，我们只在表中存入1个用户信息     * 这个查询语句可以获得 所有 User 但我们只需要第一个即可     * @return     */    @Query(&quot;SELECT * FROM Users LIMIT 1&quot;)    Flowable&lt;User&gt; getUser();    /**     * 想数据库中插入一条 User 对象     * 若数据库中已存在，则将其替换     * @param user     * @return     */    @Insert(onConflict = OnConflictStrategy.REPLACE)    Completable insertUser(User user);    /**     * 清空所有数据     */    @Query(&quot;DELETE FROM Users&quot;)    void deleteAllUsers();}</code></pre><p>按照我们正常编写的习惯，我们会在该类中，编写相应的数据库操作代码。但与之不同的是采用 <code>Room</code> 之后，我们将其变为一个接口类，并且只需要编写和设定相应的标签即可，不用再去关心存储操作的具体实现。</p><pre><code class="java">    /**     * 为了简便，我们只在表中存入1个用户信息     * 这个查询语句可以获得 所有 User 但我们只需要第一个即可     * @return     */    @Query(&quot;SELECT * FROM Users LIMIT 1&quot;)    Flowable&lt;User&gt; getUser();</code></pre><p> 这里我们看到，该查询方法使用的是 <code>@Query</code> 注解，那么这个注解的具体功能是什么呢？Google 官方对它的解释是：在一个被标注了 <code>@Dao</code> 标签的类中，用于查询的方法。顾名思义被该注解标注的方法，会被 <code>Room</code> 的注解处理器识别，当作一个数据查询方法，至于具体的查询逻辑并不需要我们关心，我们只需要将 <code>SQL 语句</code> 作为参数，传入 <code>@Query(...)</code> 中即可。之后我们发现，该方法返回的是一个背压 <code>Flowable&lt;...&gt;</code> 类型的对象，这是为了防止表中数据过多，读取速率远大于接收数据，从而导致内存溢出的问题，具体详见 <code>RxJava</code> 的教程，这里我就不赘述了。</p><pre><code class="java">    /**     * 想数据库中插入一条 User 对象     * 若数据库中已存在，则将其替换     * @param user     * @return     */    @Insert(onConflict = OnConflictStrategy.REPLACE)    Completable insertUser(User user);</code></pre><p>我们看到，上述方法被 <code>@Insert</code> 注解所标注，从名字就能看出，这将会是一个插入方法。顾名思义被 <code>@Insert</code> 标注的方法，会用于向数据库中插入数据，唯一让我们迷茫的是括号中的这个 <code>onConflict</code>  参数，<code>onConflict</code>  意为“冲突”，再联想下我们日常生活中的数据库操作，就不难想到：这是用来设定，当插入数据库中的数据，与原数据发生冲突时的处理方法。这里我们传入的是 <code>OnConflictStrategy.REPLACE</code> ，意为“如果数据发生冲突，则用其替换掉原数据”，除此之外还有很多相应操作的参数，比如<code>ROLLBACK</code> <code>ABORT</code> 等，篇幅原因就不详细说明了，大家可以自行查阅官方文档。还有一点值得说的是这个 <code>Completable</code> ，该返回值是 <code>RxJava</code> 的基本类型，它只处理 <code>onComplete</code> <code>onError</code> 事件，可以看成是Rx的Runnable。</p><pre><code class="java">    /**     * 清空所有数据     */    @Query(&quot;DELETE FROM Users&quot;)    void deleteAllUsers();</code></pre><p>最后这个方法就是清空 <code>users</code> 表中的所有内容，很简单，这里就不做说明了。唯一需要注意的是，这里使用了 <code>DELETE FROM 表名</code> 的形式，而不是 <code>truncate table 表名</code> ，区别就在于：效率上<code>truncate</code>比<code>delete</code>快，但<code>truncate</code> 相当于保留表的结构，重新创建了这个表，所以删除后不记录日志，不可以恢复数据。</p><h4 id="UsersDatabase"><a href="#UsersDatabase" class="headerlink" title="UsersDatabase"></a>UsersDatabase</h4><p>有关于 <code>Room</code> 的三大组成我们已经讲完了两个，现在就让我们看看最后一个 <code>@Database</code> 注解：</p><pre><code class="java">@Database(entities = {User.class}, version = 1, exportSchema = false)public abstract class UsersDatabase extends RoomDatabase {    /**     * 单例模式     * volatile 确保线程安全     * 线程安全意味着改对象会被许多线程使用     * 可以被看作是一种 “程度较轻的 synchronized”     */    private static volatile UsersDatabase INSTANCE;    /**     * 该方法由于获得 DataBase 对象     * abstract     * @return     */    public abstract UserDao userDao();    public static UsersDatabase getInstance(Context context) {        // 若为空则进行实例化        // 否则直接返回        if (INSTANCE == null) {            synchronized (UsersDatabase.class) {                if (INSTANCE == null){                    INSTANCE = Room.databaseBuilder(context.getApplicationContext(),                            UsersDatabase.class, &quot;Sample.db&quot;)                            .build();                }            }        }        return INSTANCE;    }}</code></pre><p>老样子， <code>Google</code> 定义中是这么写的：将一个类标记为 <code>Room</code> 数据库。顾名思义，我们需要在标记了该标签的类里，做具体的数据库操作，比如数据库的建立、版本更新等等。我们看到，我们向其中传入了多个参数，包括：<code>entities</code> 以数组结构，标记一系列数据库中的表，这个例子中我们只有一个 <code>User</code> 表，所以只传入一个； <code>version</code> 数据库版本；<code>exportSchema</code> 用于历史版本库的导出</p><pre><code class="java">    /**     * 单例模式     * volatile 确保线程安全     * 线程安全意味着改对象会被许多线程使用     * 可以被看作是一种 “程度较轻的 synchronized”     */    private static volatile UsersDatabase INSTANCE;</code></pre><p> 可以看出这是一个单例模式，用于创建一个全局可获得的 UsersDatabase 对象。</p><pre><code class="java">    public static UsersDatabase getInstance(Context context) {        // 若为空则进行实例化        // 否则直接返回        if (INSTANCE == null) {            synchronized (UsersDatabase.class) {                if (INSTANCE == null){                    INSTANCE = Room.databaseBuilder(context.getApplicationContext(),                            UsersDatabase.class, &quot;Sample.db&quot;)                            .build();                }            }        }        return INSTANCE;    }</code></pre><p>这是单例模式对象 INSTANCE 的获得方法，不明白的同学可以去看我这篇 <a href="https://blog.csdn.net/qq_43377749/article/details/96324909" target="_blank" rel="noopener">单例模式-全局可用的 context 对象，这一篇就够了</a></p><h4 id="UserDataSource"><a href="#UserDataSource" class="headerlink" title="UserDataSource"></a>UserDataSource</h4><p>我们可以看到：绝大多数的数据库操作方法，都定义在了 <code>UserDao</code> 中，虽然一般注解类的方法不会被继承，但是有些被特殊标记的方法可能会被继承，但是我们之后要建立的很多功能类中，都需要去调用 <code>UserDao</code> 里的方法。所以我们这里定义 <code>UserDataSource</code> 接口：</p><pre><code class="java">public interface UserDataSource {    /**     * 从数据库中读取信息     * 由于读取速率可能 远大于 观察者处理速率，故使用背压 Flowable 模式     * Flowable：https://www.jianshu.com/p/ff8167c1d191/     */    Flowable&lt;User&gt; getUser();    /**     * 将数据写入数据库中     * 如果数据已经存在则进行更新     * Completable 可以看作是 RxJava 的 Runnale 接口     * 但他只能调用 onComplete 和 onError 方法，不能进行 map、flatMap 等操作     * Completable：https://www.jianshu.com/p/45309538ad94     */    Completable insertOrUpdateUser(User user);    /**     * 删除所有表中所有 User 对象     */    void  deleteAllUsers();}</code></pre><p>该接口很简单，就是一个工具，方法和  <code>UserDao</code>  一摸一样，这里我们就不赘述了。</p><h4 id="LocalUserDataSource"><a href="#LocalUserDataSource" class="headerlink" title="LocalUserDataSource"></a>LocalUserDataSource</h4><pre><code class="java">public class LocalUserDataSource implements UserDataSource {    private final UserDao mUserDao;    public LocalUserDataSource(UserDao userDao) {        this.mUserDao = userDao;    }    @Override    public Flowable&lt;User&gt; getUser() {        return mUserDao.getUser();    }    @Override    public Completable insertOrUpdateUser(User user) {        return mUserDao.insertUser(user);    }    @Override    public void deleteAllUsers() {        mUserDao.deleteAllUsers();    }}</code></pre><p>我们先看看官方的解析：“使用 <code>Room</code> 数据库作为一个数据源。”即通过该类的对象所持有的 <code>UserDao</code> 对象，进行数据库的增删改查操作。</p><ul><li>到此为止，有关于 Room 对数据库的操作部分就讲完了，接下来我们进行视图层搭建的解析。</li></ul><hr><h4 id="UserViewModel"><a href="#UserViewModel" class="headerlink" title="UserViewModel"></a>UserViewModel</h4><p>首先我们先实现 <code>ViewModel</code> 类，那什么是 <code>ViewModel</code> 类呢？从字面上理解的话，它肯定是跟视图 <code>View</code> 以及数据 <code>Model</code> 相关的。其实正像它字面意思一样，它是负责准备和管理和UI组件 <code>Fragment/Activity</code> 相关的数据类，也就是说 <code>ViewModel</code> 是用来管理UI相关的数据的，同时 <code>ViewModel</code> 还可以用来负责UI组件间的通信。那么现在就来看看他的具体实现：</p><pre><code class="java">public class UserViewModel extends ViewModel {    /**     * UserDataSource 接口     */    private final UserDataSource mDataSource;    private User mUser;    public UserViewModel(UserDataSource dataSource){        this.mDataSource = dataSource;    }    /**     * 从数据库中读取所有 user 名称     * @return 背压形式发出所有 User 的名字     *     * 由于数据库中 User 量可能很大，可能会因为背压导致内存溢出     * 故采用 Flowable 模式，取代 Observable     */    public Flowable&lt;String&gt; getUserName(){        return mDataSource.getUser()                .map(new Function&lt;User, String&gt;() {                    @Override                    public String apply(User user) throws Exception {                        return user.getUserName();                    }                });    }    /**     * 更新/添加 数据     *     * 判断是否为空，若为空则创建新 User 进行存储     * 若不为空，说明该 User 存在，这获得其主键 &#39;getId()&#39; 和传入的新 Name 拼接，生成新 User 存储     * 通过 insertOrUpdateUser 接口，返回 Comparable 对象，监听是否存储成功     * @param userName     * @return     */    public Completable updateUserName(String userName) {        mUser = mUser == null                ? new User(userName)                : new User(mUser.getId(), userName);        return mDataSource.insertOrUpdateUser(mUser);    }}</code></pre><p>代码结构非常简单，<code>mDataSource</code> 就是我们前面建立的 <code>UserDataSource</code> 接口对象，由于我们的数据库操作控制类：<code>LocalUserDataSource</code> 是通过是实现该接口的，所以我们就可以在外部将 <code>LocalUserDataSource</code> 对象传入，从而对他的方法进行相应的回调，也就是先实现了所需的数据库操作。每个方法的功能，我已经在注释中给出，这里就不再赘述</p><h4 id="ViewModelFactory"><a href="#ViewModelFactory" class="headerlink" title="ViewModelFactory"></a>ViewModelFactory</h4><p>有上面我们可以看到，我们已经有了进行数据处理的 <code>ViewModel</code> 类，那么我们这里的 <code>ViewModelFactory</code> 类又有什么作用呢？让我们先看下范例中的实现：</p><pre><code class="java">public class ViewModelFactory implements ViewModelProvider.Factory {    private final UserDataSource mDataSource;    public ViewModelFactory(UserDataSource dataSource) {        mDataSource = dataSource;    }    // 你需要通过 ViewModelProvider.Factory 的 create 方法来创建(自定义的) ViewModel    // 参考文档：https://medium.com/koderlabs/viewmodel-with-viewmodelprovider-factory-the-creator-of-viewmodel-8fabfec1aa4f    @Override    public &lt;T extends ViewModel&gt; T create(@NonNull Class&lt;T&gt; modelClass) {        // 为什么这里用 isAssignableFrom 来判断传入的 modelClass 类的类型， 而不直接用 isInstance 判断？        // 答：二者功能一样，但如果传入值（modelClass 为空）则 isInstance 会报错奔溃，而 isAssignableFrom 不会        if (modelClass.isAssignableFrom(UserViewModel.class)) {            return (T) new UserViewModel(mDataSource);        }        throw new IllegalArgumentException(&quot;Unknown ViewModel class&quot;);    }}</code></pre><p><code>ViewModelFactory</code> 继承自 <code>ViewModelProvider.Factory</code> ，它负责帮你创建 <code>ViewModel</code> 实例。但你也许会问，我们不是已经有了 <code>ViewModel</code> 的构造方法了吗？在用 <code>ViewModelFactory</code> 不是多此一举？如果还不熟悉 <code>ViewModelFactory</code> 有关内容的，可以看下这篇：<a href="https://blog.csdn.net/qq_43377749/article/details/100856599" target="_blank" rel="noopener">ViewModel 和 ViewModelProvider.Factory：ViewModel 的创建者</a></p><h4 id="Injection"><a href="#Injection" class="headerlink" title="Injection"></a>Injection</h4><p>关于 <code>Injection</code> ，这是个帮助类，它和 Room 的逻辑功能并没有关系。<code>Sample</code> 中将其独立出来用于各个对象、类型的注入，先让我们看下该类的实现：</p><pre><code class="java">public class Injection {    /**     * 通过该方法实例化出能操作数据库的 LocalUserDataSource 对象     * @param context     * @return     */    public static UserDataSource provideUserDateSource(Context context) {        // 获得 RoomDatabase        UsersDatabase database = UsersDatabase.getInstance(context);        // 将可操作 UserDao 传入        // 实例化出可操作 LocalUserDataSource 对象方便对数据库进行操作        return new LocalUserDataSource(database.userDao());    }    /**     * 获得 ViewModelFactory 对象     * 为 ViewModel 实例化作准备     * @param context     * @return     */    public static ViewModelFactory provideViewModelFactory(Context context) {        UserDataSource dataSource = provideUserDateSource(context);        return new ViewModelFactory(dataSource);    }}</code></pre><p>该类有两个方法组成，实现了各个类型数据相互间的转换，想再让我们先看下第一个方法：</p><pre><code class="java">    /**     * 通过该方法实例化出能操作数据库的 LocalUserDataSource 对象     * @param context     * @return     */    public static UserDataSource provideUserDateSource(Context context) {        // 获得 RoomDatabase        UsersDatabase database = UsersDatabase.getInstance(context);        // 将可操作 UserDao 传入        // 实例化出可操作 LocalUserDataSource 对象方便对数据库进行操作        return new LocalUserDataSource(database.userDao());    }</code></pre><p>在该方法中，我们首先接到了我们的 <code>context</code> 对象，通过 <code>UsersDatabase.getInstance(context)</code> 方法，让 <code>database</code> 持有 <code>context</code> ，实现数据库的链接和初始化。同时放回一个 <code>LocalUserDataSource</code> 对象，这样一来我们就可以对数据表中的内容惊醒相应的操作。</p><pre><code class="java">    /**     * 获得 ViewModelFactory 对象     * 为 ViewModel 实例化作准备     * @param context     * @return     */    public static ViewModelFactory provideViewModelFactory(Context context) {        UserDataSource dataSource = provideUserDateSource(context);        return new ViewModelFactory(dataSource);    }</code></pre><p>该方法的功能非常明确，就是为我们实例化出一个 <code>ViewModelFactory</code> 对象，为我们往后创建 <code>ViewModel</code> 作准备。可以看到，这里我们调用了前面的 <code>provideUserDateSource</code> 方法，通过该方法获得了对数据库操作的 <code>LocalUserDataSource</code> 对象，这里我们就看到了单例模式使用的先见性，使得数据库不会被反复的创建、连接。</p><ul><li>好了，至此所有准备工作都已经完成，让我们开始视图层 UserActivity 的调用</li><li>由于 <code>UserActivity</code> 的内容较多我就不贴完整的代码，我们逐步进行讲解</li></ul><hr><h4 id="准备数据成员"><a href="#准备数据成员" class="headerlink" title="准备数据成员"></a>准备数据成员</h4><p>首先我们准备了所需的给类数据成员：</p><pre><code class="java">    private static final String TAG = UserActivity.class.getSimpleName();    private TextView mUserName;    private EditText mUserNameInput;    private Button mUpdateButton;    // 一个 ViewModel 用于获得 Activity &amp; Fragment 实例    private ViewModelFactory mViewModelFactory;    // 用于访问数据库    private UserViewModel mViewModel;    // disposable 是订阅事件，可以用来取消订阅。防止在 activity 或者 fragment 销毁后仍然占用着内存，无法释放。    private final CompositeDisposable mDisposable = new CompositeDisposable();</code></pre><ul><li>首先界面操作的各个控件</li><li>接这就是 <code>mViewModelFactory</code> 、 <code>mViewModel</code> 两个数据成员，用于负责数据源的操作</li><li>再就是一个 <code>CompositeDisposable</code> 对象，用于管理订阅事件，防止 Activity 结束后，订阅仍在进行的情况</li></ul><h4 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate"></a>onCreate</h4><p>控件、数据源层、数据库等的初始化</p><pre><code class="java">    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_user);        mUserName = findViewById(R.id.user_name);        mUserNameInput = findViewById(R.id.user_name_input);        mUpdateButton = findViewById(R.id.update_user);        // 实例化 ViewModelFactory 对象，准备实例化 ViewModel        mViewModelFactory = Injection.provideViewModelFactory(this);        mViewModel = new ViewModelProvider(this, mViewModelFactory).get(UserViewModel.class);        mUpdateButton.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                updateUserName();            }        });    }</code></pre><ul><li>首先是各类控件的初始化</li><li>接着是 <code>ViewModel</code> 的初始化，在这过程中，也就实现了数据库的链接</li><li>用户信息按钮监听器绑定，点击执行 <code>updateUserName</code> 方法如下</li></ul><h4 id="updateUserName"><a href="#updateUserName" class="headerlink" title="updateUserName"></a>updateUserName</h4><p>修改数据库中用户信息</p><pre><code class="java">    private void updateUserName() {        String userName = mUserNameInput.getText().toString();        // 在完成用户名更新之前禁用“更新”按钮        mUpdateButton.setEnabled(false);        // 开启观察者模式        // 更新用户信息，结束后重新开启按钮        mDisposable.add(mViewModel.updateUserName(userName)        .subscribeOn(Schedulers.io())        .observeOn(AndroidSchedulers.mainThread())        .subscribe(new Action() {            @Override            public void run() throws Exception {                mUpdateButton.setEnabled(true);            }        }, new Consumer&lt;Throwable&gt;() {            @Override            public void accept(Throwable throwable) throws Exception {                Log.d(TAG, &quot;accept: Unable to update username&quot;);            }        }));    }</code></pre><ul><li>获得新的用户名</li><li>将按钮设为不可点击</li><li>在 <code>io</code> 线程中访问数据库进行修改</li><li>切换到主线程进行相应处理，比如让按钮恢复到可点击状态</li></ul><h4 id="onStart"><a href="#onStart" class="headerlink" title="onStart"></a>onStart</h4><p>初始化用户信息，修改 <code>UI</code> 界面内容</p><pre><code class="java">    @Override    protected void onStart() {        super.onStart();        // 观察者模式        // 通过 ViewModel 从数据库中读取 UserName 显示        // 如果读取失败，显示错误信息        mDisposable.add(mViewModel.getUserName()                .subscribeOn(Schedulers.io())                .observeOn(AndroidSchedulers.mainThread())        .subscribe(new Consumer&lt;String&gt;() {            @Override            public void accept(String s) throws Exception {                mUserName.setText(s);            }        }, new Consumer&lt;Throwable&gt;() {            @Override            public void accept(Throwable throwable) throws Exception {                Log.e(TAG, &quot;Unable to update username&quot;);            }        }));    }</code></pre><ul><li>在 <code>io</code> 线程中进行数据库访问</li><li>切换到主线程，修改 <code>UI</code> 信息</li></ul><h4 id="onStop"><a href="#onStop" class="headerlink" title="onStop"></a>onStop</h4><p>取消订阅</p><pre><code class="java">    @Override    protected void onStop() {        super.onStop();        // 取消订阅。防止在 activity 或者 fragment 销毁后仍然占用着内存，无法释放。        mDisposable.clear();    }</code></pre><ul><li>通过我们之前实例化的 <code>CompositeDisposable</code> 对象，解除订阅关系</li></ul><hr><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h4 id="Demo-地址"><a href="#Demo-地址" class="headerlink" title="Demo 地址"></a>Demo 地址</h4><p><a href="https://github.com/FishInWater-1999/ArchitectureComponentsStudy" target="_blank" rel="noopener">ArchitectureComponentsStudy</a></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>学会使用 <code>Android Architecture Components</code> 提供的组件简化我们的开发，能够使我们开发的应用模块更解耦更稳定，视图与数据持久层分离，以及更好的扩展性与灵活性。最后，码字不易，别忘了点个赞哦</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Room</tag>
      
      <tag>RxJava</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>